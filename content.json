{"pages":[{"title":"所有分类","text":"","link":"/categories/index.html"},{"title":"关于","text":"🍭关于我 AzuSemisa，常以xiaolin_，Segment_Tree_等用户名出现在网络上 名字由炮姐（Misaka），艾米莉亚碳（Emilia），咲太师傅（Azusagawa）融合而来 初二党，坐标SC-CD，二次元爱好者，除了是一名信息学竞赛生外，更多的还是一名文化课选手（我也不知道当初为什么没选竞赛班选了实验班 擅长划水，颓废，经常模拟赛爆零，是个蒟蒻 爱好有点杂，有闲时喜欢捣鼓一下博客，看看番，听听歌，偶尔会读读书，还喜欢玩MC（慢慢往肥宅的方向发展了 🎨关于本站 建于2020年1月18日，主要发一些题解、笔记和奇奇怪怪的东西 使用Hexo作为框架，Volantis作为主题 托管于Coding和Vercel(ZEIT) 由Github提供源码托管 域名相关服务由腾讯云提供支持 由jsDelivr提供大部分CDN服务","link":"/about/index.html"},{"title":"友链","text":"加载中，稍等几秒... 如何添加友链？ 请首先添加我的友链，然后在这个页面下方的评论区里申请，申请格式： 1234&quot;name&quot;: &quot;AzuSemisa&quot;,&quot;avatar&quot;: &quot;https://cdn.jsdelivr.net/gh/xiao-lin52/cdn-assets/images/avatar.webp&quot;,&quot;url&quot;: &quot;https://azusemisa.top&quot;,&quot;desc&quot;: &quot;一个OI蒟蒻的小窝&quot; 为了方便笔者添加友链，请遵从这个格式，谢谢！😆 注意事项！ 任何网址都可添加友链，包括但不限于博客，各类网站的主页，只要没有违法内容，都可以申请添加！😘 无论您是大佬，神仙，还是萌新，蒟蒻，抑或是文化课选手，都来者不拒，欢迎互换友链！😉 既然是互换友链，那么希望您能遵守承诺，如果您撤下了我的友链，那么相应的，您的友链也会被撤下，如果有特殊情况，可以在评论里留言。😏 如果您对笔者感兴趣，可以加笔者的微信，加的时候请说明您是从我的博客来的否则有可能被当成骗子🤗 最后，感谢您能访问我的小站🌹","link":"/friends/index.html"},{"title":"留言","text":"Your browser does not support the video tag. 欢迎来到我的小窝，在这里留下你的足迹吧😄 建议、问题都可以提出来，也可以一起聊一些OI的话题 有什么不对的地方我也会尽量想办法解决的","link":"/message/index.html"},{"title":"所有标签","text":"","link":"/tags/index.html"}],"posts":[{"title":"【CodeForces 163A】 Substring and Subsequence","text":"印象中好像是唯一一道自己做对的除背包以外的线性DP题（我太菜了QAQ），因此想写篇题解纪念一下 题目大意 题目传送门 翻译有点问题，我这里重新翻一下 大概意思就是说，给你两个字符串sss和ttt，求出有多少对字符串xxx和yyy，满足xxx是sss的子串且yyy是ttt的子序列，答案对1000000007(109+7)1000000007(10^9+7)1000000007(109+7)取模 关于子串和子序列的区别，可以理解为子串是一段连续的区间，而子序列则不一定是连续的 思路 这道题乍一看其实很像最长公共子序列，唯一不同的在于对于sss要取它的子串，我们类比一下最长公共子序列的状态转移方程 dp[i,j]={0 (i=0 or j=0)dp[i−1,j−1]+1 (s[i]=t[j])max⁡(dp[i−1,j],dp[i,j−1]) (s[i]≠t[j])dp[i,j]=\\begin{cases}0\\ (i=0 \\text{ or }j=0)\\\\dp[i-1,j-1]+1\\ (s[i]=t[j])\\\\\\max(dp[i-1,j],dp[i,j-1])\\ (s[i]\\not =t[j])\\end{cases} dp[i,j]=⎩⎪⎨⎪⎧​0 (i=0 or j=0)dp[i−1,j−1]+1 (s[i]=t[j])max(dp[i−1,j],dp[i,j−1]) (s[i]​=t[j])​ dp[i,j]dp[i,j]dp[i,j]表示的是在sss的前iii个字符和ttt的前jjj个字符中的最长公共子序列的长度，因此，对于这道题，我们不妨设dp[i,j]dp[i,j]dp[i,j]为以sss的第iii个字符为结尾的子串与ttt的前jjj个字符中的子序列相同的个数，同样，我们分成两种情况来讨论，一种是s[i]=t[j]s[i]=t[j]s[i]=t[j]，一种是s[i]≠t[j]s[i]\\not =t[j]s[i]​=t[j] 如果s[i]=t[j]s[i]=t[j]s[i]=t[j]，那么当前状态首先应该包括了dp[i−1,j−1]dp[i-1,j-1]dp[i−1,j−1]的所有情况，因为这两个字符是相同的，那么我们相当于是可以在dp[i−1,j−1]dp[i-1,j-1]dp[i−1,j−1]的所有情况后面加上一个相同的字符，结果一定还是成立的，然后还应该包括dp[i,j−1]dp[i,j-1]dp[i,j−1]的所有情况，因为不管当前两个字符是否相同，dp[i,j−1]dp[i,j-1]dp[i,j−1]的所有情况肯定都适用于dp[i,j]dp[i,j]dp[i,j]，最后，dp[i,j]dp[i,j]dp[i,j]还应该包括s[i]s[i]s[i]和t[j]t[j]t[j]这对组合，因为很明显前面两种情况都没有把t[j]t[j]t[j]算进去，所以最后的状态转移方程应该是这样的 dp[i,j]=dp[i,j−1]+dp[i−1,j−1]+1dp[i,j]=dp[i,j-1]+dp[i-1,j-1]+1 dp[i,j]=dp[i,j−1]+dp[i−1,j−1]+1 如果s[i]≠t[j]s[i]\\not = t[j]s[i]​=t[j]，那么上面所说的dp[i−1,j−1]dp[i-1,j-1]dp[i−1,j−1]的情况就不适用于当前情况，也没有s[i]s[i]s[i]和t[j]t[j]t[j]这对组合，所以状态转移方程就是这样的 dp[i,j]=dp[i,j−1]dp[i,j]=dp[i,j-1] dp[i,j]=dp[i,j−1] 最后，由于dp[i,j]dp[i,j]dp[i,j]只统计了以s[i]s[i]s[i]为结尾的子串，所以最终答案应该把所有的dp[i,∣s∣]dp[i,|s|]dp[i,∣s∣]加起来，另外，不要忘记取模 参考代码 其实只要搞清楚状态转移方程了，代码什么的就很好写了，这就是你懒得写注释的理由吗！，关键是要理解思路 12345678910111213141516171819202122#include&lt;bits/stdc++.h&gt;#define mod 1000000007using namespace std;string a,b;int n,m,ans,dp[5001][5001];int main(){ getline(cin,a); getline(cin,b); n=a.length(); m=b.length(); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) if(a[i-1]==b[j-1]) dp[i][j]=(dp[i][j-1]+dp[i-1][j-1]+1)%mod;//取模！！ else dp[i][j]=dp[i][j-1]; for(int i=1;i&lt;=n;i++) ans=(ans+dp[i][m])%mod; printf(&quot;%d&quot;,ans); return 0;}","link":"/posts/3200880746.html"},{"title":"【CodeForces 827A】 String Reconstruction","text":"其实说实话，在看到这道题时，我并没有想到要用并查集做，我觉得，这道题其实可以暴力。 当然并不是说每输入一个字符串的起始位置就开始暴力更改这个区间，这样肯定是会T的。 我所说的暴力呢，是说在每个区间开始的位置标记这个区间是第几个字符串，如果有多个，就取其中最长的一个（因为根据题目要求一定存在符合要求的字符串，所以最长的一定包含了短的），然后最后在输出的时候判断一下该输出哪个字符串就行了。 那么不属于任何一个区间的地方呢？直接输出a不就完了！还有什么小写字母字符串是比全是a的字符串的字典序还要小呢？ 注意！在输出过程中，如果遇到这个区间还没输出完，又到了另外一个区间的开始位置时，一定要判断当前正在输出的这个字符串能否将遇到的这个区间的字符串完全包含！如果不能，就立马退出，再输出从这个位置开始的字符串。 思路还是很简单的，代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;using namespace std;int n,k,x,m,a[10000001];//a数组标记每个区间所对应的字符串的下标，这个数组一定要开大一点，否则会REstring t[100001];int main(){ scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) { cin&gt;&gt;t[i]&gt;&gt;k; for(int j=1;j&lt;=k;j++) { scanf(&quot;%d&quot;,&amp;x); if(t[a[x]].length()&lt;t[i].length())//如果已有区间从x开始，则比较两字符串的长度 a[x]=i; m=max(m,x); } } int i=1; while(i&lt;=m) { if(!a[i])//如果当前点不属于任何一个区间，输出'a' printf(&quot;a&quot;); else { int j; for(j=0;j&lt;t[a[i]].length();j++)//输出当前区间的字符串 { if(t[a[i+j]].length()+j&gt;t[a[i]].length())//如果遇到另一个区间的开始，且无法完全包含，则退出，因为a默认为0，所以即使不是另一个区间的开始也没有问题 break; else printf(&quot;%c&quot;,t[a[i]][j]); } i+=j; continue; } i++; } return 0;}","link":"/posts/1841004241.html"},{"title":"【CodeForces 609E】 Minimum spanning tree for each edge","text":"题意很清楚，给定一张带权无向图，对于图上的每一条边，询问包括这一条边的生成树中边权权值之和最小的。 首先想到的方法是每次都先把要求的这条边加入最小生成树，然后跑一遍 Kruskal，但用膝盖想一下都知道这样肯定是会 T 飞的，所以我们可以直接在原来的最小生成树上进行修改，也就是说，把这一条边强行塞进最小生成树，由于这样很明显会形成一个环，所以我们还需要从这个环里再删掉一条边。 假设此时这条边连接的是 uuu 和 vvv 两个点，则从 uuu 到 vvv 的最短路径应该会经过 LCA(u,v)\\text{LCA}(u,v)LCA(u,v)，所以这个环应该是从 uuu 到 LCA(u,v)\\text{LCA}(u,v)LCA(u,v) 再到 vvv 最后回到 uuu，因此，我们需要删掉的边应该是在从 uuu 到 LCA(u,v)\\text{LCA}(u,v)LCA(u,v) 再到 vvv 这条路径上，又因为要求新的最小生成树的权值和最小，所以我们应该尽量删掉权值较大的边。 因此，这道题就变成了先求出最小生成树，然后对于每一条边，询问其两个端点在树上的最短路径中边权最大的边。 这种问题本来可以用树剖做，但由于没有修改操作，不需要那么麻烦其实就是懒，使用倍增求 LCA，在求每个点的第 2i2^i2i 个父亲的时候，另外开一个数组，求每个点到它第 2i2^i2i 个父亲这条路径上最大的边权，然后在往上跳的时候顺便用一个变量统计一下就可以了，具体的看代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include&lt;bits/stdc++.h&gt;#define mp(a,b) make_pair(a,b)#define pll pair&lt;long long,long long&gt;using namespace std;struct Edge{ long long u; long long v; long long c; long long id;};bool cmp(Edge a,Edge b){ return a.c&lt;b.c;}bool cmp2(Edge a,Edge b)//这个是求完最小生成树后还原所有边的顺序的，虽然也可以再开一个数组，但是我懒。{ return a.id&lt;b.id;}Edge a[200001];vector&lt;pll&gt; edge[200001];long long n,m,cnt,k,log2n,f[200001],dep[200001],fa[200001][21],maxn[200001][21];long long find(long long x){ return f[x]==x? f[x]:f[x]=find(f[x]);}void dfs(long long u,long long father){ fa[u][0]=father; dep[u]=dep[father]+1; for(long long i=1;(1&lt;&lt;i)&lt;=dep[u];i++) { fa[u][i]=fa[fa[u][i-1]][i-1]; maxn[u][i]=max(maxn[u][i-1],maxn[fa[u][i-1]][i-1]);//求 u 到它第 2^i 个父亲这条路径上最大的边权。 } for(long long i=0;i&lt;edge[u].size();i++) { long long v=edge[u][i].first,c=edge[u][i].second; if(v!=father) { maxn[v][0]=c;//在搜索儿子前先把这个初始化一下。 dfs(v,u); } }}long long lca(long long u,long long v){ long long depu=dep[u],depv=dep[v],ans=0;//ans 用来统计最大边权。 if(depu!=depv) { if(depu&lt;depv) { swap(depu,depv); swap(u,v); } for(long long i=0;(1&lt;&lt;i)&lt;=depu-depv;i++) if((depu-depv)&amp;(1&lt;&lt;i)) { ans=max(ans,maxn[u][i]); u=fa[u][i]; } } if(u==v) return ans; for(long long i=log2n;i&gt;=0;i--) if(fa[u][i]!=fa[v][i]) { ans=max(ans,max(maxn[u][i],maxn[v][i])); u=fa[u][i]; v=fa[v][i]; } return max(ans,max(maxn[u][0],maxn[v][0]));}signed main(){ scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m); for(long long i=1;i&lt;=n;i++) f[i]=i; for(long long i=1;i&lt;=m;i++) { scanf(&quot;%lld%lld%lld&quot;,&amp;a[i].u,&amp;a[i].v,&amp;a[i].c); a[i].id=i; } sort(a+1,a+1+m,cmp); for(long long i=1;i&lt;=m;i++)//Kruskal 求最小生成树。 { long long t1=find(a[i].u),t2=find(a[i].v); if(t1!=t2) { f[t1]=t2; cnt++; k+=a[i].c; edge[a[i].u].push_back(mp(a[i].v,a[i].c)); edge[a[i].v].push_back(mp(a[i].u,a[i].c)); } if(cnt==n-1) break; } sort(a+1,a+1+m,cmp2); log2n=log(n)/log(2)+0.5; dfs(1,0); for(long long i=1;i&lt;=m;i++) printf(&quot;%lld\\n&quot;,k+a[i].c-lca(a[i].u,a[i].v));//加上当前这条的边权，删去路径上最大的边权。 return 0;} 一开始的时候我还想着要不要判断一下这条边是否是树边，但其实如果是树边的话，那么加上的也是它，删去的也是它，根本没有发生变化，所以没必要特判。 另外，这道题一定要开 long long，因为 109×2⋅10510^9\\times 2\\cdot10^5109×2⋅105 很明显炸 int 了。","link":"/posts/3582173013.html"},{"title":"【洛谷 P3958】 奶酪","text":"当我这样一个蒟蒻看到题解区里都是类似并查集、dfs、bfs这种高深的东西时，真的很难受（因为看不懂） 于是我整了一个小时，终于整出一个人畜无害老少皆宜即使是蒟蒻也能看懂的代码了 以上是废话 思路 简单来说，先按高矮（即z）从小到大排序，如果一个洞能和它前面任何一个洞相连或是直接与下表面相连，就存进一个数组，如果数组中有哪个能和上表面相连，就输出Yes，反之，输出No。 因为事先已经排过了序，所以可以保证数组中的数都是与下表面相连的，就像a1与下底面相连，a2与a1相连，所以a2也是和下底面相连的，所以不用管它和哪个相连，知道是连着的就对了 附上喜闻乐见的AC代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define ll long longusing namespace std;struct qwq//结构体定义数组{ ll x; ll y; ll z;};bool cmp(qwq a,qwq b)//自定义结构体sort排序{ if(a.z!=b.z) return a.z&lt;b.z;//一定记得以高矮优先 if(a.x!=b.x) return a.x&lt;b.x; if(a.y!=b.y) return a.y&lt;b.y;}ll dist(ll x1,ll y1,ll z1,ll x2,ll y2,ll z2){ return (x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)+(z1-z2)*(z1-z2);}ll t,n,h,r,s,flag;qwq tree[1010],g[1010];int main(){ scanf(&quot;%lld&quot;,&amp;t); for(int c=1;c&lt;=t;c++) { scanf(&quot;%lld%lld%lld&quot;,&amp;n,&amp;h,&amp;r); s=0; flag=0; memset(tree,0,sizeof(tree));//以上是初始化 for(int i=1;i&lt;=n;i++) scanf(&quot;%lld%lld%lld&quot;,&amp;g[i].x,&amp;g[i].y,&amp;g[i].z); sort(g+1,g+1+n,cmp);//排序 for(int i=1;i&lt;=n;i++) { flag=0; if(g[i].z-r&lt;=0)//如果与下底面相连就直接存入数组 { s++; tree[s].x=g[i].x; tree[s].y=g[i].y; tree[s].z=g[i].z; } for(int j=1;j&lt;=s;j++) if(dist(g[i].x,g[i].y,g[i].z,tree[j].x,tree[j].y,tree[j].z)&lt;=4*r*r)//判断是否相切或相交 { s++; tree[s].x=g[i].x; tree[s].y=g[i].y; tree[s].z=g[i].z; break;//只要有一个与其相连，就退出循环 } if(tree[s].z+r&gt;=h)//判断是否与上顶面相连 { flag=1; break; } } if(flag) printf(&quot;Yes\\n&quot;); else printf(&quot;No\\n&quot;); } return 0;} 如果哪里做的不对，请各位大佬帮忙指出，十分感谢","link":"/posts/3619596124.html"},{"title":"【洛谷 P6014】 斗牛","text":"看到这道题的时候，其实我第一反应是“天哪，这道题这么难，nnn这么大，不是dp就是记忆化吧”（蒟蒻之言，大佬勿喷QAQ） 然后再仔细读了一下题，发现几件事情： 不管nnn有多大，始终会有两张牌不被选。 因为被选上的n−2n-2n−2张牌是101010的倍数，因此个位为000，所以剩下222张牌的个位和这nnn个数之和的个位是一样的。 牌的值仅为111至101010。 于是，我突然想到，既然正着算这n−2n-2n−2个数不容易，那就反过来算剩下的两个数呗！ 所以，最后我的办法是，算出nnn个数的和，桶排每种数值的个数，暴力枚举出两个数，这两个数的和的个位等于所有数总和的个位。 有一个问题，有可能存在多个不同的n−2n-2n−2个数的组合，比如：2,8,1,9{2,8,1,9}2,8,1,9这组数，既可以选出2,8{2,8}2,8，又可以选出1,9{1,9}1,9，怎么办呢？ 其实仔细想一下，不管怎么选，其答案是唯一的，因为所有数的和是唯一的，其个位也是唯一的，所以点数也是唯一的。 还是证明一下吧（蒟蒻用不来数学公式，只能语言描述QAQ）： 令s1=n个数的总和，s2=符合要求的n-2个数的和，s3=剩下2个数的和 ∵s1≡b(mod10),s2≡0(mod10)\\because s1\\equiv b\\pmod{10},s2\\equiv0\\pmod{10}∵s1≡b(mod10),s2≡0(mod10) ∴s3≡s1−s2≡b−0≡b(mod10)\\therefore s3\\equiv s1-s2\\equiv b-0 \\equiv b\\pmod{10}∴s3≡s1−s2≡b−0≡b(mod10) 综上所述，要求的2个数之和的个位与n个数之和的个位相同，所以点数是唯一的 代码 1234567891011121314151617181920212223242526#include&lt;cstdio&gt;using namespace std;int n,sum,b[11];//这个题数据较小，sum用int也不会爆int main(){ scanf(&quot;%d&quot;,&amp;n); for(int i=1; i&lt;=n; i++) { int a; scanf(&quot;%d&quot;,&amp;a); sum+=a; b[a]++;//桶排计算各种牌值的个数 } for(int i=1; i&lt;=10; i++) for(int j=1; j&lt;=10; j++)//两重循环暴力求剩下的两个数 if(((i==j&amp;&amp;b[i]&gt;=2)||(i!=j&amp;&amp;b[i]&gt;=1&amp;&amp;b[j]&gt;=1))&amp;&amp;(i+j)%10==sum%10)//判断牌的个数够不够，以及这两张牌的和的个位是否与所有牌的和的个位相同 { if((i+j)%10==0)//记得特判！！！ printf(&quot;10&quot;); else printf(&quot;%d&quot;,(i+j)%10); return 0;//找到了就直接退出，因为点数是唯一的 } printf(&quot;0&quot;); return 0;} 其实这两重循环还可以再优化，但我觉得没有太大的必要了，毕竟这也只循环了100100100次而已。 蒟蒻求赞qwq","link":"/posts/1392144638.html"},{"title":"【洛谷 P6101】 出言不逊","text":"谔谔的题目传送门 题意： 每次操作使字符串中的一种字符数量增加一倍，问最少几次操作后字符串长度能大于等于LLL。 思路： 根据这个题意，我们可以看出，其实这个题就是一个贪心的思想，只要一开始选数量最多的那种字符，然后一直将其倍增就好了，为什么呢？因为既然是要求最少的操作次数，那么每次操作能增加的字符数量一定要尽量多，所以我们一开始就选最多的那种字符，就能使每次操作增加的字符数量最大化，这样最后的次数一定是最少的。同时这样倍增一次后，该字符数量还是最多的，那么我们下一次操作就还是选这种字符。 举个例子，在 AKIOI\\texttt{AKIOI}AKIOI 这个字符串中，字符 I\\texttt{I}I 的个数显然是最多的，那么我们一直将其数量倍增，最后能达到的总长度一定比选其他字符要长。 同时我们也可以看出，这道题不可能暴力模拟，因为根据L≤264L\\le2^{64}L≤264这个数据就能看出，谁想暴力，谁就爆零。 那么我们该怎么办呢？推规律呗！ 设s=∣S∣−xs=|S|-xs=∣S∣−x（也就是除开我们要倍增的那种字符以外的字符个数），LiL_iLi​为第iii次操作后的字符串长度。 L1=s+2⋅x=s+21⋅xL_1=s+2\\cdot x=s+2^1\\cdot x L1​=s+2⋅x=s+21⋅x L2=s+2⋅2⋅x=s+22⋅xL_2=s+2\\cdot 2\\cdot x=s+2^2\\cdot x L2​=s+2⋅2⋅x=s+22⋅x L3=s+2⋅2⋅2⋅x=s+23⋅xL_3=s+2\\cdot 2\\cdot 2\\cdot x=s+2^3\\cdot x L3​=s+2⋅2⋅2⋅x=s+23⋅x ⋯\\cdots ⋯ Ln=s+2n⋅xL_n=s+2^n\\cdot x Ln​=s+2n⋅x 由此，这个式子就推出来了，有人可能会说，你这个计算的是nnn次操作后的字符串长度啊，不符合题意啊！这好办，既然要求字符串长度大于等于LLL，也就是LnL_nLn​要大于等于LLL，那我们列个不等式就行了。 s+2n⋅x≥Ls+2^n\\cdot x\\ge L s+2n⋅x≥L 2n≥L−sx2^n\\ge\\dfrac{L-s}{x} 2n≥xL−s​ n≥log⁡(L−sx)n\\ge \\log\\left(\\dfrac{L-s}{x}\\right) n≥log(xL−s​) 完事。 关于计算字符个数，其实也很简单，题目明确说了，一共只有626262种字符，那么我们开个数组，桶排就好了，比如说大写字母个数就存在b1b_{1}b1​到b26b_{26}b26​，小写字母个数就存在b27b_{27}b27​到b52b_{52}b52​，而数字个数就存在b53b_{53}b53​到b62b_{62}b62​。 对了，还有一点重要提醒：开 long long 还是会炸，要开 long double 或 unsigned long long！！！，本题还特别提醒，要注意数据范围，结果我因为没开 long double 调了半小时……。long long 的范围是到263−12^{63}-1263−1，但本题的LLL是到264−12^{64}-1264−1，所以用了 long long 还是不行。 代码： 1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;using namespace std;string s;long long maxn,ans,b[63];long double l;//再次提醒，一定要开 long double 或 unsigned long long。long long my_log(long double x)//我个人不太信得过 cmath 里的函数，所以能自己写的我还是自己写好了。{ long long s=0; while(x&gt;1)//当x为1时，表示长度已经等于L了，所以不能再累加了。 { s++; x/=2; } return s;}int main(){ cin&gt;&gt;s&gt;&gt;l; for(int i=0;i&lt;s.length();i++) { if(s[i]&gt;='A'&amp;&amp;s[i]&lt;='Z')//分段存，判断当前字符属于哪一类，然后对应的下标+1 b[s[i]-'A'+1]++; if(s[i]&gt;='a'&amp;&amp;s[i]&lt;='z') b[s[i]-'a'+27]++; if(s[i]&gt;='0'&amp;&amp;s[i]&lt;='9') b[s[i]-'0'+53]++; } for(int i=1;i&lt;=62;i++)//找出最数量最多的字符 maxn=max(maxn,b[i]); cout&lt;&lt;my_log((l-s.length()+maxn)*1.0/maxn);//这里的1.0主要起转化类型的作用 return 0;//谔谔完毕} 就这样，如果还有不懂的，可以在评论里问，如果有什么不对的地方，还请大佬指出，谢谢！","link":"/posts/570467942.html"},{"title":"【洛谷 P6195】 迫害","text":"题目传送门 这道题，乍一看很难，但其实就是一道推结论的数学题。 相信大家在小学的时候都做过这样一道数学题吧：大意就是如何用最少的正整数凑出最多的连续的正整数（随便口胡了一下，差不多就行了），其思路大致如下： 先取111，因为这是最小的正整数。 再取222，因为一个111凑不出222。 再取444，因为1+2=31+2=31+2=3，无法凑出444。 再取888，因为1+4=5,2+4=6,1+2+4=71+4=5,2+4=6,1+2+4=71+4=5,2+4=6,1+2+4=7，凑不出888。 ⋯\\cdots⋯ 由此，我们可以看出一个规律，当每次取前面取过的所有数的和再加一时，可以凑出最多的正整数，即： mi=∑j=1i−1mj+1m_i=\\sum\\limits_{j=1}^{i-1}m_j+1 mi​=j=1∑i−1​mj​+1 铺垫完毕。 过程 接下来我们进入这道题的分析。 根据上述规律，我们可以看出，这道题其实也有着异曲同工之妙，由于有mmm个数可以取任意值，我们就按照以上策略来取（由于nnn代表的是有nnn个111，所以可以当成是补漏的），设xix_ixi​表示第iii次取的值，则有： x1=n+1x_1=n+1 x1​=n+1 x2=x1+n+1=2⋅n+2=2⋅(n+1)x_2=x_1+n+1=2\\cdot n+2=2\\cdot(n+1) x2​=x1​+n+1=2⋅n+2=2⋅(n+1) x3=x1+x2+n+1=4⋅n+4=4⋅(n+1)x_3=x_1+x_2+n+1=4\\cdot n+4=4\\cdot(n+1) x3​=x1​+x2​+n+1=4⋅n+4=4⋅(n+1) x4=x1+x2+x3+n+1=8⋅n+8=8⋅(n+1)x_4=x_1+x_2+x_3+n+1=8\\cdot n+8=8\\cdot(n+1) x4​=x1​+x2​+x3​+n+1=8⋅n+8=8⋅(n+1) ⋯\\cdots ⋯ xm=2m−1⋅(n+1)x_m=2^{m-1}\\cdot(n+1) xm​=2m−1⋅(n+1) 此时，我们能表示出来的从111开始的连续的正整数就有这么多： ∑i=1mxi+n\\sum\\limits_{i=1}^m x_i+n i=1∑m​xi​+n 即： (1+2+4+8+⋯+2m−1)⋅(n+1)+n(1+2+4+8+\\cdots+2^{m-1})\\cdot(n+1)+n (1+2+4+8+⋯+2m−1)⋅(n+1)+n 怎么样，前面那个式子是不是似曾相识？没错，这是我们小学所学的等比数列！只要把最后的nnn变成n+1−1n+1-1n+1−1，并把n+1n+1n+1合并到前面的那一坨东西里面，就可以弄出这个式子： 2m⋅(n+1)−12^m\\cdot(n+1)-1 2m⋅(n+1)−1 具体过程我不详细解释了，比较简单，手推一下就行了。既然都弄出了这个式子，那我们就可以偷税地去算了。 对了，由于m≤109m\\le 10^9m≤109，直接暴力算乘方明显会超时，所以我们需要用快速幂（不会的同学建议去做一下这道题）。 参考代码 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;#define ll long long#define p 1000000007using namespace std;ll n,m,t;inline ll input()//读入优化{ ll x=0,f=1; char c=getchar(); while(c&lt;'0'||c&gt;'9') { if(c=='-') f=-1; c=getchar(); } while(c&gt;='0'&amp;&amp;c&lt;='9') { x=x*10+c-'0'; c=getchar(); } return x*f;}inline ll ksm(ll b,ll k)//快速幂{ ll ans=1; while(k) { if(k&amp;1)//快速幂里面的位运算，相当于k%2==1 ans=ans*b%p; b=b*b%p; k&gt;&gt;=1;//同上，相当于k/=2 } return ans%p;}int main(){ n=input();//读入优化不解释 m=input(); printf(&quot;%lld&quot;,ksm(2,m)*(n+1)%p-1);//记得取模啊！！！ return 0;} 后记 这道题其实不算很难吧，主要就是推式子那里麻烦了一点，然后要用到快速幂，其他的也并不是很麻烦，不想用读入优化也是可以的，只是因为比赛的时候想优化一下（其实我还加了八聚氧只不过太长了所以就删掉了）。","link":"/posts/3896288680.html"},{"title":"【笔记】图论-拓扑排序","text":"拓扑排序，是一种听上去很高级的算法，但其实它是很简单的（就基础算法而言）。 本文主要介绍一下拓扑排序最基本的概念和实现过程。（也就是说是一篇入门文章，大佬们可以不用看了） 什么是拓扑排序？ 在生活中和数学题中，我们常常会遇到需要完成很多件事的情况比如写很多作业，这些事件之间各有先后顺序，即你必须先完成这件事，才能完成另外的事，我们可以根据这些事来画张图（只是个例子）： 在这张图中，每条有向边代表要想完成v，就必须完成u，比如要想打开洛谷，就必须先打开电脑废话。 能不能给这些事排个序，让我按照这个顺序来做事不会冲突呢（比如不会出现先水犇犇再打开洛谷的情况）？ 当然可以，我们可以看出，按照ABCDEFGH这个顺序做事就不会冲突。 说了这么多，究竟什么是拓扑排序呢？相信你也看出来了，拓扑排序就是对一张图进行排序，使得每一条路径的起点永远出现在终点的前面，也就是安排一个顺序，使得做事不会冲突。最后的这个顺序，就被称为是拓扑序列，而得出这个序列的过程被称为拓扑排序。 当然，一张图的拓扑序列可能不止一种，比如在上图中BACEDGFH也是一个拓扑序列。 对于要进行排序的图，它必须是一个DAG（有向无环图），即不会出现要做A，先做B，但要做B，又要先做A的情况。 算法思路 拓扑排序其实很简单，对于一个点，如果它没有父亲（即与其相连的入边的起点）或是其父亲都被排在序列里了，那么这个点就可以放进序列，因为它既然没有先决条件，就是可以做的。 概括一下，不断地去做那些没有先决条件或是先决条件被满足的事情，最后所有事情都会做完这句话不适用于我的作业（满足是DAG的情况下）。 那么怎么判断一个点有无先决条件呢？很简单，我们在建图时就统计好每个点的入度，入度为000就说明没有先决条件，就是可以做的，在排序时，每做完一件事，就删掉这个点，同时其出边相连的点入度减111，如果一个点的先决条件都被满足了，那么它的入度也就为000了。 **注意：**不是真的要在图里把这个结点删去，而是只用将其相邻的点入度减111就行了，这样就和删去这个点效果是一样的了。 拓扑排序主要有两种实现方法，可以分别类比为BFS和DFS（因为真的很像啊！），我个人比较喜欢用BFS，因为要开的数组较少。 BFS 这种方法的思路是：每找到一个入度为000的点,就将其入队，然后拓展与其相连的点，将这些点入度减111，因为当前这个点入度为000，所以我们要完成它，完成了它之后，与它相连的点都少了一个先决条件，所以入度减111（这TM跟BFS有什么区别？）。 这里我们就不用开一个visitvisitvisit数组来记录到没到达过了，因为既然一个点入度都为000了，怎么可能还有路径到达它呢？所以不需要。 由于太简单，我就不手动模拟了，就是和BFS一模一样的。 PS：由于没有拓扑排序的模板题，所以我就自己出了一道。 输入格式： 第111行两个整数nnn和mmm，表示在这张图中共有nnn个点，mmm条边。 第222行到第m+1m+1m+1行，每行两个数uuu和vvv，表示从uuu到vvv有一条边。 输入保证没有环。 输出格式： 输出共一行，为这个图的拓扑序列，每两个数字之间一个空格。 输入数据： 1234567891011128 111 32 31 52 53 44 64 75 65 76 87 8 输出数据： 答案不唯一！ 11 2 3 4 5 6 7 8 不用看了就是上面那张图 参考代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;using namespace std;struct Edge{ int next; int to;};Edge edge[100001];//静态链式前向星存图int n,m,cnt,tot,head[10001],in[10001],ans[10001];//in记录每个点的入度，ans存答案queue&lt;int&gt; q;//我比较喜欢用STL，如果不会的可以百度一下，很简单的，几分钟就会了void add_edge(int u,int v){ cnt++; edge[cnt].next=head[u]; edge[cnt].to=v; head[u]=cnt;}void topo(){ for(int i=1;i&lt;=n;i++) if(!in[i]) q.push(i);//一开始检测哪些点入度为0，从这些点开始干♂。 while(!q.empty())//如果队列不为空 { int u=q.front();//取出队头元素 q.pop();//队头元素出队 ans[++tot]=u;//因为这个点被放进队列，有且只有一种情况，即它的入度为0，这种情况下我们当然是可以来做这件事的 for(int i=head[u];i;i=edge[i].next)//枚举与这个点相连的所有点。 { int v=edge[i].to; in[v]--;//这些点的入度减1 if(!in[v])//如果这个点入度为0了，就可以入队了，没有必要枚举完了再判断哪些点入度为0 q.push(v); } }}int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) { int a,b; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); add_edge(a,b); in[b]++; } topo(); for(int i=1;i&lt;=tot;i++) printf(&quot;%d &quot;,ans[i]); return 0;} 是不是很简单啊？只要会BFS就应该能看懂了。 DFS 这种方法相对来说就要麻烦一些，因为要开一个visitvisitvisit数组，但其实也没麻烦到哪去。 思路：从一个入度为000的点开始遍历，先一直走到底，在回溯的时候，将当前点压入栈中，也就是说，最后的出度为000的点将会最先被压入栈中，也就会最后被输出。同时，我们不再走之前走过的点了，因为这些点已经被压入栈中。 注意！ 要遍历所有点，找到入度为000的点，从这一点开始进行遍历，因为入度为000的点不可能从其他点到达，所以要从每一个初始入度为000的点都遍历一次。 参考代码：（题目如上） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;using namespace std;struct Edge{ int next; int to;};Edge edge[100001];int n,m,cnt,tot,head[10001],in[10001],ans[10001],visit[10001];stack&lt;int&gt; s;//还是STL模板void add_edge(int u,int v){ cnt++; edge[cnt].next=head[u]; edge[cnt].to=v; head[u]=cnt;}void topo(int u){ visit[u]=1;//标记当前点 for(int i=head[u];i;i=edge[i].next)//枚举所有出边 { int v=edge[i].to; if(!visit[v]) topo(v);//继续遍历 } s.push(u);//将这一点压入栈}int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) { int a,b; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); add_edge(a,b); in[b]++; } for(int i=1;i&lt;=n;i++)//一定要从每一个入度为0的点都遍历一次 if(!in[i]) topo(i); while(!s.empty()) { printf(&quot;%d &quot;,s.top()); s.pop(); } return 0;} 很简单是不是啊？ 拓扑排序由于保证了每个点、每条边只会被遍历一次，所以其时间复杂度为O(n+m)O(n+m)O(n+m)，还是很不错了。 在最开始，我们曾提到拓扑排序只能处理没有环的图，但其实，它还可以用来判断是否存在环。 思路很简单，如果一张图中存在环，那么我们是不可能将所有的点都放进答案数组里的，组成环的那些点因为入度怎么都不可能为000（试想一下让你在穿裤子之前必须穿上衣，但在穿上衣之前又必须穿裤子，那么最后你一定什么也穿不了），所以它们不会被放进数组。 简单来说，在BFS完之后，加一条语句判断tottottot是否小于nnn，如果是，那么一定存在环。 就像这样： 12if(tot&lt;n) printf(&quot;有环啊啊啊啊！！！&quot;); 这只是用BFS的思路，DFS的你们可以自己想一下，我就不再说了。 总结 emmm……没有什么好总结的了，都很简单，关键是做题（基础算法和题目可是两回事，蒟蒻亲身体验QAQ） 推荐几道题目吧： 全都是你谷上的哦（没办法窝太菜了只有你谷账号没有CF和AT之类的账号QAQ） P4017 最大食物链计数（拓扑排序+动归，极其简单，看题就切） P1137 旅行计划（简单明了，DFS一遍就过） P1038 神经网络（版子题，简单） P1983 车站分级 （有难度，但主要是在如何建图上，建好了跑一遍拓扑就好了） P1347 排序（也差不多是版子题，迄今为止做过最简单的一道蓝题） 由于我是个菜鸡，所以这些题保证你只要学懂了拓扑排序都是可以做的，只是有些要稍微思考一下。 如果有哪里不对请大佬在评论里指出，蒟蒻感谢之极qwq。","link":"/posts/2563015957.html"},{"title":"【洛谷 P3385】 【模板】负环","text":"本题其实就是最短路的延伸版本，如果不了解最短路的可以看我这篇文章：【笔记】图论-最短路径算法。 如果了解最短路的一定知道， Bellman-Ford 算法是可以判断负环的，方法也很简单，就是在两重循环结束后再遍历每一条边（下文通称称这条边的起点为点uuu，终点为点vvv），如果从点uuu到点vvv比disvdis_vdisv​还要短，那么就存在负环。 为什么呢？我们来看下面这张图： 假设从点1出发，手动模拟一下 Bellman-ford 的两重循环可以算出：dis1=−2,dis2=−1,dis3=1dis_1=-2,dis_2=-1,dis_3=1dis1​=−2,dis2​=−1,dis3​=1，但此时，很明显可以看出，从点333到点111为−3-3−3，比dis1dis_1dis1​还要小，所以此时是存在负环的。 因为如果存在负环，那么每在环中转一圈，就会减小一定的值，这样就不存在最短路了，不论你转多少圈，再转一圈始终会比当前的最短距离短，如果不存在负环，那么最短路就是确定的，也就是说经过n×mn\\times mn×m次循环一定能求出最短的路径。 根据以上思路，我打出了一段代码： 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;using namespace std;int t,n,m,k,u[6001],v[6001],c[6001],dis[2001];//因为有可能全都是双向边，所以数组要开成m的两倍int main(){ scanf(&quot;%d&quot;,&amp;t); while(t--) { memset(dis,0x3f3f3f,sizeof(dis)); k=0; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) { k++; scanf(&quot;%d%d%d&quot;,&amp;u[k],&amp;v[k],&amp;c[k]);//Bellman-Ford这样存边更方便 if(c[k]&gt;=0) { k++; u[k]=v[k-1]; v[k]=u[k-1]; c[k]=c[k-1]; } } dis[1]=0; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=k;j++)//Bellman-Ford朴素算法 dis[v[j]]=min(dis[v[j]],dis[u[j]]+c[j]); for(int i=1;i&lt;=k;i++) if(dis[v[i]]&gt;dis[u[i]]+c[i])//判断负环 { printf(&quot;YE5\\n&quot;);//毒瘤出题人解释一下为什么是YE5！！！ goto l;//懒得写flag，直接跳出循环到l:处 } printf(&quot;N0\\n&quot;); l:; } return 0;} 如果你看到上面这段代码就很高兴地回去改了，那么很遗憾地告诉你，这是90pts的代码。 为什么呢？我们看题目： 寻找一个从顶点111所能到达的负环。 上面那段代码判断的是有没有负环，但题目要求是求从点111能到的负环，所以会错。 什么意思呢？意思是从点111开始，要能到这个负环才行，如果点111与这个负环不连通，那么就还是输出N0。 怎么改呢？很简单，用一个bbb数组表示每个点能否从点111到达，就像 Dijkstra 一样，枚举每条边时，我们判断一下这条边的出发点是否能从点111到达就行了，如果出发点目前不能从点111到达，就不管这条边，如果可以，就把这条边的终点也标记为可以从点111到达。同时，最后在判断负环时，也要判断当前边的出发点是否能从点111到达。这样不能从点111到达的负环就不会被判断到了。 那么，这么做会不会影响disdisdis数组的更新呢？当然不会，我们本来就是为了避免误将没有更新过的点当成已更新过的，才会把disdisdis数组设成无穷大的，现在只是另开了一个数组来代替这个功能而已。 还是比较简单吧，加了几行代码而已： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;using namespace std;int t,n,m,k,u[6001],v[6001],c[6001],dis[2001],b[2001];int main(){ scanf(&quot;%d&quot;,&amp;t); while(t--) { memset(b,0,sizeof(b)); k=0; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) { k++; scanf(&quot;%d%d%d&quot;,&amp;u[k],&amp;v[k],&amp;c[k]); if(c[k]&gt;=0) { k++; u[k]=v[k-1]; v[k]=u[k-1]; c[k]=c[k-1]; } } dis[1]=0; b[1]=1; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=k;j++) if(b[u[j]]) { dis[v[j]]=min(dis[v[j]],dis[u[j]]+c[j]); b[v[j]]=1; } for(int i=1;i&lt;=k;i++) if((b[u[i]]||b[v[i]])&amp;&amp;dis[v[i]]&gt;dis[u[i]]+c[i]) { printf(&quot;YE5\\n&quot;); goto l; } printf(&quot;N0\\n&quot;); l:; } return 0;} 好了，没有套路了，这就是 AC 的代码。 评测记录： Bellman-Ford 真香。","link":"/posts/1479545610.html"},{"title":"【笔记】图论-最短路径算法","text":"在图论中，有一类算法，是专门拿来算两点之间最短距离的，被称之为最短路算法。 一共有四种最短路算法，分别是：Floyd，Dijkstra，Bellman-Ford和SPFA，它们时间复杂度各不相同，同时也具有各自的缺陷，今天就来介绍一下这四种算法。 参考题目：P1744 采购特价商品（四种算法参考代码均为这道题） PS：因为图论刚起步，所以为了熟悉一下，代码都是用的链式前向星存图，其实这四种都有自己的方式，下面会讲到。 Floyed Floyd和其它三种不一样，是一种全源最短路径算法，也就是说，它能求出任意点为起点，任意点为终点的最短距离，而其它三种只能求出以某一点为起点，任意点为终点的最短距离，即单源最短路径。 Floyd算法时间复杂度为O(n3)O(n^{3})O(n3)，核心代码如下： 1234for(int k=1;k&lt;=n;k++) for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]); 其中，k为中间点，i和j为起点和终点。 关于为什么要把k放在最外层，我也是纠结了很久（那肯定啊强迫症看了会很不舒服的嘛），直到看到了这张图片。 这东西把这个算法解释的很清楚了，我就不再说了。 代码： 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#define min(a,b) a&lt;b?a:busing namespace std;struct Point{ int x; int y;};Point a[101];int n,m,s,t,cnt,h[101],b[101];double dis[101][101];int main(){ scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) { scanf(&quot;%d%d&quot;,&amp;a[i].x,&amp;a[i].y); for(int j=1;j&lt;=n;j++) dis[i][j]=10000000;//初始化dis数组为无穷大，这样才能避免算的时候加入不存在的边 //因为是取最小值，所以这么大的数不会被考虑 } scanf(&quot;%d&quot;,&amp;m); for(int i=1;i&lt;=m;i++) { int u,v; scanf(&quot;%d%d&quot;,&amp;u,&amp;v); dis[u][v]=dis[v][u]=sqrt((a[u].x-a[v].x)*(a[u].x-a[v].x)+(a[u].y-a[v].y)*(a[u].y-a[v].y)); } scanf(&quot;%d%d&quot;,&amp;s,&amp;t); for(int k=1;k&lt;=n;k++)//切记：中间点一定要放在最外层，原因上面已经讲过了 for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) dis[i][j]=min(dis[i][j],dis[i][k]+dis[j][k]);//这里如果没有边，则默认为无穷大 //由于是无穷大，所以这里不可能取到不存在的边 printf(&quot;%.2lf&quot;,dis[s][t]); return 0;} 事实上Floyd算法并不用链式前向星，而是邻接矩阵，毕竟它是求任意点为起点和终点的最短路径，所以必须用邻接矩阵。 优点：简单易懂，全源最短路 缺点：很明显啊……时间复杂度太感人了，空间复杂度也很棒棒啊 Dijkstra 正如上面所说，Dijkstra是一种单源最短路径算法，时间复杂度为O(n2)O(n^{2})O(n2)，比较稳定。 Dijkstra的核心思想是不停地找距离起点最近又没有更新过的点，然后对其所有相连的点进行更新。 因为从一个点到另一个点，中间必定经过至少一个中转点（把起点也算上），Dijkstra就是不停地把距离起点最近的点作为中转点，来更新与之相连的点。 Dijkstra默认不可能出现起点到A比起点到B距离长，但从起点经过A再到B距离却比直接到B短的情况，所以无法处理存在负边权的情况。 下面用图片来具体说明一下（标粗的点表示没有更新过）： 第一步： 此时，初始化dis[1]=0dis[1]=0dis[1]=0，dis[2,3,4,5]=∞dis[2,3,4,5]=\\inftydis[2,3,4,5]=∞，全部标记为未更新。 第二步： 此时，因为dis[1]=0dis[1]=0dis[1]=0，距离起点最近，因此更新点1，标记一下。然后，修改与点1相连的所有点，于是，dis[2]=2,dis[3]=4,dis[4]=7dis[2]=2,dis[3]=4,dis[4]=7dis[2]=2,dis[3]=4,dis[4]=7，但这时并不标记这些点，因为它们不一定是最短路径。 数据：dis[1]=0,dis[2]=2,dis[3]=4,dis[4]=7,dis[5]=∞dis[1]=0,dis[2]=2,dis[3]=4,dis[4]=7,dis[5]=\\inftydis[1]=0,dis[2]=2,dis[3]=4,dis[4]=7,dis[5]=∞ 第三步： 第二轮循环后，找到点2距离起点最近且目前未被更新过，更新点2，并循环与点2相连的所有点，即点1，点3，点5，同样，这轮修改不标记，原因如上所述。因为dis[1]=0&lt;dis[2]+2dis[1]=0&lt;dis[2]+2dis[1]=0&lt;dis[2]+2，所以不修改点1。 数据：dis[1]=0,dis[2]=2,dis[3]=3,dis[4]=7,dis[5]=4dis[1]=0,dis[2]=2,dis[3]=3,dis[4]=7,dis[5]=4dis[1]=0,dis[2]=2,dis[3]=3,dis[4]=7,dis[5]=4 第四步： 第三轮循环，找到未被更新过的点中点3距起点最近，因此标记点3，并修改与点3相连的点，即点1，点2，点4，点5，但因为dis[1]=0&lt;dis[3]+4,dis[2]=2&lt;dis[3]+1,dis[5]=4&lt;dis[3]+6dis[1]=0&lt;dis[3]+4,dis[2]=2&lt;dis[3]+1,dis[5]=4&lt;dis[3]+6dis[1]=0&lt;dis[3]+4,dis[2]=2&lt;dis[3]+1,dis[5]=4&lt;dis[3]+6，因此这三个点不管，只有点4被修改（同样不标记） 数据：dis[1]=0,dis[2]=2,dis[3]=3,dis[4]=4,dis[5]=4dis[1]=0,dis[2]=2,dis[3]=3,dis[4]=4,dis[5]=4dis[1]=0,dis[2]=2,dis[3]=3,dis[4]=4,dis[5]=4 最后两轮更新将点4和点5更新，手动模拟一下发现没有点再修改了，循环结束。 综上所述，Dijkstra算法简单来说就是，找距起点最近的点，用它来修改相连的点 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#define min(a,b) a&lt;b?a:busing namespace std;struct Point{ int x; int y;};struct Edge{ int next; int to; double w;};Point a[101];Edge edge[2001];int n,m,s,t,cnt,h[101],b[101];double dis[101];void add_edge(int u,int v){ edge[cnt].next=h[u]; edge[cnt].to=v; edge[cnt].w=sqrt((a[u].x-a[v].x)*(a[u].x-a[v].x)+(a[u].y-a[v].y)*(a[u].y-a[v].y)); h[u]=cnt; cnt++;}int main(){ memset(h,-1,sizeof(h)); scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) { scanf(&quot;%d%d&quot;,&amp;a[i].x,&amp;a[i].y); dis[i]=100000000;//初始化dis数组无穷大 } scanf(&quot;%d&quot;,&amp;m); for(int i=1;i&lt;=m;i++) { int u,v; scanf(&quot;%d%d&quot;,&amp;u,&amp;v); add_edge(u,v); add_edge(v,u); } scanf(&quot;%d%d&quot;,&amp;s,&amp;t); dis[s]=0;//这里只初始化距离，不标记起点，否则就无法用起点去修改与之相邻的点了 for(int i=1;i&lt;=n;i++) { double minn=100000000; int mj=0; for(int j=1;j&lt;=n;j++)//找距离起点最近的未更新的点 if(b[j]==0&amp;&amp;dis[j]&lt;minn) { minn=dis[j]; mj=j; } if(mj==0)//如果没有找到，就说明要么是所有点都更新完成了，要么是没有点和起点相连 break; b[mj]=1;//更新最近的点 for(int j=h[mj];j!=-1;j=edge[j].next)//用这个点去修改相邻的点 dis[edge[j].to]=min(dis[edge[j].to],dis[mj]+edge[j].w);//要判断一下通过这个点到达是否为最短路径 } printf(&quot;%.2lf&quot;,dis[t]); return 0;} Dijkstra算法可以用链式前向星，也可以用邻接矩阵，但个人认为链式前向星会更快一些，因为可以省去判断是否与当前点相连。 应当注意的是，Dijkstra不能处理存在负边权的情况，如下图： 如图，从A到C最短应该是A—&gt;B—&gt;C，长度为-7，但Dijkstra在第一轮循环的时候，就会先更新点C为1，再用点C去修改点B，然后更新点B为-9，所以无法求出最短路径。 优点：时间复杂度稳定，不容易被卡 缺点：无法处理存在负边权的情况 Bellman-Ford Bellman-Ford也是一种单源最短路径，其时间复杂度为O(nm)O(nm)O(nm)，较Dijkstra来说没有那么稳定，容易被卡。 与Dijkstra不同，Bellman-Ford的核心思想是，在一个图中，总有边是连接着修改过的点和未修改过的点的，通过枚举这些边，来不断修改未修改过的点的值。 具体我也不好直接说明，还是用图来手动模拟一下清晰。 PS：加粗的表示值未被修改过。 第一步： 老规矩，初始化所有点的值为无穷大，但点1不用，默认为0。 数据：dis[1]=0,dis[2,3,4,5]=∞dis[1]=0,dis[2,3,4,5]=\\inftydis[1]=0,dis[2,3,4,5]=∞ 第二步： 枚举所有的边，发现dis[1]+2&lt;dis[2],dis[1]+4&lt;dis[3],dis[1]+7&lt;dis[4]dis[1]+2&lt;dis[2],dis[1]+4&lt;dis[3],dis[1]+7&lt;dis[4]dis[1]+2&lt;dis[2],dis[1]+4&lt;dis[3],dis[1]+7&lt;dis[4]，因此修改这些点的值dis[2]=dis[1]+2=2,dis[3]=dis[1]+4=4,dis[4]=dis[1]+7=7dis[2]=dis[1]+2=2,dis[3]=dis[1]+4=4,dis[4]=dis[1]+7=7dis[2]=dis[1]+2=2,dis[3]=dis[1]+4=4,dis[4]=dis[1]+7=7，但在接下来的循环中，又发现dis[2]+1&lt;dis[3]dis[2]+1&lt;dis[3]dis[2]+1&lt;dis[3]，修改dis[3]=dis[2]+1=3dis[3]=dis[2]+1=3dis[3]=dis[2]+1=3，dis[3]+1&lt;dis[4]dis[3]+1&lt;dis[4]dis[3]+1&lt;dis[4]，于是修改dis[4]=dis[3]+1=4dis[4]=dis[3]+1=4dis[4]=dis[3]+1=4。 数据：dis[1]=0,dis[2]=2,dis[3]=3,dis[4]=4,dis[5]=∞dis[1]=0,dis[2]=2,dis[3]=3,dis[4]=4,dis[5]=\\inftydis[1]=0,dis[2]=2,dis[3]=3,dis[4]=4,dis[5]=∞ 第三步： 再次枚举所有的边，发现dis[2]+2&lt;dis[5]dis[2]+2&lt;dis[5]dis[2]+2&lt;dis[5]，于是修改dis[5]=dis[2]+2=4dis[5]=dis[2]+2=4dis[5]=dis[2]+2=4，而后又发现dis[3]+6&gt;dis[5]dis[3]+6&gt;dis[5]dis[3]+6&gt;dis[5]，于是dis[5]dis[5]dis[5]修改完毕，至此，所有的点都修改完了。 关于为什么Bellman-Ford要循环nnn次，其实很简单，虽然上面这个图只用了3次就完成了，但不能排除有链的情况，比如这样： 这时，每次循环所有边就只能改变一个点的值，所以至少要循环5次。 参考代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#define min(a,b) a&lt;b?a:busing namespace std;struct Point{ int x; int y;};struct Edge{ int next; int to; double w;};Point a[101];Edge edge[2001];int n,m,s,t,cnt,h[101];double dis[101];void add_edge(int u,int v){ edge[cnt].next=h[u]; edge[cnt].to=v; edge[cnt].w=sqrt((a[u].x-a[v].x)*(a[u].x-a[v].x)+(a[u].y-a[v].y)*(a[u].y-a[v].y)); h[u]=cnt; cnt++;}int main(){ memset(h,-1,sizeof(h)); scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) { scanf(&quot;%d%d&quot;,&amp;a[i].x,&amp;a[i].y); dis[i]=100000000; } scanf(&quot;%d&quot;,&amp;m); for(int i=1;i&lt;=m;i++) { int u,v; scanf(&quot;%d%d&quot;,&amp;u,&amp;v); add_edge(u,v); add_edge(v,u); } scanf(&quot;%d%d&quot;,&amp;s,&amp;t); dis[s]=0; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++)//链式前向星遍历所有边 //其实也可以用一个f[2*m][2]的数组来存每条边的起点与终点，会更方便 //之所以是2*m，是因为这是无向图，每条边要存两次 for(int k=h[j];k!=-1;k=edge[k].next) dis[edge[k].to]=min(dis[j]+edge[k].w,dis[edge[k].to]);//判断通过当前这条边到达这个点会不会更短 printf(&quot;%.2lf&quot;,dis[t]); return 0;} Bellman-Ford可以不用链式前向星，而直接单纯地存边的起讫点，在时间上区别个人认为不大，但空间的话还是后者要优秀一点。 Bellman-Ford无法处理存在负权回路的情况，即这条回路上所有边的权值加起来为负数的回路（废话这样一直转下去每次减一点值就无穷小了呀），就像这样： 尽管Bellman-Ford无法处理负权回路的情况，但可以判断是否存在负权回路，如果全部循环完了，还存在某条边使得从点A到点B的距离更小，就存在负权回路。 直接在两重循环完了后面加上这样几行代码即可： 1234for(int i=1;i&lt;=n;i++) for(int j=head[i];j!=-1;j=edge[j].next)//链式前向星遍历 if(dis[edge[j].to]&gt;dis[i]+edge[j].w) printf(&quot;啊啊啊有负权回路啊！！！&quot;); 优点：可以处理负边权的情况，可以检测负权回路 缺点：容易被卡！！！ SPFA SPFA是Bellman-Ford的队列优化版本，时间复杂度和Bellman-Ford一样，是O(nm)O(nm)O(nm)（不要信《信息学奥赛一本通》上的鬼话，它说时间复杂度是O(km)，其中k是常数，约为2，根本不对，详见百度） SPFA的思路非常简单，每次从队头取一个点出来，判断从这个点到相邻的点是否更短，如果是，则将这个相邻的点入队，其实就和BFS很像，但不同的是，SPFA中的点可以多次入队，因为第一次找到的最短路径不一定就是真正的最短路径。同时，也正因为可以多次入队，所以它无法像普通的BFS一样估算队列的长度，所以在实现时，要么采用循环队列（即把队列当成一个圆环，当队尾到达一定位置时，就把尾指针移到队头，相当于从头再开始存，一般是用一个取模来完成，这样比较方便），这时队列只需开到2∗n+52*n+52∗n+5即可（《信息学奥赛一本通》原话，具体证明我也不会，如果哪位大佬知道的话麻烦在评论里指出，蟹蟹！），要么还可以用STL库中的queue容器，这里我用的是queue，但也要学会手打队列，不能养成STL依赖症。 参考代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#define min(a,b) a&lt;b?a:busing namespace std;struct Point{ int x; int y;};struct Edge{ int next; int to; double w;};Point a[101];Edge edge[2001];int n,m,s,t,cnt,head[101];double dis[101];queue&lt;int&gt; q;void add_edge(int u,int v){ edge[cnt].next=head[u]; edge[cnt].to=v; edge[cnt].w=sqrt((a[u].x-a[v].x)*(a[u].x-a[v].x)+(a[u].y-a[v].y)*(a[u].y-a[v].y)); head[u]=cnt; cnt++;}int main(){ scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) { scanf(&quot;%d%d&quot;,&amp;a[i].x,&amp;a[i].y); dis[i]=10000000; head[i]=-1; } scanf(&quot;%d&quot;,&amp;m); for(int i=1;i&lt;=m;i++) { int u,v; scanf(&quot;%d%d&quot;,&amp;u,&amp;v); add_edge(u,v); add_edge(v,u); } scanf(&quot;%d%d&quot;,&amp;s,&amp;t); q.push(s);//一开始起点入队 dis[s]=0; while(!q.empty()) { for(int i=head[q.front()];i!=-1;i=edge[i].next) if(dis[q.front()]+edge[i].w&lt;dis[edge[i].to])//判断相邻的点通过当前点到达是否更短 { dis[edge[i].to]=dis[q.front()]+edge[i].w; q.push(edge[i].to);//如果是，则当前点的值修改，并入队 } q.pop(); } printf(&quot;%.2lf&quot;,dis[t]); return 0;} 整个过程其实和BFS几乎完全一样，这里我介绍一下queue容器的使用。 使用queue容器要包含#include&lt;queue&gt;这个头文件。 queue的定义格式是queue&lt;元素类型&gt;队列名称，如：queue&lt;int&gt;qwq就是定义了一个名字为qwq，元素类型为int的队列 queue一共有6个常用函数： qwq.push(x)：将x元素入队 qwq.pop()：将队头元素出队 qwq.front()：返回队头元素的值（但不出队） qwq.back()：返回队尾元素的值（个人觉得用处不大） qwq.empty()：判断队列是否为空，如果为空，则返回true qwq.size()：返回队列中元素个数 差不多就是这些了，如果还有什么，我后面再补充。 特别注意：SPFA容易被卡！ 在此放上一张经久不衰的图片： 2018 年 7 月 19 日，某位同学在NOI Day 1 T1里非常熟练地使用了一个广为人知的算法SPFA求最短路。 然后呢？ 100→60100 \\rightarrow 60100→60； Ag→CuAg \\rightarrow CuAg→Cu； 最终，他因此没能与理想的大学达成契约。 由于SPFA“优秀”的时间复杂度，所以它经常在各大OJ和OI上被卡，再引用一个人的话。 卡SPFA已经是一个共识了好吧…… 所以在比赛时，最好还是不要用SPFA了…… 优点：比较简单易懂，而且可以处理负边权的情况 缺点：容易被卡 总结 四种最短路径算法个人觉得还是根据具体的题目来看吧，但一般来说我觉得应该是没有负边权就用Dijkstra（实在不行加个堆优化），有负边权就用SPFA好了，也没有必要一味地说SPFA死了，毕竟既然这玩意还没有完全被淘汰不用，就说明它还是有自己的用途的。","link":"/posts/1960909489.html"},{"title":"回顾2019","text":"唉，又过去一年了，离初三毕业又近了一点了 这一年过的好悲惨啊 文化课凉凉~~，OI也没什么太大的进展，怎么说呢，很不如意吧 PS：这是蒟蒻第一次写年终总结，所以可能有点水，请不要介意 OI方面 总体来说今年在OI这块还算不错吧，参加了人生中第一次CSP，就拿了一个不错 的成绩，J组一等，虽然这还很微不足道，但也是算一个小小的成就吧（毕竟这样就能稳保直升了），而且通过这次比赛，也是拓宽了眼界，见到了很多巨佬，同时也学到了很多。 给一些还未参加过OI的同学一些建议（纯属个人主观意见）： 首先，在考试前，不要太紧张，J组没什么难的，只要有一些基础，会模拟、简单dp，最好是再来一点图论知识，只要不出大问题，一般一等是稳的 其次，不要觉得骗分是多么不好的行为，只要不是作弊（或卡评测姬）， 没人规定不准骗分，甚至有时骗的比正解还好（比如我今年T4用邻接矩阵加记忆化dfs拿了80pts） 还有，不要过早地给自己下定义，比如觉得自己铁定凉凉什么的，一切要等尘埃落定后才知道，我今年做T4时，贪心把邻接矩阵开大了一些，结果考完了又记错了，以为自己MLE了（这样就只有100+100+10+0=210pts了，在SC正好拿不到一等），难过了好久，结果发现只是记错了，最后总分是290pts，稳上分数线 最后，不要就此结束，J组只是一个很小很小的成就，甚至很多学校都不屑去参加，如果你是真正把OI当成一个兴趣爱好或一种以后的谋生手段来搞，那这是远远不够的，至少都要拿个S组一等才行吧。 （以上内容请dalao勿喷） 除了参加CSP，今年我也想了很多 我现在学OI是为了什么？升学？声誉？谋生？我觉得都不是，仿佛就是一瞬间，我就选中了OI，决定把它当成一生为之奋斗的东西，有时就是这么神奇，有人苦苦寻觅一生的东西，你却一下子就找到了，有人直到老了，都不知道自己这一生是在干嘛，而我却很幸运，在最好的年华就找到了自己的路，或许，这就是一种缘分吧。 我该怎么去学好OI这门竞赛？OI之路说长不长，说短不短，五年时间，也能干很多事了，但如果没有目标，没有计划，就会像dfs没了vis标记，永远停留在函数中直到崩溃，但我现在就属于没有什么触手可及的或是量化的目标来完成，每天都只是跟着老师上课，再在洛谷上刷刷题，红题、橙题、黄题都做了不少，但却没有一点实质性的用处，我希望自学，但却缺乏途径，有了书，又没有时间来练（其实是因为自己时间规划得太差了），这些我现在都没有想清，准备留到寒假再想好了。 我的终极目标是什么？我的班主任曾说过他很羡慕我有自己的目标，人生规划和计划，但其实细想一下，我根本还没有想清。我想去上姚班，但姚班一年只在全国招不到50个人，还要算上数学和物理竞赛的巨佬，这太难太难了，能靠OI获得清华自招的名额都难，更别提姚班了。撇开上大学不说，工作呢？和程序设计有关的工作数不胜数，从低级码农，到顶级科研，我喜欢的到底是OI的什么？是AC的瞬间？还是一行行代码在IDE中被打出，实现？或许我现在还太年轻，没有这个脑子想清这些问题。 总的来说，这一年在OI上过的还是挺好的，在机房也结识了很多朋友，毕竟我是个实验班的蒟蒻，又不善于跟人打交道，所以直到今年暑假才开始有点存在感，但有些地方还是跟竞赛班的大佬很不一样，也没有什么共同的语言，对彼此班上的梗都不了解，说了也是白说。 文化课方面 今年文化课是铁定砸掉了，尤其是历史（政治不清楚，估计也差不多），由于CSP前一两周在机房积极备考，所以逃掉了不少课，再加上开学一个月后历史书又被人不声不响地拿走，我就没好好听过几堂历史课，所以历史肯定是没希望了，只要不在80分以下就行了（80分以下要抄书……）。 最近这几周一直学习不在状态，老是想颓，周末做完作业就了事，学校里也总是心不在焉，废话多，静不下心。语文、英语模拟考都GG了，最拿手的数学最近也不是很理想，现在感觉很痛苦，想要挣扎出这个泥潭，却又来不及了，只能眼睁睁地看着QMKS一点一点逼近，却又无能为力，幻想着奇迹发生，但理智又告诉我不可能，没有办法，只能硬着头皮去考了。 但总体来说，今年一整年的文化课搞得还是有声有色，拿了一次年级第七名，一次年级第八名，如果半期以后能再好一点，就比较完美了。 总结一下，2020年在文化课方面主要注意以下几点： 上课一定要认真听讲，虽然这很像套话，但事实证明，上课的确很重要 课后要注意复习，周末时应把平时讲的内容拿出来看一看，至少是把历史看一遍（理工男表示文科真的让我很抓狂） 周末要注意对手机和电脑的把控，适当颓废有益健康，过度玩乐摧残文化，这个还是不能不管的 注意刷题，周末和平时都要有计划地水做一些数学和物理，这个到了寒假再具体计划 最后再回顾一下，如果要用一个词语概括我的2019年的话，我觉得应该是遗憾吧，没能把好成绩一直延续到最后 希望2020年，我能让自己重新振作起来，不要重蹈2019的覆辙了 新年，加油！ Ps：一些新年小计划： 文化课拿一次年级前五 语文得一次130分 数学拿一次150 学好物理力学，不要挂科 在机房AK一次 绿名，绿名，绿名！！！ AC500道 Fighting！！！","link":"/posts/1276451225.html"},{"title":"【笔记】图论-树链剖分","text":"树链剖分，听起来确实是一种很高级的算法，但其实它并没有想象中的那么难以理解，事实上，个人觉得，树剖其实根本没有什么太大的思维难度（老实说我觉得怕不是背包都比它要难理解），只是码量大亿点，但只要熟练掌握了，打代码其实也并没有那么难 所谓树链剖分，是用来解决一类树上问题的，它将一棵树剖成很多条链，把树上问题转化成序列问题，然后用其它一些数据结构，比如线段树来维护树上路径的信息 举个例子，比如给定一棵树，每个点有自己的权值，要求查询某两点之间的路径上的所有点的点权和，看起来很简单是不是？用倍增在跳的时候顺便统计就行了，那么如果再要求支持改变某个点的点权呢，或是给某两点之间的路径上的所有点的点权全部加上一个数呢？倍增很明显就不行了吧，这时候就要用到树剖了 思路 树链剖分一般指的是重链剖分，在讲解它的思路之前，我们先要明确几个概念 重儿子：一个点的所有儿子中子树节点数量最多的儿子，如果有多个，那就随便选一个 轻儿子：一个点所有儿子中除重儿子以外的其他儿子，也就是说，对于一个点，重儿子是唯一的，但轻儿子不唯一 重边：一个点到它的重儿子之间的边 轻边：一个点到它的轻儿子之间的边 重链：一大堆重边组成的一条链 这么说起来可能有点抽象，还是拿张图最容易理解 在这张图中，蓝色节点表示轻儿子，橙色节点表示重儿子，相应的，蓝色边表示轻边，橙色边表示重边，由绿框框起来的就是重链，特别的，单独一个点也可以叫做重链 这个过程完了之后，整棵树就会被完全剖分成一条一条的重链 接下来是重点 对于这一条一条的重链，很明显我们还是不能直接用线段树去维护，因为每条链中的节点编号并不是连续的，所以，我们还要引入一个东西——DFS序 这个东西就是树剖把树上问题转化成序列问题的关键，所谓DFS序呢，就是在对这棵树进行DFS的时候，标记每个点是第几个到达的，其实也就是强连通分量Tarjan算法里的dfn数组，但树剖不太一样，因为我们需要让一条重链上所有点的DFS序连续，这样才好让这条链变成一个区间，所以，我们在对这棵树进行DFS的时候，优先遍历重儿子，这样就可以保证一条重链上的点的DFS序连续，因为是先把这条重链一拉到底之后再遍历其他的重链 对于上面那棵树，它的DFS序如下（拿蓝框框起来的就是） 我们可以用每个节点的DFS序建一棵线段树，这样，一条重链就是一个连续的区间了，也便于维护 代码实现 首先我们先来看一些变量 dep[]：记录每个点的深度 son[]：记录每个点的重儿子 size[]：记录以当前点为根的子树的节点个数 id[]：记录每个点的DFS序 rk[]：记录每个DFS序对应的点 top[]：记录当前点所在重链的顶部（下称链头），也就是深度最浅的点 其实树链剖分一共只需要两次DFS就可以解决了，第一次求出每个点的深度和重儿子（dep[]，son[]，size[]），第二次记录每个点的DFS序，相当于是连重边（id[]，rk[]，top[]），代码很短，也很好理解 12345678910111213141516171819202122232425void dfs1(int u,int father)//第一次DFS{ dep[u]=dep[father]+1; fa[u]=father; size[u]=1;//这个是把u点自己给算进去 for(int i=0;i&lt;edge[u].size();i++)//这里是用的vector存图 if(edge[u][i]!=father) { dfs1(edge[u][i],u);//先遍历子树 size[u]+=size[edge[u][i]];//累加当前点的子树的节点数 son[u]=size[edge[u][i]]&gt;size[son[u]]? edge[u][i]:son[u];//找重儿子，如果当前儿子的子树比重儿子的子树节点数量更多的话就换过去 }}void dfs2(int u,int father,int t)//第二次DFS，t是当前点所在重链的顶部{ cnt++;//DFS序 top[u]=t; rk[cnt]=u;//当前DFS序对应的节点编号 id[u]=cnt;//当前节点对应的DFS序 if(son[u]) dfs2(son[u],u,t);//一定要优先遍历重儿子啊！！！ for(int i=0;i&lt;edge[u].size();i++) if(edge[u][i]!=son[u]&amp;&amp;edge[u][i]!=father) dfs2(edge[u][i],u,edge[u][i]);} 在第二个DFS中，之所以下面遍历轻儿子的时候把轻儿子所在的重链顶部设成是轻儿子，是因为当前节点和轻儿子并不在一条重链里，自然也就无法充当它所在的重链的顶部 代码是真的很短了，但这其实只是树剖本身的实现，不要忘了，它是用来解决一类问题的，剖的过程确实很简单，但要维护却比较恼火，上面提到过，可以用线段树来维护重链上的信息，这玩意本来码量就很大，再加上有时候还会结合LCA，就更令人难受了 接下来，我会讲一下如何用树剖求LCA，当然，一般来说用树剖求LCA，就一定会有路径查询和路径修改，我会顺带着把这两个也讲一下的 树剖+LCA 如果是做过树剖的题的人，应该知道在这种题中一般会有这种要求，即求这棵树上从uuu到vvv的最短路径上所有点权之和，以及将这棵树上从uuu到vvv的最短路径上所有点的点权加上一个数，而这个最短路径，很明显就是要求LCA 树剖求LCA，思路其实和倍增差不多，都是往上跳，直到跳到同一个点结束，但树剖与倍增又有一点不同，倍增是往上跳2k2^k2k个祖先，而树剖则是直接跳到链头的父亲，因为如果uuu和vvv在同一条重链上，那么可以肯定他们中有一个是对方的祖先，比较一下深度就行了，如果不在同一条重链上，那么我们就先让他们跳到同一条重链上，再按照前面的方法执行 首先，我们比较uuu和vvv链头的深度，避免跳过头，接下来，我们把链头深度较深的那一个（假设是uuu）跳到他链头的父亲，因为如果只跳到链头，那么很明显这个点所在的重链并没有变，只有跳到链头的父亲才是到了另外一条重链，如此循环，直到uuu和vvv的链头是同一个点，也就是它们处于同一条重链上，这时深度浅的那一个就是LCA(u,v)\\text{LCA}(u,v)LCA(u,v) 老规矩，用上面那张图手动模拟一下 假设我们求14和16号点的LCA，过程如下： 首先比较各自链头的深度，很明显是16号点的链头深度更深，因此把16号点跳到链头的父亲11号点 再次比较14号点和11号点的链头深度，这次是14号点，跳到链头的父亲，为7号点 发现7号点和11号点的链头相同，也就是它们处于同一条重链，退出循环 因为7号点深度比11号点的深度更浅，所以LCA(14,16)=7\\text{LCA}(14,16)=7LCA(14,16)=7 当然，一般来说如果只是单纯求LCA还用不到树剖上场，如果必须要用树剖，那就肯定是加了路径修改和路径查询，这两个也是导致树剖码量大的一个很重要的原因。。。 其实只要掌握了树剖求LCA的方法，修改和查询也不是什么难事，上面说过，我们是用节点的DFS序建的线段树，因此每条重链都是一个连续的区间，而重链上的每个点到链头很明显也是连续的，结合刚刚求LCA的跳法，我们只需要在uuu（或vvv）跳到链头的父亲之前先修改（或查询）uuu到链头的点，并在最后出于同一重链上时把uuu到vvv之间的点进行修改（或查询）就行了，具体的可以看一下代码 1234567891011121314151617181920212223242526272829303132333435363738int lca_query(int u,int v)//查询{ int ans=0; while(top[u]!=top[v])//比较链头是否相同 if(dep[top[u]]&gt;=dep[top[v]]) { ans=ans+query(1,id[top[u]],id[u]);//query是线段树的区间查询函数，和普通写法是一样的 u=fa[top[u]];//让这个点跳到链头的父亲 } else { ans=ans+query(1,id[top[v]],id[v]); v=fa[top[v]]; } if(dep[u]&gt;=dep[v]) ans=ans+query(1,id[v],id[u]);//u和v处于同一重链上时单独处理 else ans=ans+query(1,id[u],id[v]); return ans;}void lca_update(int u,int v,int k)//和上面是一样的{ while(top[u]!=top[v]) if(dep[top[u]]&gt;=dep[top[v]]) { update(1,id[top[u]],id[u],k);//update是线段树的区间修改函数，和普通写法也是一样的 u=fa[top[u]]; } else { update(1,id[top[v]],id[v],k); v=fa[top[v]]; } if(dep[u]&gt;=dep[v]) update(1,id[v],id[u],k); else update(1,id[u],id[v],k);} （感觉其实不算很难啊） 一般来说，树剖的题基本上就是路径修改，路径查询，单点修改，单点查询，修改子树，查询子树这几种，后面四种都可以直接用线段树来完成，因为一个点的子树的DFS序也是一个完整的区间，比如上图中7的子树的DFS序就是从3到8，由于之前记录了每棵子树的节点数量，所以这里只需要修改从id[i]到id[i]+size[i]-1这个区间就行了 另外，树剖求LCA的时间复杂度是O(log⁡n)O(\\log n)O(logn)，且常数较小，不容易被卡掉，预处理也是O(n)O(n)O(n)级别的，所以还算比较优秀了 参考代码 题目：P3384 【模板】轻重链剖分 这道题要求支持路径修改，路径查询，子树修改，子树查询四种操作，上面都已经讲过了，就直接贴代码了 感受树剖的码量吧！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169#include&lt;bits/stdc++.h&gt;#define MAXN 100005using namespace std;struct node{ int l; int r; int data; int f;};node tree[MAXN&lt;&lt;2];vector&lt;int&gt; edge[MAXN];int n,m,r,p,cnt,w[MAXN];int dep[MAXN],fa[MAXN],son[MAXN],size[MAXN],top[MAXN],rk[MAXN],id[MAXN];void dfs1(int u,int father)//第一次DFS{ dep[u]=dep[father]+1; fa[u]=father; size[u]=1; for(int i=0;i&lt;edge[u].size();i++) if(edge[u][i]!=father) { dfs1(edge[u][i],u); size[u]+=size[edge[u][i]]; son[u]=size[edge[u][i]]&gt;size[son[u]]? edge[u][i]:son[u]; }}void dfs2(int u,int father,int t)//第二次DFS{ cnt++; top[u]=t; rk[cnt]=u; id[u]=cnt; if(son[u]) dfs2(son[u],u,t); for(int i=0;i&lt;edge[u].size();i++) if(edge[u][i]!=son[u]&amp;&amp;edge[u][i]!=father) dfs2(edge[u][i],u,edge[u][i]);}void push_down(int i)//懒标记下传{ int l=i&lt;&lt;1,r=i&lt;&lt;1|1; if(!tree[i].f) return; tree[l].data=(tree[l].data+tree[i].f*(tree[l].r-tree[l].l+1)%p)%p; tree[r].data=(tree[r].data+tree[i].f*(tree[r].r-tree[r].l+1)%p)%p; tree[l].f=(tree[l].f+tree[i].f)%p; tree[r].f=(tree[r].f+tree[i].f)%p; tree[i].f=0;}void build(int i,int l,int r)//建线段树{ tree[i].l=l; tree[i].r=r; if(l==r) { tree[i].data=w[rk[l]]%p; return; } build(i&lt;&lt;1,l,(l+r)&gt;&gt;1); build(i&lt;&lt;1|1,((l+r)&gt;&gt;1)+1,r); tree[i].data=(tree[i&lt;&lt;1].data+tree[i&lt;&lt;1|1].data)%p;}void update(int i,int l,int r,int k)//线段树区间修改{ if(tree[i].l&gt;=l&amp;&amp;tree[i].r&lt;=r) { tree[i].data=(tree[i].data+(tree[i].r-tree[i].l+1)*k%p)%p; tree[i].f=(tree[i].f+k)%p; return; } push_down(i); if(tree[i&lt;&lt;1].r&gt;=l) update(i&lt;&lt;1,l,r,k); if(tree[i&lt;&lt;1|1].l&lt;=r) update(i&lt;&lt;1|1,l,r,k); tree[i].data=(tree[i&lt;&lt;1].data+tree[i&lt;&lt;1|1].data)%p;}int query(int i,int l,int r)//线段树区间查询{ int ans=0; if(tree[i].l&gt;=l&amp;&amp;tree[i].r&lt;=r) return tree[i].data%p; push_down(i); if(tree[i&lt;&lt;1].r&gt;=l) ans=(ans+query(i&lt;&lt;1,l,r))%p; if(tree[i&lt;&lt;1|1].l&lt;=r) ans=(ans+query(i&lt;&lt;1|1,l,r))%p; return ans%p;}int lca_query(int u,int v)//路径查询{ int ans=0; while(top[u]!=top[v]) if(dep[top[u]]&gt;=dep[top[v]]) { ans=(ans+query(1,id[top[u]],id[u]))%p; u=fa[top[u]]; } else { ans=(ans+query(1,id[top[v]],id[v]))%p; v=fa[top[v]]; } if(dep[u]&gt;=dep[v]) ans=(ans+query(1,id[v],id[u]))%p; else ans=(ans+query(1,id[u],id[v]))%p; return ans;}void lca_update(int u,int v,int k)//路径修改{ while(top[u]!=top[v]) if(dep[top[u]]&gt;=dep[top[v]]) { update(1,id[top[u]],id[u],k); u=fa[top[u]]; } else { update(1,id[top[v]],id[v],k); v=fa[top[v]]; } if(dep[u]&gt;=dep[v]) update(1,id[v],id[u],k); else update(1,id[u],id[v],k);}int main(){ scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;m,&amp;r,&amp;p); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;w[i]); for(int i=1;i&lt;=n-1;i++) { int u,v; scanf(&quot;%d%d&quot;,&amp;u,&amp;v); edge[u].push_back(v); edge[v].push_back(u); } dfs1(r,0); dfs2(r,0,r); build(1,1,n); for(int i=1;i&lt;=m;i++) { int op,x,y,z; scanf(&quot;%d&quot;,&amp;op); switch(op) { case 1: scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z); lca_update(x,y,z); break; case 2: scanf(&quot;%d%d&quot;,&amp;x,&amp;y); printf(&quot;%d\\n&quot;,lca_query(x,y)); break; case 3: scanf(&quot;%d%d&quot;,&amp;x,&amp;z); update(1,id[x],id[x]+size[x]-1,z); break; case 4: scanf(&quot;%d&quot;,&amp;x); printf(&quot;%d\\n&quot;,query(1,id[x],id[x]+size[x]-1)); break; } } return 0;} 其实不算很难懂啦，关键就是码量太大了。。。 相关题目 P3038 [USACO11DEC]Grass Planting G（树剖维护边权，其实可以把边权转化成点权） P4092 [HEOI2016/TJOI2016]树（跟上面说的不太一样，但可以用树剖解决） P4315 月下“毛景树”（差点把我心态搞崩，码量不是一般的大） P2146 [NOI2015]软件包管理器（树剖经典题） P2486 [SDOI2011]染色（有些思维难度，加油！） P3178 [HAOI2015]树上操作（板子题） 其实真正开始做树剖的题就会发现，其实很多代码是通用的，完全可以把上一道题的代码复制过来稍微改一下就行了，但我个人不推荐这样做，毕竟要想熟练掌握代码，最好的方法就是多打几遍嘛，而且这样还可以练手速，做题做多了之后就可以越打越快（我有一次曾经一天内做了8道树剖题，手都快打废了）","link":"/posts/499196864.html"},{"title":"【笔记】图论-Tarjan算法","text":"Tarjan是一种求强连通分量、双连通分量的常用算法，其拓展例如求缩点、割点、割桥以及2-SAT等都是非常实用的。 这篇文章主要讲一下Tarjan的朴素算法及其在缩点、求割点等方面的应用（主要是因为其他的都不会了QAQ） 什么是强连通分量？ 在有向图G中，如果两个顶点vi,vj间（vi&gt;vj）有一条从vi到vj的有向路径，同时还有一条从vj到vi的有向路径，则称两个顶点强连通。如果有向图G的每两个顶点都强连通，称G是一个强连通图。有向图的极大强连通子图，称为强连通分量。——来自某度的解释 什么意思呢？ 就是说在一个有向图中，有一个或几个子图，从它们中的任何一个点都可以到另外的任意一个点，这个子图就被称为是强连通分量（一个点也可以被称作是强连通分量哦） 另外，这张子图一定要是最大的，即要把所有满足条件的点全部加进这张子图，才能称为是强连通分量。 举个例子： 在这张图中，1,2,3,41,2,3,41,2,3,4和555还有666是三个强连通分量，但1,3,41,3,41,3,4并不能被称为是强连通分量，因为它不是最大的满足条件的子图，必须要加入点2才算。 简单介绍Tarjan算法 Tarjan算法是一种基于DFS（深度优先搜索）的求图的强连通分量的算法，非常常用（还有就是活在《信奥一本通》上的Kosaraju和活在百度百科中的Gabow算法），同时，其时间复杂度为O(n)O(n)O(n)，算是非常优秀的了。 一些变量 tot：当前点是第几个被遍历的。 dfn[]：记录每个点是第几个被遍历的，可以理解为一个时间戳。 low[]：记录每个点不经过祖先节点能到达最早的祖先的时间戳（下称”返祖“好名字）。 PS:这里大部分人写的都是能到达的最早的祖先，但这样就和下面有一个公式不符，所以我改了一下，如果不对希望大佬在评论里指出，谢谢！ stack[]：一个栈，存放强连通分量（不是直接存哦，有一些方法的）。 vis[]：标记每个点是否在栈中。 color[]：记录每个点属于第几个强连通分量。 p[]：记录每个强连通分量有几个点。（最后这两个都是缩点时用的） 算法思路 从一个点出发，遍历整张图。 dfn[]数组初始化为当前点（下称u）被遍历的顺序，同时将u入栈。 初始化low[u]=dfn[u]，因为一个点一定能到达它自己。 枚举所有出边（链式前向星存图），如果这条边到达的点（下称v）还没有被遍历过，则遍历点v，然后更新low[u]，公式为： low[u]=min⁡(low[u],low[v])low[u]= \\min (low[u],low[v]) low[u]=min(low[u],low[v]) 因为点v能到达的祖先节点，点u也一定能到达（废话），所以应该更新点u的low值。 如果v已被遍历过，且v在栈中，也要更新low值公式为： low[u]=min⁡(low[u],dfn[v])low[u]= \\min (low[u],dfn[v]) low[u]=min(low[u],dfn[v]) 因为到达之前到过的点（也就是祖先），说明这个点可以返祖，那么肯定是要更新low值的（更详细的请看下面的“一些可能的问题”） 枚举完所有出边后，如果dfn[u]=low[u]dfn[u]=low[u]dfn[u]=low[u]则说明这个点是一个强连通分量的开始点（梦开始的地方）它不可能属于其他任何一个强连通分量，因为它无法返祖，所以不可能和之前的点组成一个强连通分量，因而它属于一个独立的强连通分量，这时，将栈中在这个点之后入栈的点全部出栈（包括这个点），因为这些点也不属于其他任何一个强连通分量，如果属于，那么u就不可能无法返祖，所以，它们都是同一个强连通分量。 看起来很麻烦是不是？我也觉得下面用图来手模一下就清楚了。 上图： 资源缺乏，凑合着看吧 我们从点1开始遍历，下面是模拟过程： 从点1开始！u=1,dfn[1]=1,low[1]=1,stack={1},vis[1]=1u=1,dfn[1]=1,low[1]=1,stack=\\{1\\},vis[1]=1u=1,dfn[1]=1,low[1]=1,stack={1},vis[1]=1，先遍历点3。 u=3,dfn[3]=2,low[3]=2,stack={1,3},vis[3]=1u=3,dfn[3]=2,low[3]=2,stack=\\{1,3\\},vis[3]=1u=3,dfn[3]=2,low[3]=2,stack={1,3},vis[3]=1，再遍历点5。 u=5,dfn[5]=3,low[5]=3,stack={1,3,5},vis[5]=1u=5,dfn[5]=3,low[5]=3,stack=\\{1,3,5\\},vis[5]=1u=5,dfn[5]=3,low[5]=3,stack={1,3,5},vis[5]=1，遍历点6。 u=6,dfn[6]=4,low[6]=4,stack={1,3,5,6},vis[6]=1u=6,dfn[6]=4,low[6]=4,stack=\\{1,3,5,6\\},vis[6]=1u=6,dfn[6]=4,low[6]=4,stack={1,3,5,6},vis[6]=1，此时没有出边了，开始硬核出栈。 检测到dfn[6]=low[6]dfn[6]=low[6]dfn[6]=low[6]，将栈中点6及其之后的点全部出栈（其实只有一个点），stack={1,3,5},vis[6]=0stack=\\{1,3,5\\},vis[6]=0stack={1,3,5},vis[6]=0，666为一个强连通分量。 回溯到点5，没有出边了，出栈。stack={1,3},vis[5]=0stack=\\{1,3\\},vis[5]=0stack={1,3},vis[5]=0，555为一个强连通分量。 回溯到点3，遍历点4。 u=4,dfn[4]=5,low[4]=5,stack={1,3,4}vis[4]=1u=4,dfn[4]=5,low[4]=5,stack=\\{1,3,4\\}vis[4]=1u=4,dfn[4]=5,low[4]=5,stack={1,3,4}vis[4]=1，接下来遍历点1，发现已经遍历过了，说明点4返祖了（！！！），此时更新low[4]=dfn[1]=1low[4]=dfn[1]=1low[4]=dfn[1]=1。再遍历点6，发现点6已经遍历过了，但又不在栈中，说明点6不属于点4所在的强连通分量，所以不管。此时所有出边枚举完了，回溯到点3。 更新low[3]=min⁡(low[3],low[4])=1low[3]=\\min(low[3],low[4])=1low[3]=min(low[3],low[4])=1（意思是点3能到达点1），没有出边了，回溯到点1。 遍历点2，u=2,dis[2]=6,low[2]=6,stack={1,3,4,2},vis[2]=1u=2,dis[2]=6,low[2]=6,stack=\\{1,3,4,2\\},vis[2]=1u=2,dis[2]=6,low[2]=6,stack={1,3,4,2},vis[2]=1，枚举出边，只有一个点4已经被遍历了，且点4在栈里，low[2]=min⁡(low[2],dfn[4])=5low[2]=\\min(low[2],dfn[4])=5low[2]=min(low[2],dfn[4])=5，枚举完毕，回溯。 点1出边枚举完毕，开始出栈，stack清空，vis清空，1,3,4,21,3,4,21,3,4,2为一个强连通分量。自此，遍历完毕，三个强连通分量全部被求出（完结撒花，感谢陪伴）。 一些可能的问题 Q： 如果这张有向图不连通怎么办？也就是说，如果从一个点出发不能遍历完整张图怎么办？ A： 废话，那就从点1枚举到点n，如果当前点没有被遍历过，就从这一点开始遍历。 Q： 如何判断当前点有没有被遍历过？ A： dfn数组是干嘛的？记录每个点被遍历的顺序啊！如果dfn数组不为0，则表示它已经被更新，也被遍历过了。 Q： 还是没有搞懂为什么遍历完一个点后要把low更新为当前点和这条边的终点的low值中的较小值啊。 A： low数组记录的是能到达的最早的祖先，既然这条边的终点能到达，那起点肯定也能到达啊，同时要取最早的祖先，所以要取较小的值。 Q： 既然许多大佬都说low[]是记录能到的最早的祖先，那为什么出现”返祖“情况时不取祖先的能到达的最早时间戳，而要取祖先的时间戳呢？换句话说，为什么遍历到被遍历过的又在栈里的点（就是祖先嘛）时不用公式low[u]=min⁡(low[u],low[v])low[u]= \\min (low[u],low[v])low[u]=min(low[u],low[v])，而要用公式low[u]=min⁡(low[u],dfn[v])low[u]= \\min(low[u],dfn[v])low[u]=min(low[u],dfn[v])呢？ A： 这个问题其实有点复杂，理论上来说用前者是绝对没有问题的（仅限于求强连通分量的时候），但后面在求割点时，第一个公式就会出bug，所以我将low[]数组定义为不经过祖先节点能到达的最早祖先，详细情况请看后面讲求割点的部分。 （大概就是这些了，如果还有什么问题后面再补充） 参考代码 题目： 洛谷 P2863 [USACO06JAN]牛的舞会The Cow Prom 传送门 （PS：我没有用P2341 【模板】强连通分量 / [HAOI2006]受欢迎的牛，是因为这道题虽然写的是强连通分量的模板，但其实还用到了缩点的知识，不便于朴素算法的理解） 题目大意： 求子图内点的个数大于1的强连通分量个数。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;cstdio&gt;#include&lt;cstring&gt;#define min(a,b) a&lt;b?a:busing namespace std;struct Edge//链式前向星存图{ int next; int to;};Edge edge[50001];int n,m,s,head[10001];int cnt,k,ans,dfn[10001],low[10001],stack[10001],v[10001];//我这里的代码时间和这篇笔记的时间隔了将近5天 //所以有些变量名可能不太一样 //这里v数组就是上面的vis //cnt是上面的totvoid tarjan(int x){ cnt++; dfn[x]=low[x]=cnt; stack[++k]=x; v[x]=1;//初始化各种数组，包括dfn和low初始化为x被遍历到的次序，x入栈，v标记x入栈 for(int i=head[x];i!=-1;i=edge[i].next) if(!dfn[edge[i].to])//如果没有搜过 { tarjan(edge[i].to); low[x]=min(low[x],low[edge[i].to]);//取自己能到的最早祖先和终点能到的最早祖先 } else if(v[edge[i].to])//如果搜过了，且这个点在栈里，说明返祖了 low[x]=min(low[x],dfn[edge[i].to]);//详情见上面 if(dfn[x]==low[x])//如果dfn[x]=low[x]，说明这个点为整个强连通分量中的最老的祖先，也说明整个强连通分量已经遍历完了 { int flag=0; while(stack[k]!=x) { flag=1; v[stack[k]]=0; k--; } v[x]=0; k--; if(flag)//这里是判断这个强连通分量点的个数是否大于1（题目要求） ans++; }}void add_edge(int u,int v){ edge[s].next=head[u]; edge[s].to=v; head[u]=s; s++;}int main(){ memset(head,-1,sizeof(head)); scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) { int a,b; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); add_edge(a,b); } for(int i=1;i&lt;=n;i++) if(!dfn[i]) tarjan(i);//不确定从一个点开始就能遍历完整张图，所以要每个点都试一下 printf(&quot;%d&quot;,ans); return 0;} Tarjan+缩点 What means 缩点？ 一张有向图中，如果存在环，就会造成很多不方便的地方，比如不方便进行动归计算，这时，就可以用缩点来解决问题，所谓缩点，就是将这张有向图中所有的强连通分量变成一个一个的团，然后给这些团加边，形成一张DAG（有向无环图），就便于解决问题了。 这张图会让你更明白一些： 这张图中共有四个强连通分量，已经用红色圈出来了，对其进行缩点操作以后，就会变成下面这个样子： 是不是很棒棒啊仔细研究一番以后，可以发现：点1对应强连通分量1,2,3,41,2,3,41,2,3,4，点2对应强连通分量8,98,98,9，点3对应强连通分量5,6,75,6,75,6,7，点4对应强连通分量101010，此时，这张图中已经不存在环了，可以放心地尽情搞♂事♂情。 算法思路 Tarjan求出强连通分量，并在出栈时更新color和p。 遍历所有边，如果这条边连接的两个点不在同一个强连通分量中，就连边。 看起来很简单是不？没错，就是这么简单，没有别的了，只是有些细节可以再优化一下，下面的代码中会讲到。 参考代码 题目： 洛谷 P3387 【模板】缩点 传送门 题目大意： 将一张有向图缩点，然后在新的图上跑一遍记忆化DFS（DP也行），求出一条经过的点权值和最大的路径。 为什么知道这道题是缩点呢？废话这题目写了是缩点模板的嘛 既然题目告诉我们，可以重复经过一个点或一条边，但权值只计算一次，那么，既然是同一个强连通分量，取了一个，为什么不能取其他的呢？反正可以重复经过，取完一个强连通分量再回到之前的点就行了，完全不影响啊，这样缩完点后，一个强连通分量就是一个点，到达这个点，相当于就是到达了整个强连通分量，同时，在DAG图上跑记忆化，可以做到O(n)O(n)O(n)啊，如果不缩点，那就要重复经过一个点，这样时间复杂度就大大提升了，所以为什么不先用Tarjan跑一遍O(n)O(n)O(n)，再用记忆化跑一遍O(n)O(n)O(n)呢，这样更优啊。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;struct Edge{ int next; int to;};Edge edge[100001];int x[100001],y[100001]; int n,m,s,a[10001],head[10001];int cnt,cur,top,dfn[10001],low[10001],stack[10001],v[10001];//cur是统计强连通分量个数的int np[10001],b[10001];//这里的np相当于是上面的p，b则是colorint ans,f[10001];//f[i]记录的是从第i个强连通分量开始遍历所能取到的最大值void add_edge(int u,int v){ edge[s].next=head[u]; edge[s].to=v; head[u]=s; s++;}void tarjan(int x){ cnt++; dfn[x]=low[x]=cnt; stack[++top]=x; v[x]=1; for(int i=head[x];i!=-1;i=edge[i].next) if(!dfn[edge[i].to]) { tarjan(edge[i].to); low[x]=min(low[x],low[edge[i].to]); } else if(v[edge[i].to]) low[x]=min(low[x],dfn[edge[i].to]); if(dfn[x]==low[x]) { cur++;//当前强连通分量遍历完毕，cur加一 while(stack[top+1]!=x)//这里之所以用top+1是为了把x也弹出来 { v[stack[top]]=0; b[stack[top]]=cur;//标记栈顶的点属于第cur个强连通分量 np[cur]+=a[stack[top]];//p为这一强连通分量中所有点权值之和 top--; } }}void dfs(int x){ if(f[x]) return;//搜过了，就不再搜了 int maxn=np[x]; for(int i=head[x];i!=-1;i=edge[i].next) { if(!f[edge[i].to]) dfs(edge[i].to); maxn=max(maxn,f[edge[i].to]+np[x]);//取所有出边的终点中f的最大值 } f[x]=maxn;}int main(){ memset(head,-1,sizeof(head)); scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); for(int i=1;i&lt;=m;i++) { scanf(&quot;%d%d&quot;,&amp;x[i],&amp;y[i]); add_edge(x[i],y[i]);//优化：将之前的边存下来，便于后面重新建图 } for(int i=1;i&lt;=n;i++) if(!dfn[i]) tarjan(i); memset(head,-1,sizeof(head)); memset(edge,0,sizeof(edge)); s=0; for(int i=1;i&lt;=m;i++)//为什么不用链式前向星遍历：为了节省内存，我们将之前的edge清空 //因为链式前向星不是线性存图，所以一边遍历edge一边用edge来存图会冲突 if(b[x[i]]!=b[y[i]])//b[x[i]]和b[y[i]]分别表示x[i]和y[i]所在的强连通分量 add_edge(b[x[i]],b[y[i]]);//添加第b[x[i]]个强连通分量和第b[y[i]]个强连通分量之间的边 for(int i=1;i&lt;=cur;i++)//缩点后的图不一定从一点出发就能到达所有的点，因此要一个一个枚举 { dfs(i);//记忆化深搜 ans=max(ans,f[i]); } printf(&quot;%d&quot;,ans); return 0;} Tarjan+割点 何为割点？ 在一张无向图中，有一个或几个点，删去之后整张图就不连通了，这样的点称为割点，也就是说，如果没有这个点，一张连通图就会变成几张连通图。 还是举个例子： 在这张无向图中，很容易看出，如果删去点3，整张图就会变成1,21,21,2和4,5,64,5,64,5,6两张连通图，因此，点3为这张无向图的割点，同时，如果删去点4，整张图会变成1,2,31,2,31,2,3和5,65,65,6两张连通图，因此，点4也是这张图的割点。 算法思路 从一个根节点出发，遍历全图。 一边遍历，一边判断当前点是否为割点。 关于如何判断割点，我们分成两部分来考虑。 如果这个点是根节点，那好办，如果它连接两个及以上的连通图，这个点就是割点，因为如果去掉这一点，这些连通图就不连通了（之所以会有两张及以上的连通图，就是因为这些图彼此两两不连通，而只通过根节点连接彼此，所以，如果根节点炸了，这些图就失去了唯一的连通途径，就不连通了） 如果这个点不是根节点，就要判断它下面的点不通过它能否返祖，如果全都可以，则这个点不为割点，因为它的儿子都可以不通过它返祖，那要它也没什么用，但只要有一个儿子必须经过它才能返祖，这个点就是割点，因为去掉它后它的儿子就不能与上面的图连通。 如何判断？ 用这个！if(low[v]≥dfn[u])if(low[v]\\ge dfn[u])if(low[v]≥dfn[u])，low记录的是不经过祖先节点所能访问到的最早的祖先的时间戳，如果儿子的low值比当前节点的时间戳要小（或正好等于它），就说明这个儿子不经过它，是无法访问到更早的点的，所以去掉这个点后，它的儿子和祖先节点的连接就会断掉，就不连通了，所以这个点是割点。 用图来模拟一下好了。 我们从点1开始遍历，因此点1为根节点，它连接了两张连通图（即2,3,42,3,42,3,4和555），如果它炸了，两张连通图就不再相互连通，所以它是割点。再看点2，因为点3和点4不经过点2就无法访问点1，所以，点2如果炸了，点3和点4就不能与点1连通，所以点2也是割点。 一个非常重要的地方 这里就可以看出为什么当遍历时遇到祖先节点时的公式为low[u]=min⁡(low[u],dfn[v])low[u]=\\min(low[u],dfn[v])low[u]=min(low[u],dfn[v])而不是low[u]=min⁡(low[u],low[v])low[u]=\\min(low[u],low[v])low[u]=min(low[u],low[v])了，因为如果是后者的话则计算的是不管怎样到，总之能到达的最早的祖先，这样无法判断这个点最直接的能回到的祖先，也就无法判断割点。在上面的图中，如果用后面那个公式，low[3]和low[4]就都会变成1，此时再判断点2，就不能看出点2是割点了。 参考代码 题目： 洛谷 P3388 【模板】割点（割顶） 传送门 题目大意： 求一张无向图中的割点（注意：是从小到大输出节点！） 参考代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;struct Edge{ int next; int to;};Edge edge[200001];int n,m,s,head[20001];int cnt,top,cur,dfn[20001],low[20001],stack[20001],v[20001],b[20001];//b用来存放割点void add_edge(int u,int v){ edge[s].next=head[u]; edge[s].to=v; head[u]=s; s++;}void tarjan(int x,int root)//root是当前连通图的根节点，也就是最先被遍历的那个点{ int son_cnt=0,flag=0;//son_cnt统计连接的连通图个数 cnt++; dfn[x]=low[x]=cnt; stack[++top]=x; v[x]=1; for(int i=head[x];i!=-1;i=edge[i].next) if(!dfn[edge[i].to]) { tarjan(edge[i].to,root); low[x]=min(low[x],low[edge[i].to]); if(low[edge[i].to]&gt;=dfn[x]&amp;&amp;x!=root) flag=1; if(x==root) son_cnt++;//遍历完一个点后，这个点所在的连通图也就遍历完了，所以加一 } else if(v[edge[i].to]) low[x]=min(low[x],dfn[edge[i].to]);//注意！原因上面讲过了，不这样写的话就会WA if(son_cnt&gt;=2)//如果连接的连通图个数大于一，则这个点为割点 flag=1; if(flag) b[++cur]=x; if(dfn[x]!=low[x]) while(stack[top+1]!=x) { v[stack[top]]=0; top--; }}int main(){ memset(head,-1,sizeof(head)); scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) { int x,y; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); add_edge(x,y); add_edge(y,x);//无向图要添加两条边 } for(int i=1;i&lt;=n;i++) if(!dfn[i]) tarjan(i,i);//枚举所有点，如果没有被遍历过，就从这一点开始遍历 sort(b+1,b+1+cur);//排序！！ printf(&quot;%d\\n&quot;,cur); for(int i=1;i&lt;=cur;i++) printf(&quot;%d &quot;,b[i]); return 0;} 总结 Tarjan算法真的很常用，而且应该算是比较难的一个东西了，它有很多应用，还有很多的扩展，所以一定要把最基础的东西弄牢固，否则会对后面的练习造成困难。 一些相关的题目 洛谷 P1656 炸铁路（割边，与割点的求法有一个很小的不同，看一下题解就知道了） 洛谷 P2341 【模板】强连通分量 / [HAOI2006]受欢迎的牛（缩点） 洛谷 P2746 [USACO5.3]校园网Network of Schools（缩点，有点考智商） 洛谷 P3469 [POI2008]BLO-Blockade（有难度的割点+数学） 洛谷 P5058 [ZJOI2004]嗅探器（有些难度的割点）","link":"/posts/1282189380.html"},{"title":"【笔记】图论-最近公共祖先","text":"前置知识：树 概念 众所周知，在一棵树上，每个点都有其祖先，而最近公共祖先，顾名思义，就是指一个或几个点共有的祖先，且这个祖先的深度最大，为了方便，我们把一个或几个点的最近公共祖先记为LCA(u1,u2,⋯ ,un)\\text{LCA}(u_1,u_2,\\cdots,u_n)LCA(u1​,u2​,⋯,un​) 举个例子，这是一棵树： 其中，LCA(3,12)=2\\text{LCA}(3,12)=2LCA(3,12)=2，LCA(11,12)=4\\text{LCA}(11,12)=4LCA(11,12)=4，LCA(10,14)=1\\text{LCA}(10,14)=1LCA(10,14)=1，LCA(12,2)=2\\text{LCA}(12,2)=2LCA(12,2)=2，而LCA(7,8)≠1\\text{LCA}(7,8)\\neq 1LCA(7,8)​=1，因为555也是他们的公共祖先，并且555的深度比111大。 另外，LCA不一定只是在二叉树上才有（废话），上图很明显就不是一个二叉树 一般来说，LCA有四种求法，即倍增、Tarjan、RMQ+ST表和树链剖分，但本文只记录了三种，没有关于树链剖分的介绍，主要是因为树剖码量比较大，而且如果只是单纯地求某两点的LCA的话很浪费，这玩意用途很大，后面会专门写一篇文章来介绍，到时候反正也要说，所以这里就先不管了 倍增 倍增算是比较常见的求LCA的方法了，同时也是我个人比较喜欢用的一种方法。倍增是在线算法，相当于就是不管什么时候，只要你想求LCA，就可以跑一遍倍增，不需要事先知道所有的输入数据，也就是常说的输入一个回答一个，与之相反的是离线算法，这在Tarjan里面会更详细地讲 思路 一般来说，当我们还没有学过LCA的算法之前，我们首先想到的是暴力，先把两个点挪到相同的高度，然后把它们一层一层往上挪，它们相遇的时候所在的点就是它们的最近公共祖先，但是很明显，这样子太慢了，首先是需要用DFS预处理出每个节点的父亲及其深度，时间复杂度为O(n)O(n)O(n)，然后每次查询的时间复杂度大约为O(log⁡n)O(\\log n)O(logn)（特殊情况另当别论） 而倍增相当于是对暴力算法的优化，不再是一层一层地挪，而是用一个fa[u][i]数组来表示uuu的第2i2^i2i个祖先，实现快速移动 要想理解这一点，首先要理解一点，即通过上述方法，可以使树上的一个点移动到任意一个祖先节点 假设这个点的深度为depudep_udepu​，它的祖先节点的深度为depvdep_vdepv​，那么要跳到vvv去，之间会经过depu−depv+1dep_u-dep_v+1depu​−depv​+1个点，我们把这个数转化成二进制（假设为555），则有： (5)10=(101)2=20+22(5)_{10}=(101)_2=2^0+2^2 (5)10​=(101)2​=20+22 也就是说，uuu只需要先跳到fa[u][0]，再跳到fa[u][2]（这里的uuu已经是原来的fa[u][0]了）就可以到vvv了 另外这个数组有一个递推公式，思路也比较简单，就是自己的第2i−12^{i-1}2i−1个父亲的第2i−12^{i-1}2i−1个父亲就是自己的第2i2^i2i个父亲，即fa[u][i]=fa[fa[u][i-1]][i-1] 既然如此，倍增算法的思路也就出来了，在一开始用DFS预处理出所有的fa[u][i]，然后每次查询时先把两点调到相同的高度，再让两点一起移动就可以了，而这两个过程都可以采用上述方法 但这样又会有一个小问题，我并不知道LCA(u,v)\\text{LCA}(u,v)LCA(u,v)的深度，没有办法预先知道要跳多少，所以在这个过程中就有可能跳到LCA的上方，这个问题也好解决，既然我不知道哪个祖先是它们的最近公共祖先，那我就干脆不跳到他们的公共祖先，只是跳到最接近它们公共祖先的地方，即它们LCA的下一层，然后最后返回fa[u][0]就可以了，这样判断起来也很容易，如果是跳到了共同的祖先，那么fa[u][i]一定会等于fa[v][i]，所以在每次循环时判断一下就好了 还有一点，在最后这里uuu和vvv一起跳的时候，这个循环的顺序和移动uuu到vvv的深度时的顺序是相反的，也就是说这里要把iii从大往小循环，可以这样理解，这个跳的过程就是为这个深度差的二进制位填111的过程，每填一个111，就跳到对应的fa[u][i]（iii为这个111在二进制数里面的位数），之前我们知道这个值是多少，所以可以从低位开始一位一位按照这个给定的值去填，但此时我们并不知道这个值是多少，所以我们必须要尝试，如果从低位开始，那么有可能这一位本来是为000的，但填了111之后并没有超过原数的大小，只有到后面我们才会发现填错了，而如果从高位开始，那么就不会有这种问题。可以联系一下我们小学时学的比较数的大小的方法，先把最低位对齐，然后从最高位一位一位开始比，如果在某一位上一个数的数字小于另一个，那么就可以判断这个数一定小于那个数，这里也是一样的，如果本来是000，被填成了111，那么马上就可以发现这个数大于了深度差，也就是跳到了公共祖先上去 大概的思路就是这样了，可能写的有点迷，要是搞不懂的可以在评论里说一声，我好改进一下 过程模拟 众所周知，手动模拟能解决一切疑惑 我们用上面那棵树来模拟一下这个过程，假设我们求的是LCA(13,12)\\text{LCA}(13,12)LCA(13,12) 发现121212的深度和131313不一样，并且比它深，所以要将其上移，此时深度的差值为111，因此只需要一次u=fa[u][0]即可解决问题，此时121212变为444，而444不为131313，所以131313并不是LCA(13,12)\\text{LCA}(13,12)LCA(13,12) 然后是上跳，从nnn（点数）的二进制最高位开始试（这里求nnn的二进制最高位的位数iii就是求log⁡n\\log nlogn，有一个简便方法：i=log(n)/log(2)+0.5，这个0.50.50.5是起四舍五入的作用的），首先是fa[4][4]和fa[13][4]，发现它们都等于000，则不管它，继续。然后是fa[4][3]和fa[13][3]，和上面一样，不管，继续。fa[4][2]和fa[13][2]也是都等于000，直到fa[4][1]和fa[13][1]才都等于111，虽然我们知道这就是它们的LCA，但程序并不能分辨这是不是最近的公共祖先，所以还是跳过，最后fa[4][0]=2和fa[13][0]=6，这下才能执行u=fa[u][i],v=fa[v][i]的程序，两个点分别变为222和666 最后，返回fa[2][0]=1，求出LCA(13,12)=1\\text{LCA}(13,12)=1LCA(13,12)=1，完毕 参考代码 题目：洛谷 P3379 【模板】最近公共祖先（LCA） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;bits/stdc++.h&gt;using namespace std;struct Edge{ int next; int to;};Edge edge[1000001];//记得要建双向边，因为在输入的时候并不知道谁是谁的父亲int n,m,s,cnt,head[500001];int log2n,dep[500001],fa[500001][21];//log2n上面提到过，记录的是log(n)，dep数组记录每个点的深度，fa[u][i]记录第u个点的第2^i个父亲void add_edge(int u,int v){ cnt++; edge[cnt].next=head[u]; edge[cnt].to=v; head[u]=cnt;}void dfs(int u,int father)//预处理求出dep和fa数组{ fa[u][0]=father; dep[u]=dep[father]+1; for(int i=1;(1&lt;&lt;i)&lt;=dep[u];i++)//1&lt;&lt;i相当于2^i，这里要保证2^i小于u的深度 fa[u][i]=fa[fa[u][i-1]][i-1]; for(int i=head[u];i;i=edge[i].next) if(edge[i].to!=father) dfs(edge[i].to,u);}int lca(int u,int v)//倍增求LCA//因为u和v的值会在函数里发生改变，所以一定要用传参函数，也就是我们平时习惯的那样{ int depu=dep[u],depv=dep[v]; //这里也不能少，和上面一样，u和v的值会在函数里发生改变，但深度又要保持不变，所以另外用两个变量来代替 if(depu!=depv)//如果两个点深度不一样，所以需要调到相同高度 { if(depu&lt;depv)//因为默认是移动u点，所以要保证u在v的下方 { swap(u,v); swap(depu,depv); } for(int i=0;i&lt;=depu-depv;i++) //准确来说这里应该是log(depu-depv)/log(2)+0.5，但我嫌麻烦，而且这样也是对的 if((1&lt;&lt;i)&amp;(depu-depv))//判断第(depu-depv)的第i位是否为1，可以自己算一下 u=fa[u][i]; } if(u==v)//不要忘了判断，如果这里漏了，那么最后的返回值就是fa[LCA(u,v)][0] return u; for(int i=log2n;i&gt;=0;i--)//从高位向低位填1 if(fa[u][i]!=fa[v][i])//判断这一次所跳的点是否为公共祖先 { u=fa[u][i]; v=fa[v][i]; } return fa[u][0];}int main(){ scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;s); for(int i=1;i&lt;=n-1;i++) { int x,y; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); add_edge(x,y); add_edge(y,x); } log2n=log(n)/log(2)+0.5; dfs(s,0); for(int i=1;i&lt;=m;i++) { int a,b; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); printf(&quot;%d\\n&quot;,lca(a,b)); } return 0;} 整个程序不算太难，比较简洁，定义的数组也不多，所以我个人（当然也是很多人）比较喜欢这种算法 倍增的时间复杂度算是比较不错的了，O(nlog⁡n)O(n\\log n)O(nlogn)预处理，O(log⁡n)O(\\log n)O(logn)查询，同时这个nnn一般来说最大也就是1e51e51e5左右，而log⁡n\\log nlogn则不会超过202020，所以总体来说是很优秀的 Tarjan 这个Tarjan并不是求强连通分量的那个Tarjan，只是因为是同一个人发明的，所以都叫一样的名字（误导了我整整一学期=_=），关于这一点有兴趣的同志可以看一下这篇文章：Tarjan 大佬的算法们（根据这篇文章和百度百科看来，Tarjan这个巨佬至少发明了三四种算法和数据结构。。。） Tarjan是一种离线算法，也就是说和上面的倍增不同，它需要事先知道我们有哪些问题，然后一次性全部解决掉，好处是时间复杂度很棒，对于qqq次询问，Tarjan的时间复杂度仅为O(n+q)O(n+q)O(n+q)，但坏处也显而易见，不够灵活 思路 Tarjan其实比较容易理解，先对整棵树进行DFS，在这个过程中，每到一个点uuu并搜完这个点所有的子树后，查看有没有要查询的LCA(u,v)\\text{LCA}(u,v)LCA(u,v)（下称“有询问关系”），如果有，再看一下vvv是否遍历完毕，如果是，那么就找vvv的并查集的祖宗（也就是并查集的根结点，不是指这棵树上vvv的祖宗），这个祖宗就是LCA(u,v)\\text{LCA}(u,v)LCA(u,v)，最后标记自己已经遍历完毕，并把自己合并到父亲节点上（用并查集） 这时有一个小问题 为什么并查集的祖宗就是LCA？？？ 因为在这个过程中，我们是先遍历完所有子树才把自己合并到父亲节点上，此时我们分两种情况讨论，如果uuu和vvv互相都不是对方的祖先，那么它们就处在两棵不同的子树上，如果遍历到vvv时发现uuu已经被遍历过了，那么此时uuu的并查集的祖宗一定在uuu和vvv所属的子树分叉的地方，因为这个点的子树还没有遍历完，还差vvv这棵，所以自然也就不会合并到自己的父亲上去，而这个分叉的地方很明显就是LCA(u,v)\\text{LCA}(u,v)LCA(u,v)。如果uuu和vvv中某一个点是对方的祖先（假设vvv是uuu的祖先），那就更好办了，当遍历到uuu时，vvv由于自己的子树还没遍历完，所以不会打标记，而回溯到vvv时，uuu已经遍历完毕，而vvv还没有把自己合并到父亲节点，所以目前uuu的所属的并查集的根是vvv，也就是LCA(u,v)=v\\text{LCA}(u,v)=vLCA(u,v)=v 搞清楚了这一点，这个算法也就很简单了，如果还有点搞不清楚，那就来手动模拟一次 过程模拟 老规矩，上图 这次我们多弄一点，要求求出LCA(5,3),LCA(7,8),LCA(2,5),LCA(1,4)\\text{LCA}(5,3),\\text{LCA}(7,8),\\text{LCA}(2,5),\\text{LCA}(1,4)LCA(5,3),LCA(7,8),LCA(2,5),LCA(1,4) 首先从点111开始，一路向下，一直到点555，发现这是叶子节点，查看与555有询问关系的333和222，发现它们都还没有标记，所以不管，标记vis5=1,fa5=2vis_5=1,fa_5=2vis5​=1,fa5​=2，然后回溯 回溯到点222，发现它的子节点都搜完了，而有询问关系的点555已经被打了标记，所以查看它的祖先为222，因此LCA(2,5)=2\\text{LCA}(2,5)=2LCA(2,5)=2，标记一下vis2=1,fa2=1vis_2=1,fa_2=1vis2​=1,fa2​=1，回溯 又到了点111，由于子树还没有搜完，因此暂时不查看与点111有询问关系的点，也不打标记，先搜一下点333，一直往下到点777 点777也是个叶子节点，但与777有询问关系的888还没有标记，所以也不管，标记vis7=1,fa7=3vis_7=1,fa_7=3vis7​=1,fa7​=3，回溯到点333，接着又搜点888 到了点888，发现有询问关系的点777已经被打了标记，所以查看777的祖宗，为333，所以LCA(7,8)=3\\text{LCA}(7,8)=3LCA(7,8)=3，再标记vis8=1,fa8=3vis_8=1,fa_8=3vis8​=1,fa8​=3，回溯 回到点333，这时点333的子节点全部搜完，所以查看与点333有询问关系的点555，发现已经被打了标记，所以查看其祖宗，为点111（fa5=2,fa2=1fa_5=2,fa_2=1fa5​=2,fa2​=1，并查集基本操作），因此LCA(5,3)=1\\text{LCA}(5,3)=1LCA(5,3)=1，老规矩，打个标记，vis3=1,fa3=1vis_3=1,fa_3=1vis3​=1,fa3​=1，回溯 又回到了点111，还是没有搜完它的儿子，所以还是不管，来到点444 这点444也是个叶子节点，与111有询问关系，但111还没被打标记，所以还是vis4=1,fa4=1vis_4=1,fa_4=1vis4​=1,fa4​=1，回溯 回到点111，这回终于把它的儿子搜完了，查看点444的祖宗为点111，因此LCA(1,4)=1\\text{LCA}(1,4)=1LCA(1,4)=1，搜索结束 至此，所有要求的LCA都求出来了，直接输出即可 个人感觉不难懂吧，但顺序一定要整好，先查看有询问关系的点，再标记自己，否则就会出现LCA(2,5)=1\\text{LCA}(2,5)=1LCA(2,5)=1的事情 参考代码 老实说我个人并不是很喜欢用Tarjan算法来求LCA\\text{LCA}LCA，因为这玩意数组太多，相对应的函数也很多，整个码量都比较大，不过有时候题目可能会强制离线，比如设置一大堆询问这种，这时候用倍增就有可能会超时，所以还是应该掌握这种算法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;bits/stdc++.h&gt;using namespace std;struct Edge{ int next; int to;};struct Que{ int next; int to; int p;//p表示的是这个询问对应的是第几个问题，方便最后按照顺序输出答案};Edge edge[1000001];Que que[1000001];//我这里使用链式前向星存储询问，这样便于查询某一个点的所有询问，而不用每次都遍历所有问题 //其实是因为当时我太弱了，否则用vector来存其实更方便int n,m,s,cnt,f[500001],head[500001],queh[500001],vis[500001],ans[500001];int find(int x)//并查集基础操作不解释{ return f[x]==x?f[x]:f[x]=find(f[x]);}void add_edge(int u,int v){ cnt++; edge[cnt].next=head[u]; edge[cnt].to=v; head[u]=cnt;}void add_que(int u,int v,int i){ cnt++; que[cnt].next=queh[u]; que[cnt].to=v; que[cnt].p=i; queh[u]=cnt;}void lca(int u,int father){ for(int i=head[u];i;i=edge[i].next)//首先搜索这个点的所有子树 { int v=edge[i].to; if(v!=father&amp;&amp;!vis[v]) { lca(v,u); f[find(v)]=find(u);//这里我是回溯到父节点时才打标记，效果和上面说的查看完所有询问再标记是一样的 //另外，其实直接f[v]=u就可以了，这里只是打并查集习惯了而已 vis[v]=1; } } for(int i=queh[u];i;i=que[i].next)//查看所有询问，如果对方已经被打了标记，就求出答案 if(vis[que[i].to]) ans[que[i].p]=find(que[i].to);}int main(){ scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;s); for(int i=1;i&lt;=n;i++) f[i]=i; for(int i=1;i&lt;=n-1;i++) { int u,v; scanf(&quot;%d%d&quot;,&amp;u,&amp;v); add_edge(u,v); add_edge(v,u); } cnt=0; for(int i=1;i&lt;=m;i++) { int a,b; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); add_que(a,b,i);//这里要建双向边，但对应的p值应该是一样的 add_que(b,a,i); } lca(s,0); for(int i=1;i&lt;=m;i++) printf(&quot;%d\\n&quot;,ans[i]); return 0;} 整个过程还是很简单，如果还有什么不懂的可以在评论里问反正也不会有人看我博客的 RMQ+ST表 这也是一种在线算法，时间复杂度很强，预处理O(nlog⁡n)O(n\\log n)O(nlogn)，而询问只需要O(1)O(1)O(1)，不过有点难想，最重要的就是怎样把求LCA转化成RMQ，以及为什么这样做是对的，搞懂了这一点后，代码其实就好写了 关于ST表以及相应的用它来求RMQ，请自行上网查找，这里不再赘述 思路 在开始之前，我们先引入一个东西，欧拉序列 所谓欧拉序列，其实就是一棵树的DFS序，只不过每到一个节点都得记录一下，就连回溯时也是一样 以上面Tarjan算法那张图为例 这棵树的欧拉序列是这样的 序号 1 2 3 4 5 6 7 8 9 10 11 12 13 点 1 2 5 2 1 3 7 3 8 3 1 4 1 这个序列的长度为2n−12n-12n−1，nnn为这棵树的点数（其实上面这张图只有777个点，我漏了一个666。。。），这个看网上都很少有证明的，虽然不是很重要，但我觉得还是应该知道为妙 首先设点uuu有xux_uxu​个儿子，点的标号从111到nnn，易得，点uuu在这个序列中出现的次数为xu+1x_u+1xu​+1，因为每个儿子回溯时都会出现一次，同时一开始从父亲下来的时候还会出现一次 容易得出 ∑i=1nxi=n−1\\sum\\limits_{i=1}^n x_i=n-1 i=1∑n​xi​=n−1 因为每个点会且只会被算一次（因为每个点只有一个父亲嘛），同时点111作为根节点，没有父亲，所以是没有被算过的，要减去111 这样的话，所有点在这个序列中出现的总次数，也就是这个序列的长度，就是 len=∑i=1nxi+1=∑i=1nxi+n=n−1+n=2n−1len=\\sum\\limits_{i=1}^{n}x_i+1=\\sum\\limits_{i=1}^nx_i+n=n-1+n=2n-1 len=i=1∑n​xi​+1=i=1∑n​xi​+n=n−1+n=2n−1 完事 好了，回归正题，既然有了欧拉序列，我们就可以把树上问题转化成序列问题了 不过问题来了，你怎么知道这就是RMQ呢？ 我们来看，对于任意两点uuu和vvv，设它们第一次出现的位置的序号为posupos_uposu​和posvpos_vposv​，且posu&lt;posvpos_u&lt;pos_vposu​&lt;posv​（大不了如果不满足的话可以把uuu和vvv换一下嘛，不影响），那么在posupos_uposu​和posvpos_vposv​之间，深度最浅的点是哪个？ LCA(u,v)\\text{LCA}(u,v)LCA(u,v)！ 这个可以结合Tarjan算法的并查集合并来想，uuu要么是vvv的祖先，要么不是（因为uuu在序列中先出现，所以如果有一个点是对方的祖先的话，那么uuu一定深度更浅，也就一定是对方的祖先），如果是的话，由于vvv是uuu的子树上的点，所以在vvv第一次出现的时候，uuu的子树一定还没有搜完，也就不可能回溯到比uuu更浅的点，所以在这段区间中，uuu的深度一定是最浅的。如果不是，那么uuu和vvv一定处在LCA(u,v)\\text{LCA}(u,v)LCA(u,v)的两棵不同的子树上，而在搜完自己所有的子树前，LCA(u,v)\\text{LCA}(u,v)LCA(u,v)是不会回溯的，所以它也是这段区间中最浅的点，所以，对于任意两个点uuu和点vvv（posu&lt;posvpos_u&lt;pos_vposu​&lt;posv​），我们只需要找到在序列中posupos_uposu​和posvpos_vposv​之间的深度最小的点，就可以找到它们的LCA，而这很明显就是RMQ 那么为什么非要取每个点第一次出现的位置来作为区间的起讫点呢（不然你想取第几个啊喂）？其实主要还是为了方便，因为有的点只会出现一次嘛，所以记录第一次出现的位置是最方便的了（当然也有可能是其他原因，不过我不太清楚，如果哪位大佬知道可以在评论里说一下） 知道以上几点之后，思路就很简单了，我们先DFS一遍，求出欧拉序列，然后预处理ST表，最后查询就完事了 参考代码 这玩意的代码比较难懂，我个人其实也不是很喜欢用 另外，这里面的ST表数组（也就是那个dp）记录的其实是序列中从iii到i+2j−1i+2^j-1i+2j−1这个区间里的点中具有最小深度的点在这个序列中的下标，并不是最小深度，因为我们只关心这个点是哪个点，而不关心它的具体深度 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;bits/stdc++.h&gt;using namespace std;struct Edge{ int next; int to;};Edge edge[1000001];int n,m,s,cnt,k,head[500001],f[1000001],dep[1000001],p[500001],dp[1000001][21];//f是欧拉序列，dep是序列中每个位置的点的深度，p是每个点在这个序列中第一次出现的位置void add_edge(int u,int v){ cnt++; edge[cnt].next=head[u]; edge[cnt].to=v; head[u]=cnt;}void dfs(int u,int father,int depth){ k++; dep[k]=depth; f[k]=u; p[u]=k;//这是从父亲节点下来的那一次，所以一定是这个点在序列中第一次出现 for(int i=head[u];i;i=edge[i].next) if(edge[i].to!=father) { dfs(edge[i].to,u,depth+1); k++;//搜完一棵子树回溯时也要记录 dep[k]=depth; f[k]=u; }}void RMQ()//ST表初始化{ for(int i=1;i&lt;=2*n-1;i++) dp[i][0]=i; for(int i=1;(1&lt;&lt;i)&lt;=2*n-1;i++) for(int j=1;j+(1&lt;&lt;i)-1&lt;=2*n-1;j++) { int a=dp[j][i-1],b=dp[j+(1&lt;&lt;(i-1))][i-1]; dp[j][i]=dep[a]&lt;dep[b]? a:b;//记录下标，而不是深度 }}int query(int l,int r)//查询{ int t=log(r-l)/log(2.0); int a=dp[l][t],b=dp[r-(1&lt;&lt;t)+1][t]; return dep[a]&lt;dep[b]? f[a]:f[b];}int main(){ scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;s); for(int i=1;i&lt;=n-1;i++) { int x,y; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); add_edge(x,y); add_edge(y,x); } dfs(s,0,1); RMQ(); for(int i=1;i&lt;=m;i++) { int a,b; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); printf(&quot;%d\\n&quot;,query(min(p[a],p[b]),max(p[a],p[b])));//这里就相当于调换顺序 //当然也可以在函数中比较两者大小 //如果前大后小，就调换顺序 } return 0;} 相关题目 SP14932 LCA - Lowest Common Ancestor（板子题） P2420 让我们异或吧（LCA结合路径查询，其实用树剖要好整一点，不过倍增也可以解决） P3398 仓鼠找sugar（主要是证明树上两条路径相交的条件，与LCA有大关系） P2245 星际导航（最小生成树+LCA，这玩意整整恶心了我一个半小时） P3258 [JLOI2014]松鼠的新家（LCA+树上差分，也是很常见的组合了） CF191C Fools and Roads（LCA+树上差分） LCA其实也不算多难的算法吧，但这玩意如果是和其他东西结合起来，可以让人觉得十分恶心，所以还是应该加强训练，提高自己的水平","link":"/posts/undefined.html"},{"title":"Emoji一览表","text":"这张表用来便于预览和复制Emoji语法，源地址 People 预览 语法 预览 语法 预览 语法 :bowtie: :bowtie: 😄 :smile: 😃 :smiley: ☺️ :relaxed: 😏 :smirk: 😍 :heart_eyes: 😘 :kissing_heart: 😚 :kissing_closed_eyes: 😳 :flushed: 😌 :relieved: 😆 :satisfied: 😁 :grin: 😉 :wink: 😜 :stuck_out_tongue_winking_eye: 😝 :stuck_out_tongue_closed_eyes: 😀 :grinning: 😗 :kissing: 😙 :kissing_smiling_eyes: 😛 :stuck_out_tongue: 😴 :sleeping: 😟 :worried: 😧 :anguished: 😮 :open_mouth: 😬 :grimacing: 😕 :confused: 😯 :hushed: 😑 :expressionless: 😒 :unamused: 😅 :sweat_smile: 😓 :sweat: 😥 :disappointed_relieved: 😩 :weary: 😔 :pensive: 😞 :disappointed: 😖 :confounded: 😨 :fearful: 😰 :cold_sweat: 😣 :persevere: 😢 :cry: 😭 :sob: 😂 :joy: 😲 :astonished: 😱 :scream: :neckbeard: :neckbeard: 😫 :tired_face: 😠 :angry: 😡 :rage: 😤 :triumph: 😪 :sleepy: 😋 :yum: 😷 :mask: 😎 :sunglasses: 😵 :dizzy_face: 👿 :imp: 😈 :smiling_imp: 😐 :neutral_face: 😶 :no_mouth: 😇 :innocent: 👽 :alien: 💛 :yellow_heart: 💙 :blue_heart: 💜 :purple_heart: ❤️ :heart: 💚 :green_heart: 💔 :broken_heart: 💓 :heartbeat: 💗 :heartpulse: 💕 :two_hearts: 💞 :revolving_hearts: 💘 :cupid: 💖 :sparkling_heart: ✨ :sparkles: ⭐️ :star: 🌟 :star2: 💫 :dizzy: 💥 :collision: 💢 :anger: ❗️ :exclamation: ❓ :question: ❕ :grey_exclamation: ❔ :grey_question: 💤 :zzz: 💨 :dash: 💦 :sweat_drops: 🎶 :notes: 🎵 :musical_note: 🔥 :fire: 💩 :hankey: 💩 :poop: 💩 :shit: 👍 :+1: 👍 :thumbsup: 👎 :-1: 👎 :thumbsdown: 👌 :ok_hand: 👊 :punch: 👊 :facepunch: ✊ :fist: ✌️ :v: 👋 :wave: ✋ :hand: ✋ :raised_hand: 👐 :open_hands: ☝️ :point_up: 👇 :point_down: 👈 :point_left: 👉 :point_right: 🙌 :raised_hands: 🙏 :pray: 👆 :point_up_2: 👏 :clap: 💪 :muscle: 🤘 :metal: 🖕 :fu: 🏃 :runner: 🏃 :running: 👫 :couple: 👪 :family: 👬 :two_men_holding_hands: 👭 :two_women_holding_hands: 💃 :dancer: 👯 :dancers: 🙆 :ok_woman: 🙅 :no_good: 💁 :information_desk_person: 🙋 :raising_hand: 👰 :bride_with_veil: 🙎 :person_with_pouting_face: 🙍 :person_frowning: 🙇 :bow: :couplekiss: :couplekiss: 💑 :couple_with_heart: 💆 :massage: 💇 :haircut: 💅 :nail_care: 👦 :boy: 👧 :girl: 👩 :woman: 👨 :man: 👶 :baby: 👵 :older_woman: 👴 :older_man: 👱 :person_with_blond_hair: 👲 :man_with_gua_pi_mao: 👳 :man_with_turban: 👷 :construction_worker: 👮 :cop: 👼 :angel: 👸 :princess: 😺 :smiley_cat: 😸 :smile_cat: 😻 :heart_eyes_cat: 😽 :kissing_cat: 😼 :smirk_cat: 🙀 :scream_cat: 😿 :crying_cat_face: 😹 :joy_cat: 😾 :pouting_cat: 👹 :japanese_ogre: 👺 :japanese_goblin: 🙈 :see_no_evil: 🙉 :hear_no_evil: 🙊 :speak_no_evil: 💂 :guardsman: 💀 :skull: 🐾 :feet: 👄 :lips: 💋 :kiss: 💧 :droplet: 👂 :ear: 👀 :eyes: 👃 :nose: 👅 :tongue: 💌 :love_letter: 👤 :bust_in_silhouette: 👥 :busts_in_silhouette: 💬 :speech_balloon: 💭 :thought_balloon: :feelsgood: :feelsgood: :finnadie: :finnadie: :goberserk: :goberserk: :godmode: :godmode: :hurtrealbad: :hurtrealbad: :rage1: :rage1: :rage2: :rage2: :rage3: :rage3: :rage4: :rage4: :suspect: :suspect: :trollface: :trollface: Nature 预览 语法 预览 语法 预览 语法 ☀️ :sunny: ☔️ :umbrella: ☁️ :cloud: ❄️ :snowflake: ⛄️ :snowman: ⚡️ :zap: 🌀 :cyclone: 🌁 :foggy: 🌊 :ocean: 🐱 :cat: 🐶 :dog: 🐭 :mouse: 🐹 :hamster: 🐰 :rabbit: 🐺 :wolf: 🐸 :frog: 🐯 :tiger: 🐨 :koala: 🐻 :bear: 🐷 :pig: 🐽 :pig_nose: 🐮 :cow: 🐗 :boar: 🐵 :monkey_face: 🐒 :monkey: 🐴 :horse: 🐎 :racehorse: 🐫 :camel: 🐑 :sheep: 🐘 :elephant: 🐼 :panda_face: 🐍 :snake: 🐦 :bird: 🐤 :baby_chick: 🐥 :hatched_chick: 🐣 :hatching_chick: 🐔 :chicken: 🐧 :penguin: 🐢 :turtle: 🐛 :bug: 🐝 :honeybee: 🐜 :ant: 🐞 :beetle: 🐌 :snail: 🐙 :octopus: 🐠 :tropical_fish: 🐟 :fish: 🐳 :whale: 🐋 :whale2: 🐬 :dolphin: 🐄 :cow2: 🐏 :ram: 🐀 :rat: 🐃 :water_buffalo: 🐅 :tiger2: 🐇 :rabbit2: 🐉 :dragon: 🐐 :goat: 🐓 :rooster: 🐕 :dog2: 🐖 :pig2: 🐁 :mouse2: 🐂 :ox: 🐲 :dragon_face: 🐡 :blowfish: 🐊 :crocodile: 🐪 :dromedary_camel: 🐆 :leopard: 🐈 :cat2: 🐩 :poodle: 🐾 :paw_prints: 💐 :bouquet: 🌸 :cherry_blossom: 🌷 :tulip: 🍀 :four_leaf_clover: 🌹 :rose: 🌻 :sunflower: 🌺 :hibiscus: 🍁 :maple_leaf: 🍃 :leaves: 🍂 :fallen_leaf: 🌿 :herb: 🍄 :mushroom: 🌵 :cactus: 🌴 :palm_tree: 🌲 :evergreen_tree: 🌳 :deciduous_tree: 🌰 :chestnut: 🌱 :seedling: 🌼 :blossom: 🌾 :ear_of_rice: 🐚 :shell: 🌐 :globe_with_meridians: 🌞 :sun_with_face: 🌝 :full_moon_with_face: 🌚 :new_moon_with_face: 🌑 :new_moon: 🌒 :waxing_crescent_moon: 🌓 :first_quarter_moon: 🌔 :waxing_gibbous_moon: 🌕 :full_moon: 🌖 :waning_gibbous_moon: 🌗 :last_quarter_moon: 🌘 :waning_crescent_moon: 🌜 :last_quarter_moon_with_face: 🌛 :first_quarter_moon_with_face: 🌙 :crescent_moon: 🌍 :earth_africa: 🌎 :earth_americas: 🌏 :earth_asia: 🌋 :volcano: 🌌 :milky_way: ⛅️ :partly_sunny: :octocat: :octocat: :squirrel: :squirrel: Objects 预览 语法 预览 语法 预览 语法 🎍 :bamboo: 💝 :gift_heart: 🎎 :dolls: 🎒 :school_satchel: 🎓 :mortar_board: 🎏 :flags: 🎆 :fireworks: 🎇 :sparkler: 🎐 :wind_chime: 🎑 :rice_scene: 🎃 :jack_o_lantern: 👻 :ghost: 🎅 :santa: 🎄 :christmas_tree: 🎁 :gift: 🔔 :bell: 🔕 :no_bell: 🎋 :tanabata_tree: 🎉 :tada: 🎊 :confetti_ball: 🎈 :balloon: 🔮 :crystal_ball: 💿 :cd: 📀 :dvd: 💾 :floppy_disk: 📷 :camera: 📹 :video_camera: 🎥 :movie_camera: 💻 :computer: 📺 :tv: 📱 :iphone: ☎️ :phone: ☎️ :telephone: 📞 :telephone_receiver: 📟 :pager: 📠 :fax: 💽 :minidisc: 📼 :vhs: 🔉 :sound: 🔈 :speaker: 🔇 :mute: 📢 :loudspeaker: 📣 :mega: ⌛️ :hourglass: ⏳ :hourglass_flowing_sand: ⏰ :alarm_clock: ⌚️ :watch: 📻 :radio: 📡 :satellite: ➿ :loop: 🔍 :mag: 🔎 :mag_right: 🔓 :unlock: 🔒 :lock: 🔏 :lock_with_ink_pen: 🔐 :closed_lock_with_key: 🔑 :key: 💡 :bulb: 🔦 :flashlight: 🔆 :high_brightness: 🔅 :low_brightness: 🔌 :electric_plug: 🔋 :battery: 📲 :calling: ✉️ :email: 📫 :mailbox: 📮 :postbox: 🛀 :bath: 🛁 :bathtub: 🚿 :shower: 🚽 :toilet: 🔧 :wrench: 🔩 :nut_and_bolt: 🔨 :hammer: 💺 :seat: 💰 :moneybag: 💴 :yen: 💵 :dollar: 💷 :pound: 💶 :euro: 💳 :credit_card: 💸 :money_with_wings: 📧 :e-mail: 📥 :inbox_tray: 📤 :outbox_tray: ✉️ :envelope: 📨 :incoming_envelope: 📯 :postal_horn: 📪 :mailbox_closed: 📬 :mailbox_with_mail: 📭 :mailbox_with_no_mail: 📦 :package: 🚪 :door: 🚬 :smoking: 💣 :bomb: 🔫 :gun: 🔪 :hocho: 💊 :pill: 💉 :syringe: 📄 :page_facing_up: 📃 :page_with_curl: 📑 :bookmark_tabs: 📊 :bar_chart: 📈 :chart_with_upwards_trend: 📉 :chart_with_downwards_trend: 📜 :scroll: 📋 :clipboard: 📆 :calendar: 📅 :date: 📇 :card_index: 📁 :file_folder: 📂 :open_file_folder: ✂️ :scissors: 📌 :pushpin: 📎 :paperclip: ✒️ :black_nib: ✏️ :pencil2: 📏 :straight_ruler: 📐 :triangular_ruler: 📕 :closed_book: 📗 :green_book: 📘 :blue_book: 📙 :orange_book: 📓 :notebook: 📔 :notebook_with_decorative_cover: 📒 :ledger: 📚 :books: 🔖 :bookmark: 📛 :name_badge: 🔬 :microscope: 🔭 :telescope: 📰 :newspaper: 🏈 :football: 🏀 :basketball: ⚽️ :soccer: ⚾️ :baseball: 🎾 :tennis: 🎱 :8ball: 🏉 :rugby_football: 🎳 :bowling: ⛳️ :golf: 🚵 :mountain_bicyclist: 🚴 :bicyclist: 🏇 :horse_racing: 🏂 :snowboarder: 🏊 :swimmer: 🏄 :surfer: 🎿 :ski: ♠️ :spades: ♥️ :hearts: ♣️ :clubs: ♦️ :diamonds: 💎 :gem: 💍 :ring: 🏆 :trophy: 🎼 :musical_score: 🎹 :musical_keyboard: 🎻 :violin: 👾 :space_invader: 🎮 :video_game: 🃏 :black_joker: 🎴 :flower_playing_cards: 🎲 :game_die: 🎯 :dart: 🀄️ :mahjong: 🎬 :clapper: 📝 :memo: 📝 :pencil: 📖 :book: 🎨 :art: 🎤 :microphone: 🎧 :headphones: 🎺 :trumpet: 🎷 :saxophone: 🎸 :guitar: 👞 :shoe: 👡 :sandal: 👠 :high_heel: 💄 :lipstick: 👢 :boot: 👕 :shirt: 👕 :tshirt: 👔 :necktie: 👚 :womans_clothes: 👗 :dress: 🎽 :running_shirt_with_sash: 👖 :jeans: 👘 :kimono: 👙 :bikini: 🎀 :ribbon: 🎩 :tophat: 👑 :crown: 👒 :womans_hat: 👞 :mans_shoe: 🌂 :closed_umbrella: 💼 :briefcase: 👜 :handbag: 👝 :pouch: 👛 :purse: 👓 :eyeglasses: 🎣 :fishing_pole_and_fish: ☕️ :coffee: 🍵 :tea: 🍶 :sake: 🍼 :baby_bottle: 🍺 :beer: 🍻 :beers: 🍸 :cocktail: 🍹 :tropical_drink: 🍷 :wine_glass: 🍴 :fork_and_knife: 🍕 :pizza: 🍔 :hamburger: 🍟 :fries: 🍗 :poultry_leg: 🍖 :meat_on_bone: 🍝 :spaghetti: 🍛 :curry: 🍤 :fried_shrimp: 🍱 :bento: 🍣 :sushi: 🍥 :fish_cake: 🍙 :rice_ball: 🍘 :rice_cracker: 🍚 :rice: 🍜 :ramen: 🍲 :stew: 🍢 :oden: 🍡 :dango: 🥚 :egg: 🍞 :bread: 🍩 :doughnut: 🍮 :custard: 🍦 :icecream: 🍨 :ice_cream: 🍧 :shaved_ice: 🎂 :birthday: 🍰 :cake: 🍪 :cookie: 🍫 :chocolate_bar: 🍬 :candy: 🍭 :lollipop: 🍯 :honey_pot: 🍎 :apple: 🍏 :green_apple: 🍊 :tangerine: 🍋 :lemon: 🍒 :cherries: 🍇 :grapes: 🍉 :watermelon: 🍓 :strawberry: 🍑 :peach: 🍈 :melon: 🍌 :banana: 🍐 :pear: 🍍 :pineapple: 🍠 :sweet_potato: 🍆 :eggplant: 🍅 :tomato: 🌽 :corn: Places 预览 语法 预览 语法 预览 语法 🏠 :house: 🏡 :house_with_garden: 🏫 :school: 🏢 :office: 🏣 :post_office: 🏥 :hospital: 🏦 :bank: 🏪 :convenience_store: 🏩 :love_hotel: 🏨 :hotel: 💒 :wedding: ⛪️ :church: 🏬 :department_store: 🏤 :european_post_office: 🌇 :city_sunrise: 🌆 :city_sunset: 🏯 :japanese_castle: 🏰 :european_castle: ⛺️ :tent: 🏭 :factory: 🗼 :tokyo_tower: 🗾 :japan: 🗻 :mount_fuji: 🌄 :sunrise_over_mountains: 🌅 :sunrise: 🌠 :stars: 🗽 :statue_of_liberty: 🌉 :bridge_at_night: 🎠 :carousel_horse: 🌈 :rainbow: 🎡 :ferris_wheel: ⛲️ :fountain: 🎢 :roller_coaster: 🚢 :ship: 🚤 :speedboat: ⛵️ :boat: ⛵️ :sailboat: 🚣 :rowboat: ⚓️ :anchor: 🚀 :rocket: ✈️ :airplane: 🚁 :helicopter: 🚂 :steam_locomotive: 🚊 :tram: 🚞 :mountain_railway: 🚲 :bike: 🚡 :aerial_tramway: 🚟 :suspension_railway: 🚠 :mountain_cableway: 🚜 :tractor: 🚙 :blue_car: 🚘 :oncoming_automobile: 🚗 :car: 🚗 :red_car: 🚕 :taxi: 🚖 :oncoming_taxi: 🚛 :articulated_lorry: 🚌 :bus: 🚍 :oncoming_bus: 🚨 :rotating_light: 🚓 :police_car: 🚔 :oncoming_police_car: 🚒 :fire_engine: 🚑 :ambulance: 🚐 :minibus: 🚚 :truck: 🚋 :train: 🚉 :station: 🚆 :train2: 🚅 :bullettrain_front: 🚄 :bullettrain_side: 🚈 :light_rail: 🚝 :monorail: 🚃 :railway_car: 🚎 :trolleybus: 🎫 :ticket: ⛽️ :fuelpump: 🚦 :vertical_traffic_light: 🚥 :traffic_light: ⚠️ :warning: 🚧 :construction: 🔰 :beginner: 🏧 :atm: 🎰 :slot_machine: 🚏 :busstop: 💈 :barber: ♨️ :hotsprings: 🏁 :checkered_flag: 🎌 :crossed_flags: 🏮 :izakaya_lantern: 🗿 :moyai: 🎪 :circus_tent: 🎭 :performing_arts: 📍 :round_pushpin: 🚩 :triangular_flag_on_post: 🇯🇵 :jp: 🇰🇷 :kr: 🇨🇳 :cn: 🇺🇸 :us: 🇫🇷 :fr: 🇪🇸 :es: 🇮🇹 :it: 🇷🇺 :ru: 🇬🇧 :gb: 🇬🇧 :uk: 🇩🇪 :de: Symbols 预览 语法 预览 语法 预览 语法 1️⃣ :one: 2️⃣ :two: 3️⃣ :three: 4️⃣ :four: 5️⃣ :five: 6️⃣ :six: 7️⃣ :seven: 8️⃣ :eight: 9️⃣ :nine: 🔟 :keycap_ten: 🔢 :1234: 0️⃣ :zero: #️⃣ :hash: 🔣 :symbols: ◀️ :arrow_backward: ⬇️ :arrow_down: ▶️ :arrow_forward: ⬅️ :arrow_left: 🔠 :capital_abcd: 🔡 :abcd: 🔤 :abc: ↙️ :arrow_lower_left: ↘️ :arrow_lower_right: ➡️ :arrow_right: ⬆️ :arrow_up: ↖️ :arrow_upper_left: ↗️ :arrow_upper_right: ⏬ :arrow_double_down: ⏫ :arrow_double_up: 🔽 :arrow_down_small: ⤵️ :arrow_heading_down: ⤴️ :arrow_heading_up: ↩️ :leftwards_arrow_with_hook: ↪️ :arrow_right_hook: ↔️ :left_right_arrow: ↕️ :arrow_up_down: 🔼 :arrow_up_small: 🔃 :arrows_clockwise: 🔄 :arrows_counterclockwise: ⏪ :rewind: ⏩ :fast_forward: ℹ️ :information_source: 🆗 :ok: 🔀 :twisted_rightwards_arrows: 🔁 :repeat: 🔂 :repeat_one: 🆕 :new: 🔝 :top: 🆙 :up: 🆒 :cool: 🆓 :free: 🆖 :ng: 🎦 :cinema: 🈁 :koko: 📶 :signal_strength: :u5272: :u5272: :u5408: :u5408: :u55b6: :u55b6: :u6307: :u6307: :u6708: :u6708: :u6709: :u6709: 🈵 :u6e80: :u7121: :u7121: :u7533: :u7533: :u7a7a: :u7a7a: :u7981: :u7981: 🈂️ :sa: 🚻 :restroom: 🚹 :mens: 🚺 :womens: 🚼 :baby_symbol: 🚭 :no_smoking: 🅿️ :parking: ♿️ :wheelchair: 🚇 :metro: 🛄 :baggage_claim: 🉑 :accept: 🚾 :wc: 🚰 :potable_water: 🚮 :put_litter_in_its_place: ㊙️ :secret: ㊗️ :congratulations: Ⓜ️ :m: 🛂 :passport_control: 🛅 :left_luggage: 🛃 :customs: 🉐 :ideograph_advantage: 🆑 :cl: 🆘 :sos: 🆔 :id: 🚫 :no_entry_sign: 🔞 :underage: 📵 :no_mobile_phones: 🚯 :do_not_litter: 🚱 :non-potable_water: 🚳 :no_bicycles: 🚷 :no_pedestrians: 🚸 :children_crossing: ⛔️ :no_entry: ✳️ :eight_spoked_asterisk: ❇️ :sparkle: ✴️ :eight_pointed_black_star: 💟 :heart_decoration: 🆚 :vs: 📳 :vibration_mode: 📴 :mobile_phone_off: 💹 :chart: 💱 :currency_exchange: ♈️ :aries: ♉️ :taurus: ♊️ :gemini: ♋️ :cancer: ♌️ :leo: ♍️ :virgo: ♎️ :libra: ♏️ :scorpius: ♐️ :sagittarius: ♑️ :capricorn: ♒️ :aquarius: ♓️ :pisces: ⛎ :ophiuchus: 🔯 :six_pointed_star: ❎ :negative_squared_cross_mark: 🅰️ :a: 🅱️ :b: 🆎 :ab: 🅾️ :o2: 💠 :diamond_shape_with_a_dot_inside: ♻️ :recycle: 🔚 :end: 🔙 :back: 🔛 :on: 🔜 :soon: 🕐 :clock1: 🕜 :clock130: 🕙 :clock10: 🕥 :clock1030: 🕚 :clock11: 🕦 :clock1130: 🕛 :clock12: 🕧 :clock1230: 🕑 :clock2: 🕝 :clock230: 🕒 :clock3: 🕞 :clock330: 🕓 :clock4: 🕟 :clock430: 🕔 :clock5: 🕠 :clock530: 🕕 :clock6: 🕡 :clock630: 🕖 :clock7: 🕢 :clock730: 🕗 :clock8: 🕣 :clock830: 🕘 :clock9: 🕤 :clock930: 💲 :heavy_dollar_sign: ©️ :copyright: ®️ :registered: ™️ :tm: ❌ :x: ❗️ :heavy_exclamation_mark: ‼️ :bangbang: ⁉️ :interrobang: ⭕️ :o: ✖️ :heavy_multiplication_x: ➕ :heavy_plus_sign: ➖ :heavy_minus_sign: ➗ :heavy_division_sign: 💮 :white_flower: 💯 :100: ✔️ :heavy_check_mark: ☑️ :ballot_box_with_check: 🔘 :radio_button: 🔗 :link: ➰ :curly_loop: 〰️ :wavy_dash: 〽️ :part_alternation_mark: 🔱 :trident: ▪️ :black_small_square: ▫️ :white_small_square: ◾️ :black_medium_small_square: ◽️ :white_medium_small_square: ◼️ :black_medium_square: ◻️ :white_medium_square: ⬛️ :black_large_square: ⬜️ :white_large_square: ✅ :white_check_mark: 🔲 :black_square_button: 🔳 :white_square_button: ⚫️ :black_circle: ⚪️ :white_circle: 🔴 :red_circle: 🔵 :large_blue_circle: 🔷 :large_blue_diamond: 🔶 :large_orange_diamond: 🔹 :small_blue_diamond: 🔸 :small_orange_diamond: 🔺 :small_red_triangle: 🔻 :small_red_triangle_down: :shipit: :shipit:","link":"/posts/2868108500.html"}],"tags":[{"name":"DP","slug":"DP","link":"/tags/DP/"},{"name":"字符串","slug":"字符串","link":"/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"模拟","slug":"模拟","link":"/tags/%E6%A8%A1%E6%8B%9F/"},{"name":"LCA","slug":"LCA","link":"/tags/LCA/"},{"name":"并查集","slug":"并查集","link":"/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"贪心","slug":"贪心","link":"/tags/%E8%B4%AA%E5%BF%83/"},{"name":"数论","slug":"数论","link":"/tags/%E6%95%B0%E8%AE%BA/"},{"name":"图论","slug":"图论","link":"/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"拓扑排序","slug":"拓扑排序","link":"/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"},{"name":"最短路","slug":"最短路","link":"/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"name":"文化课","slug":"文化课","link":"/tags/%E6%96%87%E5%8C%96%E8%AF%BE/"},{"name":"树链剖分","slug":"树链剖分","link":"/tags/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"},{"name":"Tarjan","slug":"Tarjan","link":"/tags/Tarjan/"},{"name":"工具","slug":"工具","link":"/tags/%E5%B7%A5%E5%85%B7/"}],"categories":[{"name":"题解","slug":"题解","link":"/categories/%E9%A2%98%E8%A7%A3/"},{"name":"学习笔记","slug":"学习笔记","link":"/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"回顾","slug":"回顾","link":"/categories/%E5%9B%9E%E9%A1%BE/"},{"name":"其他","slug":"其他","link":"/categories/%E5%85%B6%E4%BB%96/"}]}
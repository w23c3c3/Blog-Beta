{"pages":[{"title":"关于","text":"🍭关于我 AzuSemisa，常以xiaolin_，Segment_Tree_等用户名出现在网络上 名字由炮姐（Misaka），艾米莉亚碳（Emilia），咲太师傅（Azusagawa）融合而来 初二党，坐标SC-CD，二次元爱好者，除了是一名信息学竞赛生外，更多的还是一名文化课选手（我也不知道当初为什么没选竞赛班选了实验班 擅长划水，颓废，经常模拟赛爆零，是个蒟蒻 爱好有点杂，有闲时喜欢捣鼓一下博客，看看番，听听歌，偶尔会读读书，还喜欢玩MC（慢慢往肥宅的方向发展了 🎨关于本站 建于2020年1月18日，主要发一些题解、笔记和奇奇怪怪的东西 使用Hexo作为框架，Volantis作为主题 托管于Coding和Vercel(ZEIT) 由Github提供源码托管 域名相关服务由腾讯云提供支持 由jsDelivr提供大部分CDN服务","link":"/about/index.html"},{"title":"留言","text":"Your browser does not support the video tag. 欢迎来到我的小窝，在这里留下你的足迹吧😄 建议、问题都可以提出来，也可以一起聊一些OI的话题 有什么不对的地方我也会尽量想办法解决的","link":"/message/index.html"},{"title":"所有分类","text":"","link":"/categories/index.html"},{"title":"友链","text":"加载中，稍等几秒... 如何添加友链？ 请首先添加我的友链，然后在这个页面下方的评论区里申请，申请格式： 1234&quot;name&quot;: &quot;AzuSemisa&quot;,&quot;avatar&quot;: &quot;https://cdn.jsdelivr.net/gh/xiao-lin52/cdn-assets/images/avatar.webp&quot;,&quot;url&quot;: &quot;https://azusemisa.top&quot;,&quot;desc&quot;: &quot;一个OI蒟蒻的小窝&quot; 为了方便笔者添加友链，请遵从这个格式，谢谢！😆 注意事项！ 任何网址都可添加友链，包括但不限于博客，各类网站的主页，只要没有违法内容，都可以申请添加！😘 无论您是大佬，神仙，还是萌新，蒟蒻，抑或是文化课选手，都来者不拒，欢迎互换友链！😉 既然是互换友链，那么希望您能遵守承诺，如果您撤下了我的友链，那么相应的，您的友链也会被撤下，如果有特殊情况，可以在评论里留言。😏 如果您对笔者感兴趣，可以加笔者的微信，加的时候请说明您是从我的博客来的否则有可能被当成骗子🤗 最后，感谢您能访问我的小站🌹","link":"/friends/index.html"},{"title":"所有标签","text":"","link":"/tags/index.html"},{"title":"","text":"404 Not Found - AzuSemisa's Blog @font-face{ font-family: 'Josefin Sans'; src: url('/fonts/JosefinSans-Regular.ttf') format('truetype'); } @font-face{ font-family: 'Noto Serif SC'; src: url('/fonts/NotoSerifSC-Regular.otf') format('opentype'); } span.btn.large > a { padding: 12px 36px 10px 36px; } span.btn > a { display: inline-block; background: #2196f3; color: #fff; padding: 4px 4px 2px 4px; margin: 2px; line-height: 1.1; border-radius: 2px; transition: all .28s ease; -moz-transition: all .28s ease; -webkit-transition: all .28s ease; -o-transition: all .28s ease; } a { color: #32c5ff; cursor: pointer; text-decoration: none; transition: all 0.28s ease; -moz-transition: all 0.28s ease; -webkit-transition: all 0.28s ease; -o-transition: all 0.28s ease; } span.btn.center { display: block; text-align: center; } span.p.small, p.p.small, span.p.large, p.p.large, span.p.huge, p.p.huge, span.p.ultra, p.p.ultra { margin: 0; padding: 0; } span.p.huge, p.p.huge { font-size: 4rem; line-height: 1.4; } span.p.center, p.p.center { display: block; text-align: center; } span.p.bold, p.p.bold { font-weight: bold; } span.p.small, p.p.small { font-size: 0.875rem; } 404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除 回到首页 或 给我留言 document.onkeydown = function(evt) { evt = evt || window.event; if (evt.keyCode == 32) { var box = document.getElementById(\"messageBox\"); box.style.visibility=\"hidden\"; } };","link":"/404.html"}],"posts":[{"title":"【CodeForces 163A】 Substring and Subsequence","text":"印象中好像是唯一一道自己做对的除背包以外的线性DP题（我太菜了QAQ），因此想写篇题解纪念一下 题目大意 题目传送门 翻译有点问题，我这里重新翻一下 大概意思就是说，给你两个字符串sss和ttt，求出有多少对字符串xxx和yyy，满足xxx是sss的子串且yyy是ttt的子序列，答案对1000000007(109+7)1000000007(10^9+7)1000000007(109+7)取模 关于子串和子序列的区别，可以理解为子串是一段连续的区间，而子序列则不一定是连续的 思路 这道题乍一看其实很像最长公共子序列，唯一不同的在于对于sss要取它的子串，我们类比一下最长公共子序列的状态转移方程 dp[i,j]={0 (i=0 or j=0)dp[i−1,j−1]+1 (s[i]=t[j])max⁡(dp[i−1,j],dp[i,j−1]) (s[i]≠t[j])dp[i,j]=\\begin{cases}0\\ (i=0 \\text{ or }j=0)\\\\dp[i-1,j-1]+1\\ (s[i]=t[j])\\\\\\max(dp[i-1,j],dp[i,j-1])\\ (s[i]\\not =t[j])\\end{cases} dp[i,j]=⎩⎪⎨⎪⎧​0 (i=0 or j=0)dp[i−1,j−1]+1 (s[i]=t[j])max(dp[i−1,j],dp[i,j−1]) (s[i]​=t[j])​ dp[i,j]dp[i,j]dp[i,j]表示的是在sss的前iii个字符和ttt的前jjj个字符中的最长公共子序列的长度，因此，对于这道题，我们不妨设dp[i,j]dp[i,j]dp[i,j]为以sss的第iii个字符为结尾的子串与ttt的前jjj个字符中的子序列相同的个数，同样，我们分成两种情况来讨论，一种是s[i]=t[j]s[i]=t[j]s[i]=t[j]，一种是s[i]≠t[j]s[i]\\not =t[j]s[i]​=t[j] 如果s[i]=t[j]s[i]=t[j]s[i]=t[j]，那么当前状态首先应该包括了dp[i−1,j−1]dp[i-1,j-1]dp[i−1,j−1]的所有情况，因为这两个字符是相同的，那么我们相当于是可以在dp[i−1,j−1]dp[i-1,j-1]dp[i−1,j−1]的所有情况后面加上一个相同的字符，结果一定还是成立的，然后还应该包括dp[i,j−1]dp[i,j-1]dp[i,j−1]的所有情况，因为不管当前两个字符是否相同，dp[i,j−1]dp[i,j-1]dp[i,j−1]的所有情况肯定都适用于dp[i,j]dp[i,j]dp[i,j]，最后，dp[i,j]dp[i,j]dp[i,j]还应该包括s[i]s[i]s[i]和t[j]t[j]t[j]这对组合，因为很明显前面两种情况都没有把t[j]t[j]t[j]算进去，所以最后的状态转移方程应该是这样的 dp[i,j]=dp[i,j−1]+dp[i−1,j−1]+1dp[i,j]=dp[i,j-1]+dp[i-1,j-1]+1 dp[i,j]=dp[i,j−1]+dp[i−1,j−1]+1 如果s[i]≠t[j]s[i]\\not = t[j]s[i]​=t[j]，那么上面所说的dp[i−1,j−1]dp[i-1,j-1]dp[i−1,j−1]的情况就不适用于当前情况，也没有s[i]s[i]s[i]和t[j]t[j]t[j]这对组合，所以状态转移方程就是这样的 dp[i,j]=dp[i,j−1]dp[i,j]=dp[i,j-1] dp[i,j]=dp[i,j−1] 最后，由于dp[i,j]dp[i,j]dp[i,j]只统计了以s[i]s[i]s[i]为结尾的子串，所以最终答案应该把所有的dp[i,∣s∣]dp[i,|s|]dp[i,∣s∣]加起来，另外，不要忘记取模 参考代码 其实只要搞清楚状态转移方程了，代码什么的就很好写了，这就是你懒得写注释的理由吗！，关键是要理解思路 12345678910111213141516171819202122#include&lt;bits/stdc++.h&gt;#define mod 1000000007using namespace std;string a,b;int n,m,ans,dp[5001][5001];int main(){ getline(cin,a); getline(cin,b); n=a.length(); m=b.length(); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) if(a[i-1]==b[j-1]) dp[i][j]=(dp[i][j-1]+dp[i-1][j-1]+1)%mod;//取模！！ else dp[i][j]=dp[i][j-1]; for(int i=1;i&lt;=n;i++) ans=(ans+dp[i][m])%mod; printf(&quot;%d&quot;,ans); return 0;}","link":"/posts/3200880746.html"},{"title":"7月22日CWOI题解及总结","text":"这个周三呢，我们机房进行了一次膜你赛，本来以为自己能拿个比较不错的分数的，结果只得了210分，不是很理想，而且这次题也不算特别难，可以说是完全没考出自己应有的水平，所以觉得还是有必要对这次比赛进行一下总结 比赛经过 其实在周二的时候教练就已经跟我们说了要考一次试，普及组难度，再加上我觉得自己最近也学了不少新的算法和数据结构，所以就没怎么放在心上，该颓还是颓，也没有想到要去多做点题来巩固以前的知识什么的 周三下午，教练把我们带到隔壁机房开始考试，T1本来乍一看觉得是道签到题，然后一看数据范围2632^{63}263才知道不是那么简单，想了一小会后决定一边输入一边处理，然后稍微调试了一下，秒了。T2就是道数学题，但数据范围又是2632^{63}263，虽然开了long long还是有点不放心，但也没再多管它。T3初看以为是区间操作，刚刚把build函数打完，仔细一想，不对啊，线段树做不了这道题啊，然后把前面全删了，想了一会，发现可以用队列来做这道题，于是先打了一发，后来发现有点小bug，修了之后就去做T4了。T4先是纠结了一会题目中说的“最短距离”是什么意思，跟旁边的人讨论了一下，决定先打一发最短路板子试试，然后一测大样例，本来以为输出的答案会比正确的要小的，结果居然是正确答案的三倍多，然后又是不停地调啊调，最后在有个判断那里加了一个条件，过了！于是又回去开始检查前三道题 然后，最骚的操作来了 我先是检查了T3，仔细想了一下代码的思路，然后直接写了个数据把自己给hack了，又打了点补丁，把自己的数据测过了，就去检查T2了，然而过了一会我又想了一下，又写了组数据把自己hack了，然而当时只剩下不到两分钟了，再写貌似也来不及了，于是我放弃了T3，又看了一次T2，然后不假思索地把原来的long long改成了unsigned long long，这倒是没什么问题，但我没有发现下面我在去重时为了排除第一个数字为000的情况，把要去重的两个数组的第000个下标都设成了−1-1−1，而且我在改时也没看一下，就直接把改过的交上去了，最终成绩100+60+0+50=210pts100+60+0+50=210\\text{pts}100+60+0+50=210pts，排名第六（老实说T2居然还能得606060分真的是我rp太好了） 题解 A. 灭火 题面 思路 签到题，根据下面非常良心的样例说明可以发现，这道题的答案就是把所有的燃烧值加起来再除以mmm，如果有余数则再加一，但需要注意的是下面的毒瘤数据范围，263×202^{63}\\times 20263×20连unsigned long long都存不下，所以必须要在读入时进行累加并除以mmm，代码和思路都很简单，没什么多说的 代码 1234567891011121314151617181920#include&lt;bits/stdc++.h&gt;using namespace std;long long n,m,sum,ans;int main(){ scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m); for(int i=1; i&lt;=n; i++) { long long t; scanf(&quot;%lld&quot;,&amp;t); sum+=t%m; ans+=t/m+sum/m; sum%=m; } ans+=sum/m; if(sum%m) ans++; printf(&quot;%lld&quot;,ans); return 0;} B. 数学题 题面 思路 题如其名，真的就是一道数学题，首先把题面中给定的式子化简： a−c=c−ba+b=2×ca-c=c-b\\\\ a+b=2\\times c a−c=c−ba+b=2×c 由于ccc的范围不受限制，所以这道题实质上就是求在给定的数中有多少个不同的组合加起来是一个偶数，我们在小学的时候学过，两个奇数加起来等于一个偶数，两个偶数加起来还是等于一个偶数，因此做法很明显，先分别统计一下这串数中有多少个不同的奇数和偶数，然后用排列组合算出答案即可，设有nnn个不同的奇数，mmm个不同的偶数，则答案为Cn2+Cm2C_n^2+C_m^2Cn2​+Cm2​，更具体的这里就不说了，如果不会排列组合的请自行百度 代码 1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;using namespace std;long long n,a,k1,k2,diff1,diff2,odd[100001],even[100001];int main(){ scanf(&quot;%lld&quot;,&amp;n); for(int i=1; i&lt;=n; i++) { scanf(&quot;%lld&quot;,&amp;a); if(a&amp;1) odd[++k1]=a; else even[++k2]=a; } odd[0]=even[0]=-1; sort(odd+1,odd+1+k1); sort(even+1,even+1+k2); for(int i=1; i&lt;=k1; i++) if(odd[i]!=odd[i-1]) diff1++; for(int i=1; i&lt;=k2; i++) if(even[i]!=even[i-1]) diff2++; printf(&quot;%lld&quot;,diff1*(diff1-1)/2+diff2*(diff2-1)/2); return 0;} C. 吃蛋糕 题面 思路 关于这道题，其实我一开始想的是用线段树来做的，然后用一个bitset来储存树上的每个节点有哪些种类的蛋糕，最后用个DFS遍历一下整棵树，但是后来仔细一想发现这样完全是乱搞啊 其实这道题的正解是用队列，从开头开始遍历，每次先把下一个品种入队，再从队头不断弹出队列里已有的品种，直到队头的种类在队列里有且只有一种，在这个过程中用一个num[]记录队列里每个品种的个数，一个sum记录队列里有多少个不同的种类，一个ans记录最短的符合要求的区间，如果sum等于m了，就说明此时这个队列里所有的品种都有，就可以更新ans了 思路很简单，也不难想，但我在考场上只是想到要把队头的重复元素弹出，也就是不管队头元素有没有和队列内部元素重复，只管有没有和队头元素重复，这样很明显是不行的，比如这组数据： 127 52 1 3 4 1 2 5 如果按照我的那种方法来整的话，那么在第二个222入队的时候，由于队头是第一个222，所以会把它弹出去，但此时队列里已经有一个111了，队头的111已经不再需要，但由于我的思路只是比较队尾和队头以及队头和队头后面的元素，而此时队尾是222，队头的下一个元素是333，所以这个111并不会弹出去于是最后的答案就是666，但很明显只要不是瞎子就能看出正确答案应该是555 代码 123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;#define inf 0x3f3f3f3f#define min(a,b) a&lt;b?a:busing namespace std;queue&lt;int&gt; q;int n,m,a,ans=inf,sum,num[10001];int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) { scanf(&quot;%d&quot;,&amp;a); q.push(a); num[a]++; if(num[a]==1) sum++; while(num[q.front()]&gt;1&amp;&amp;q.size()) { num[q.front()]--; q.pop(); } if(sum==m) ans=min(ans,q.size()); } if(ans==inf) printf(&quot;no answer&quot;); else printf(&quot;%d&quot;,ans); return 0;} D. 导弹仓库 题面 思路 这道题其实就是一道最短路，建图后先跑一遍Dijkstra，然后分几种情况进行判断即可，在点上很好判断，直接看这个点的dis值是否等于l就可以了，但在边上的情况却不是很好想，这里分三种情况来讨论（注：下文中“满足条件”指的是满足从首都到仓库的距离为l的条件） 情况一 （图画得丑点不要在意） 在这种情况下，Lu,c+Lv,c=Lu,vL_{u,c}+L_{v,c}=L_{u,v}Lu,c​+Lv,c​=Lu,v​，也就是说不论是经过uuu点到ccc还是经过vvv点到ccc，这个点ccc都是唯一的，因此在这种情况下可以推出： l−disu+l−disv=wu,vl-dis_u+l-dis_v=w_{u,v} l−disu​+l−disv​=wu,v​ 其中lll就是题面中给定的那个，wu,vw_{u,v}wu,v​则是从uuu到vvv的边权 情况二 这种情况是指ccc点不唯一，且ccc只有通过uuu到达才能满足条件，此时，设这条边上另一点满足条件的为c′c'c′，即c′c'c′只有通过vvv点到达才能满足条件，此时，c′c'c′有两种情况，一种是在ccc点左边，一种是在ccc点右边，但由于ccc点通过uuu点到达已经是最短距离，如果c′c'c′还要在ccc点的左边，那么c′c'c′的最短路径就不是通过vvv到达，而是通过uuu到达，而由于ccc才是满足条件的那个点，所以c′c'c′就不满足条件。因此，c′c'c′应该在ccc点的右边，此时可以得出式子： l−disu+l−disv&lt;wu,vl-dis_u+l-dis_v&lt;w_{u,v} l−disu​+l−disv​&lt;wu,v​ 情况三 这种情况其实与第二种类似，但ccc点是通过vvv到达才满足条件，相当于把上面那张图的uuu和vvv换了个位置，因此不再赘述，式子和上面那个是一样的，但需要注意的是，这种情况不能与第二种情况一起判断，即只要满足这个式子就直接把答案加222，因为有可能uuu或vvv正好就满足条件，此时虽然不是第一种情况，但这条边上还是只有一个点，而如果像上面那样的话，就会多算一个 另外还有一点，就是要判断这个点在不在这条边上，这个比较简单，首先看起点的距离是否小于l，再看通过这条边到达终点的距离是否大于l就行了，式子是这样的： disu&lt;l,disu+wu,v&gt;ldis_u&lt;l,dis_u+w_{u,v}&gt;l disu​&lt;l,disu​+wu,v​&gt;l 把这一点理清楚后，代码其实就很简单了 对了，还有一点，由于数据范围比较大，所以普通的Dijkstra会T，要加上堆优化才行 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;bits/stdc++.h&gt;#define pii pair&lt;int,int&gt;#define mp(a,b) make_pair(a,b)#define inf 0x3f3f3f3f#define MAXN 100005using namespace std;struct Edge{ int next; int to; int w;};Edge edge[2*MAXN];priority_queue&lt; pii,vector&lt;pii&gt;,greater&lt;pii&gt; &gt; q;int n,m,s,l,ans,cnt,head[MAXN],dis[MAXN],b[MAXN],u[MAXN],v[MAXN],c[MAXN];void add_edge(int u,int v,int c){ cnt++; edge[cnt].next=head[u]; edge[cnt].to=v; edge[cnt].w=c; head[u]=cnt;}int main(){ memset(dis,inf,sizeof(dis)); scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;s); for(int i=1; i&lt;=m; i++) { scanf(&quot;%d%d%d&quot;,&amp;u[i],&amp;v[i],&amp;c[i]); add_edge(u[i],v[i],c[i]); add_edge(v[i],u[i],c[i]); } scanf(&quot;%d&quot;,&amp;l); dis[s]=0; q.push(mp(0,s)); while(q.size()) { int u=q.top().second; q.pop(); if(b[u]) continue; b[u]=1; for(int i=head[u]; i; i=edge[i].next) { int v=edge[i].to,c=edge[i].w; if(dis[v]&gt;dis[u]+c&amp;&amp;!b[v]) { dis[v]=dis[u]+c; q.push(mp(dis[v],v)); } } } for(int i=1; i&lt;=n; i++) if(dis[i]==l) ans++; for(int i=1;i&lt;=m;i++) { if(l-dis[u[i]]+l-dis[v[i]]==c[i]&amp;&amp;dis[u[i]]&lt;l&amp;&amp;dis[v[i]]&lt;l) ans++; if(l-dis[u[i]]+l-dis[v[i]]&lt;c[i]&amp;&amp;l&gt;dis[u[i]]&amp;&amp;l&lt;dis[u[i]]+c[i]) ans++; if(l-dis[u[i]]+l-dis[v[i]]&lt;c[i]&amp;&amp;l&gt;dis[v[i]]&amp;&amp;l&lt;dis[v[i]]+c[i]) ans++; } printf(&quot;%d&quot;,ans); return 0;} 反思 这次比赛其实仔细想想，真的不算很难，即使是最后一道压轴题难度其实都不大，前面的题更是简单，连最讨厌的dp都没有，但我却还是考的不理想，我认为原因主要有几个： 比赛时间安排不合理，在T1和T2上花的时间过长，大约有40-50分钟，并不是说简单题就不该花时间，但很明显花这么多时间在前两道题上对于后两道题是很不利的，关键是这其中其实有些时间是拿去和旁边的人说话去了，这就很不好了 过于注重更高级的算法和数据结构，忽略了思维的训练，这次的题其实没有一道是真正用到了高级数据结构，几乎全都是思维题，但我还是没有拿到一个较高的分数，说明我在这方面的训练是有欠缺的 练题太少，有些一眼题没能马上看出其做法，积累的太少，必然会导致第二条的结果，如果只会做板子题，即使学再多的算法和数据结构也不可能有用的 这些是我这一段时间的OI学习上存在的问题，希望在最后一周里能有所改进","link":"/posts/66570006.html"},{"title":"【CodeForces 609E】 Minimum spanning tree for each edge","text":"题意很清楚，给定一张带权无向图，对于图上的每一条边，询问包括这一条边的生成树中边权权值之和最小的。 首先想到的方法是每次都先把要求的这条边加入最小生成树，然后跑一遍 Kruskal，但用膝盖想一下都知道这样肯定是会 T 飞的，所以我们可以直接在原来的最小生成树上进行修改，也就是说，把这一条边强行塞进最小生成树，由于这样很明显会形成一个环，所以我们还需要从这个环里再删掉一条边。 假设此时这条边连接的是 uuu 和 vvv 两个点，则从 uuu 到 vvv 的最短路径应该会经过 LCA(u,v)\\text{LCA}(u,v)LCA(u,v)，所以这个环应该是从 uuu 到 LCA(u,v)\\text{LCA}(u,v)LCA(u,v) 再到 vvv 最后回到 uuu，因此，我们需要删掉的边应该是在从 uuu 到 LCA(u,v)\\text{LCA}(u,v)LCA(u,v) 再到 vvv 这条路径上，又因为要求新的最小生成树的权值和最小，所以我们应该尽量删掉权值较大的边。 因此，这道题就变成了先求出最小生成树，然后对于每一条边，询问其两个端点在树上的最短路径中边权最大的边。 这种问题本来可以用树剖做，但由于没有修改操作，不需要那么麻烦其实就是懒，使用倍增求 LCA，在求每个点的第 2i2^i2i 个父亲的时候，另外开一个数组，求每个点到它第 2i2^i2i 个父亲这条路径上最大的边权，然后在往上跳的时候顺便用一个变量统计一下就可以了，具体的看代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include&lt;bits/stdc++.h&gt;#define mp(a,b) make_pair(a,b)#define pll pair&lt;long long,long long&gt;using namespace std;struct Edge{ long long u; long long v; long long c; long long id;};bool cmp(Edge a,Edge b){ return a.c&lt;b.c;}bool cmp2(Edge a,Edge b)//这个是求完最小生成树后还原所有边的顺序的，虽然也可以再开一个数组，但是我懒。{ return a.id&lt;b.id;}Edge a[200001];vector&lt;pll&gt; edge[200001];long long n,m,cnt,k,log2n,f[200001],dep[200001],fa[200001][21],maxn[200001][21];long long find(long long x){ return f[x]==x? f[x]:f[x]=find(f[x]);}void dfs(long long u,long long father){ fa[u][0]=father; dep[u]=dep[father]+1; for(long long i=1;(1&lt;&lt;i)&lt;=dep[u];i++) { fa[u][i]=fa[fa[u][i-1]][i-1]; maxn[u][i]=max(maxn[u][i-1],maxn[fa[u][i-1]][i-1]);//求 u 到它第 2^i 个父亲这条路径上最大的边权。 } for(long long i=0;i&lt;edge[u].size();i++) { long long v=edge[u][i].first,c=edge[u][i].second; if(v!=father) { maxn[v][0]=c;//在搜索儿子前先把这个初始化一下。 dfs(v,u); } }}long long lca(long long u,long long v){ long long depu=dep[u],depv=dep[v],ans=0;//ans 用来统计最大边权。 if(depu!=depv) { if(depu&lt;depv) { swap(depu,depv); swap(u,v); } for(long long i=0;(1&lt;&lt;i)&lt;=depu-depv;i++) if((depu-depv)&amp;(1&lt;&lt;i)) { ans=max(ans,maxn[u][i]); u=fa[u][i]; } } if(u==v) return ans; for(long long i=log2n;i&gt;=0;i--) if(fa[u][i]!=fa[v][i]) { ans=max(ans,max(maxn[u][i],maxn[v][i])); u=fa[u][i]; v=fa[v][i]; } return max(ans,max(maxn[u][0],maxn[v][0]));}signed main(){ scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m); for(long long i=1;i&lt;=n;i++) f[i]=i; for(long long i=1;i&lt;=m;i++) { scanf(&quot;%lld%lld%lld&quot;,&amp;a[i].u,&amp;a[i].v,&amp;a[i].c); a[i].id=i; } sort(a+1,a+1+m,cmp); for(long long i=1;i&lt;=m;i++)//Kruskal 求最小生成树。 { long long t1=find(a[i].u),t2=find(a[i].v); if(t1!=t2) { f[t1]=t2; cnt++; k+=a[i].c; edge[a[i].u].push_back(mp(a[i].v,a[i].c)); edge[a[i].v].push_back(mp(a[i].u,a[i].c)); } if(cnt==n-1) break; } sort(a+1,a+1+m,cmp2); log2n=log(n)/log(2)+0.5; dfs(1,0); for(long long i=1;i&lt;=m;i++) printf(&quot;%lld\\n&quot;,k+a[i].c-lca(a[i].u,a[i].v));//加上当前这条的边权，删去路径上最大的边权。 return 0;} 一开始的时候我还想着要不要判断一下这条边是否是树边，但其实如果是树边的话，那么加上的也是它，删去的也是它，根本没有发生变化，所以没必要特判。 另外，这道题一定要开 long long，因为 109×2⋅10510^9\\times 2\\cdot10^5109×2⋅105 很明显炸 int 了。","link":"/posts/3582173013.html"},{"title":"【CodeForces 827A】 String Reconstruction","text":"其实说实话，在看到这道题时，我并没有想到要用并查集做，我觉得，这道题其实可以暴力。 当然并不是说每输入一个字符串的起始位置就开始暴力更改这个区间，这样肯定是会T的。 我所说的暴力呢，是说在每个区间开始的位置标记这个区间是第几个字符串，如果有多个，就取其中最长的一个（因为根据题目要求一定存在符合要求的字符串，所以最长的一定包含了短的），然后最后在输出的时候判断一下该输出哪个字符串就行了。 那么不属于任何一个区间的地方呢？直接输出a不就完了！还有什么小写字母字符串是比全是a的字符串的字典序还要小呢？ 注意！在输出过程中，如果遇到这个区间还没输出完，又到了另外一个区间的开始位置时，一定要判断当前正在输出的这个字符串能否将遇到的这个区间的字符串完全包含！如果不能，就立马退出，再输出从这个位置开始的字符串。 思路还是很简单的，代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;using namespace std;int n,k,x,m,a[10000001];//a数组标记每个区间所对应的字符串的下标，这个数组一定要开大一点，否则会REstring t[100001];int main(){ scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) { cin&gt;&gt;t[i]&gt;&gt;k; for(int j=1;j&lt;=k;j++) { scanf(&quot;%d&quot;,&amp;x); if(t[a[x]].length()&lt;t[i].length())//如果已有区间从x开始，则比较两字符串的长度 a[x]=i; m=max(m,x); } } int i=1; while(i&lt;=m) { if(!a[i])//如果当前点不属于任何一个区间，输出'a' printf(&quot;a&quot;); else { int j; for(j=0;j&lt;t[a[i]].length();j++)//输出当前区间的字符串 { if(t[a[i+j]].length()+j&gt;t[a[i]].length())//如果遇到另一个区间的开始，且无法完全包含，则退出，因为a默认为0，所以即使不是另一个区间的开始也没有问题 break; else printf(&quot;%c&quot;,t[a[i]][j]); } i+=j; continue; } i++; } return 0;}","link":"/posts/1841004241.html"},{"title":"【洛谷 P3958】 奶酪","text":"当我这样一个蒟蒻看到题解区里都是类似并查集、dfs、bfs这种高深的东西时，真的很难受（因为看不懂） 于是我整了一个小时，终于整出一个人畜无害老少皆宜即使是蒟蒻也能看懂的代码了 以上是废话 思路 简单来说，先按高矮（即z）从小到大排序，如果一个洞能和它前面任何一个洞相连或是直接与下表面相连，就存进一个数组，如果数组中有哪个能和上表面相连，就输出Yes，反之，输出No。 因为事先已经排过了序，所以可以保证数组中的数都是与下表面相连的，就像a1与下底面相连，a2与a1相连，所以a2也是和下底面相连的，所以不用管它和哪个相连，知道是连着的就对了 附上喜闻乐见的AC代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define ll long longusing namespace std;struct qwq//结构体定义数组{ ll x; ll y; ll z;};bool cmp(qwq a,qwq b)//自定义结构体sort排序{ if(a.z!=b.z) return a.z&lt;b.z;//一定记得以高矮优先 if(a.x!=b.x) return a.x&lt;b.x; if(a.y!=b.y) return a.y&lt;b.y;}ll dist(ll x1,ll y1,ll z1,ll x2,ll y2,ll z2){ return (x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)+(z1-z2)*(z1-z2);}ll t,n,h,r,s,flag;qwq tree[1010],g[1010];int main(){ scanf(&quot;%lld&quot;,&amp;t); for(int c=1;c&lt;=t;c++) { scanf(&quot;%lld%lld%lld&quot;,&amp;n,&amp;h,&amp;r); s=0; flag=0; memset(tree,0,sizeof(tree));//以上是初始化 for(int i=1;i&lt;=n;i++) scanf(&quot;%lld%lld%lld&quot;,&amp;g[i].x,&amp;g[i].y,&amp;g[i].z); sort(g+1,g+1+n,cmp);//排序 for(int i=1;i&lt;=n;i++) { flag=0; if(g[i].z-r&lt;=0)//如果与下底面相连就直接存入数组 { s++; tree[s].x=g[i].x; tree[s].y=g[i].y; tree[s].z=g[i].z; } for(int j=1;j&lt;=s;j++) if(dist(g[i].x,g[i].y,g[i].z,tree[j].x,tree[j].y,tree[j].z)&lt;=4*r*r)//判断是否相切或相交 { s++; tree[s].x=g[i].x; tree[s].y=g[i].y; tree[s].z=g[i].z; break;//只要有一个与其相连，就退出循环 } if(tree[s].z+r&gt;=h)//判断是否与上顶面相连 { flag=1; break; } } if(flag) printf(&quot;Yes\\n&quot;); else printf(&quot;No\\n&quot;); } return 0;} 如果哪里做的不对，请各位大佬帮忙指出，十分感谢","link":"/posts/3619596124.html"},{"title":"【洛谷 P6014】 斗牛","text":"看到这道题的时候，其实我第一反应是“天哪，这道题这么难，nnn这么大，不是dp就是记忆化吧”（蒟蒻之言，大佬勿喷QAQ） 然后再仔细读了一下题，发现几件事情： 不管nnn有多大，始终会有两张牌不被选。 因为被选上的n−2n-2n−2张牌是101010的倍数，因此个位为000，所以剩下222张牌的个位和这nnn个数之和的个位是一样的。 牌的值仅为111至101010。 于是，我突然想到，既然正着算这n−2n-2n−2个数不容易，那就反过来算剩下的两个数呗！ 所以，最后我的办法是，算出nnn个数的和，桶排每种数值的个数，暴力枚举出两个数，这两个数的和的个位等于所有数总和的个位。 有一个问题，有可能存在多个不同的n−2n-2n−2个数的组合，比如：2,8,1,9{2,8,1,9}2,8,1,9这组数，既可以选出2,8{2,8}2,8，又可以选出1,9{1,9}1,9，怎么办呢？ 其实仔细想一下，不管怎么选，其答案是唯一的，因为所有数的和是唯一的，其个位也是唯一的，所以点数也是唯一的。 还是证明一下吧（蒟蒻用不来数学公式，只能语言描述QAQ）： 令s1=n个数的总和，s2=符合要求的n-2个数的和，s3=剩下2个数的和 ∵s1≡b(mod10),s2≡0(mod10)\\because s1\\equiv b\\pmod{10},s2\\equiv0\\pmod{10}∵s1≡b(mod10),s2≡0(mod10) ∴s3≡s1−s2≡b−0≡b(mod10)\\therefore s3\\equiv s1-s2\\equiv b-0 \\equiv b\\pmod{10}∴s3≡s1−s2≡b−0≡b(mod10) 综上所述，要求的2个数之和的个位与n个数之和的个位相同，所以点数是唯一的 代码 1234567891011121314151617181920212223242526#include&lt;cstdio&gt;using namespace std;int n,sum,b[11];//这个题数据较小，sum用int也不会爆int main(){ scanf(&quot;%d&quot;,&amp;n); for(int i=1; i&lt;=n; i++) { int a; scanf(&quot;%d&quot;,&amp;a); sum+=a; b[a]++;//桶排计算各种牌值的个数 } for(int i=1; i&lt;=10; i++) for(int j=1; j&lt;=10; j++)//两重循环暴力求剩下的两个数 if(((i==j&amp;&amp;b[i]&gt;=2)||(i!=j&amp;&amp;b[i]&gt;=1&amp;&amp;b[j]&gt;=1))&amp;&amp;(i+j)%10==sum%10)//判断牌的个数够不够，以及这两张牌的和的个位是否与所有牌的和的个位相同 { if((i+j)%10==0)//记得特判！！！ printf(&quot;10&quot;); else printf(&quot;%d&quot;,(i+j)%10); return 0;//找到了就直接退出，因为点数是唯一的 } printf(&quot;0&quot;); return 0;} 其实这两重循环还可以再优化，但我觉得没有太大的必要了，毕竟这也只循环了100100100次而已。 蒟蒻求赞qwq","link":"/posts/1392144638.html"},{"title":"【CodeForces 977D】 Divide by three, multiply by two","text":"这道题我一看，按一定要求排列一个序列，这不就是我刚刚学的拓扑排序吗？ 关于拓扑排序，如果不了解的，可以康一康这篇文章：【笔记】图论-拓扑排序。 思路 先用两个循环，找出所有符合题目要求的数对（比如两个数分别为aia_iai​和aja_jaj​，如果ai×2=aja_i\\times 2=a_jai​×2=aj​或aj×3=aia_j\\times 3=a_iaj​×3=ai​即为符合要求），连有向边（在上面那个例子中就是连一条从aia_iai​到aja_jaj​的边），然后跑一边裸的拓扑，完事。 看上去很简单对不对？但我在写代码的时候突然想到一个问题。 拓扑排序只能处理 DAG（有向无环图），如果这个东西有环怎么办？ 于是我又开始证明在这道题中按我刚才的想法建图不可能存在环，过程如下： 设uuu为当前点的值,n,mn,mn,m为任意值。 如果图中存在环，当且仅当有下面两种情况： 2n3m⋅u=12⋅u\\dfrac{2^n}{3^m}\\cdot u=\\dfrac{1}{2}\\cdot u 3m2n​⋅u=21​⋅u 或 2n3m⋅u=3⋅u\\dfrac{2^n}{3^m}\\cdot u=3\\cdot u 3m2n​⋅u=3⋅u 注：2n3m⋅u\\dfrac{2^n}{3^m}\\cdot u3m2n​⋅u其实就是经过nnn次乘222和mmm次除333后所得到的值。 我们一个一个来证明。 第一种： ∵2n3m=12\\because \\dfrac{2^n}{3^m}=\\dfrac{1}{2} ∵3m2n​=21​ ∴2n+1=3m\\therefore 2^{n+1}=3^m ∴2n+1=3m ∵2n+1 mod 2=0,3m mod 2≠0\\because 2^{n+1} \\bmod 2=0,3^m \\bmod 2 \\not = 0 ∵2n+1mod2=0,3mmod2​=0 无解 第二种： ∵2n3m=3\\because \\dfrac{2^n}{3^m}=3 ∵3m2n​=3 ∴2n=3m+1\\therefore 2^n=3^{m+1} ∴2n=3m+1 无解 综上所述，本题所建的图中不可能有环。 既然没有环，那我们就可以快乐地跑拓扑了！ 代码 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;using namespace std;int n,tot,in[101],ans[101],edge[101][101];long long a[101];queue&lt;int&gt; q;void topo()//拓扑{ for(int i=1;i&lt;=n;i++) if(!in[i]) q.push(i); while(!q.empty()) { int u=q.front(); q.pop(); ans[++tot]=u;//这里我的ans数组是存的下标 for(int i=1;i&lt;=n;i++) if(edge[u][i]) { in[i]--; if(!in[i]) q.push(i); } } for(int i=1;i&lt;=n;i++) printf(&quot;%lld &quot;,a[ans[i]]);}int main(){ scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) scanf(&quot;%lld&quot;,&amp;a[i]); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) if((a[i]*2==a[j])||(a[i]%3==0&amp;&amp;a[i]/3==a[j]))//按照上面所说的方法建图 { edge[i][j]=1; in[j]++; } topo(); return 0;} 整个过程其实还是很简单的，主要是要证明没有环。","link":"/posts/177385609.html"},{"title":"【洛谷 P6195】 迫害","text":"题目传送门 这道题，乍一看很难，但其实就是一道推结论的数学题。 相信大家在小学的时候都做过这样一道数学题吧：大意就是如何用最少的正整数凑出最多的连续的正整数（随便口胡了一下，差不多就行了），其思路大致如下： 先取111，因为这是最小的正整数。 再取222，因为一个111凑不出222。 再取444，因为1+2=31+2=31+2=3，无法凑出444。 再取888，因为1+4=5,2+4=6,1+2+4=71+4=5,2+4=6,1+2+4=71+4=5,2+4=6,1+2+4=7，凑不出888。 ⋯\\cdots⋯ 由此，我们可以看出一个规律，当每次取前面取过的所有数的和再加一时，可以凑出最多的正整数，即： mi=∑j=1i−1mj+1m_i=\\sum\\limits_{j=1}^{i-1}m_j+1 mi​=j=1∑i−1​mj​+1 铺垫完毕。 过程 接下来我们进入这道题的分析。 根据上述规律，我们可以看出，这道题其实也有着异曲同工之妙，由于有mmm个数可以取任意值，我们就按照以上策略来取（由于nnn代表的是有nnn个111，所以可以当成是补漏的），设xix_ixi​表示第iii次取的值，则有： x1=n+1x_1=n+1 x1​=n+1 x2=x1+n+1=2⋅n+2=2⋅(n+1)x_2=x_1+n+1=2\\cdot n+2=2\\cdot(n+1) x2​=x1​+n+1=2⋅n+2=2⋅(n+1) x3=x1+x2+n+1=4⋅n+4=4⋅(n+1)x_3=x_1+x_2+n+1=4\\cdot n+4=4\\cdot(n+1) x3​=x1​+x2​+n+1=4⋅n+4=4⋅(n+1) x4=x1+x2+x3+n+1=8⋅n+8=8⋅(n+1)x_4=x_1+x_2+x_3+n+1=8\\cdot n+8=8\\cdot(n+1) x4​=x1​+x2​+x3​+n+1=8⋅n+8=8⋅(n+1) ⋯\\cdots ⋯ xm=2m−1⋅(n+1)x_m=2^{m-1}\\cdot(n+1) xm​=2m−1⋅(n+1) 此时，我们能表示出来的从111开始的连续的正整数就有这么多： ∑i=1mxi+n\\sum\\limits_{i=1}^m x_i+n i=1∑m​xi​+n 即： (1+2+4+8+⋯+2m−1)⋅(n+1)+n(1+2+4+8+\\cdots+2^{m-1})\\cdot(n+1)+n (1+2+4+8+⋯+2m−1)⋅(n+1)+n 怎么样，前面那个式子是不是似曾相识？没错，这是我们小学所学的等比数列！只要把最后的nnn变成n+1−1n+1-1n+1−1，并把n+1n+1n+1合并到前面的那一坨东西里面，就可以弄出这个式子： 2m⋅(n+1)−12^m\\cdot(n+1)-1 2m⋅(n+1)−1 具体过程我不详细解释了，比较简单，手推一下就行了。既然都弄出了这个式子，那我们就可以偷税地去算了。 对了，由于m≤109m\\le 10^9m≤109，直接暴力算乘方明显会超时，所以我们需要用快速幂（不会的同学建议去做一下这道题）。 参考代码 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;#define ll long long#define p 1000000007using namespace std;ll n,m,t;inline ll input()//读入优化{ ll x=0,f=1; char c=getchar(); while(c&lt;'0'||c&gt;'9') { if(c=='-') f=-1; c=getchar(); } while(c&gt;='0'&amp;&amp;c&lt;='9') { x=x*10+c-'0'; c=getchar(); } return x*f;}inline ll ksm(ll b,ll k)//快速幂{ ll ans=1; while(k) { if(k&amp;1)//快速幂里面的位运算，相当于k%2==1 ans=ans*b%p; b=b*b%p; k&gt;&gt;=1;//同上，相当于k/=2 } return ans%p;}int main(){ n=input();//读入优化不解释 m=input(); printf(&quot;%lld&quot;,ksm(2,m)*(n+1)%p-1);//记得取模啊！！！ return 0;} 后记 这道题其实不算很难吧，主要就是推式子那里麻烦了一点，然后要用到快速幂，其他的也并不是很麻烦，不想用读入优化也是可以的，只是因为比赛的时候想优化一下（其实我还加了八聚氧只不过太长了所以就删掉了）。","link":"/posts/3896288680.html"},{"title":"【洛谷 P6101】 出言不逊","text":"谔谔的题目传送门 题意： 每次操作使字符串中的一种字符数量增加一倍，问最少几次操作后字符串长度能大于等于LLL。 思路： 根据这个题意，我们可以看出，其实这个题就是一个贪心的思想，只要一开始选数量最多的那种字符，然后一直将其倍增就好了，为什么呢？因为既然是要求最少的操作次数，那么每次操作能增加的字符数量一定要尽量多，所以我们一开始就选最多的那种字符，就能使每次操作增加的字符数量最大化，这样最后的次数一定是最少的。同时这样倍增一次后，该字符数量还是最多的，那么我们下一次操作就还是选这种字符。 举个例子，在 AKIOI\\texttt{AKIOI}AKIOI 这个字符串中，字符 I\\texttt{I}I 的个数显然是最多的，那么我们一直将其数量倍增，最后能达到的总长度一定比选其他字符要长。 同时我们也可以看出，这道题不可能暴力模拟，因为根据L≤264L\\le2^{64}L≤264这个数据就能看出，谁想暴力，谁就爆零。 那么我们该怎么办呢？推规律呗！ 设s=∣S∣−xs=|S|-xs=∣S∣−x（也就是除开我们要倍增的那种字符以外的字符个数），LiL_iLi​为第iii次操作后的字符串长度。 L1=s+2⋅x=s+21⋅xL_1=s+2\\cdot x=s+2^1\\cdot x L1​=s+2⋅x=s+21⋅x L2=s+2⋅2⋅x=s+22⋅xL_2=s+2\\cdot 2\\cdot x=s+2^2\\cdot x L2​=s+2⋅2⋅x=s+22⋅x L3=s+2⋅2⋅2⋅x=s+23⋅xL_3=s+2\\cdot 2\\cdot 2\\cdot x=s+2^3\\cdot x L3​=s+2⋅2⋅2⋅x=s+23⋅x ⋯\\cdots ⋯ Ln=s+2n⋅xL_n=s+2^n\\cdot x Ln​=s+2n⋅x 由此，这个式子就推出来了，有人可能会说，你这个计算的是nnn次操作后的字符串长度啊，不符合题意啊！这好办，既然要求字符串长度大于等于LLL，也就是LnL_nLn​要大于等于LLL，那我们列个不等式就行了。 s+2n⋅x≥Ls+2^n\\cdot x\\ge L s+2n⋅x≥L 2n≥L−sx2^n\\ge\\dfrac{L-s}{x} 2n≥xL−s​ n≥log⁡(L−sx)n\\ge \\log\\left(\\dfrac{L-s}{x}\\right) n≥log(xL−s​) 完事。 关于计算字符个数，其实也很简单，题目明确说了，一共只有626262种字符，那么我们开个数组，桶排就好了，比如说大写字母个数就存在b1b_{1}b1​到b26b_{26}b26​，小写字母个数就存在b27b_{27}b27​到b52b_{52}b52​，而数字个数就存在b53b_{53}b53​到b62b_{62}b62​。 对了，还有一点重要提醒：开 long long 还是会炸，要开 long double 或 unsigned long long！！！，本题还特别提醒，要注意数据范围，结果我因为没开 long double 调了半小时……。long long 的范围是到263−12^{63}-1263−1，但本题的LLL是到264−12^{64}-1264−1，所以用了 long long 还是不行。 代码： 1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;using namespace std;string s;long long maxn,ans,b[63];long double l;//再次提醒，一定要开 long double 或 unsigned long long。long long my_log(long double x)//我个人不太信得过 cmath 里的函数，所以能自己写的我还是自己写好了。{ long long s=0; while(x&gt;1)//当x为1时，表示长度已经等于L了，所以不能再累加了。 { s++; x/=2; } return s;}int main(){ cin&gt;&gt;s&gt;&gt;l; for(int i=0;i&lt;s.length();i++) { if(s[i]&gt;='A'&amp;&amp;s[i]&lt;='Z')//分段存，判断当前字符属于哪一类，然后对应的下标+1 b[s[i]-'A'+1]++; if(s[i]&gt;='a'&amp;&amp;s[i]&lt;='z') b[s[i]-'a'+27]++; if(s[i]&gt;='0'&amp;&amp;s[i]&lt;='9') b[s[i]-'0'+53]++; } for(int i=1;i&lt;=62;i++)//找出最数量最多的字符 maxn=max(maxn,b[i]); cout&lt;&lt;my_log((l-s.length()+maxn)*1.0/maxn);//这里的1.0主要起转化类型的作用 return 0;//谔谔完毕} 就这样，如果还有不懂的，可以在评论里问，如果有什么不对的地方，还请大佬指出，谢谢！","link":"/posts/570467942.html"},{"title":"【洛谷 P3385】 【模板】负环","text":"本题其实就是最短路的延伸版本，如果不了解最短路的可以看我这篇文章：【笔记】图论-最短路径算法。 如果了解最短路的一定知道， Bellman-Ford 算法是可以判断负环的，方法也很简单，就是在两重循环结束后再遍历每一条边（下文通称称这条边的起点为点uuu，终点为点vvv），如果从点uuu到点vvv比disvdis_vdisv​还要短，那么就存在负环。 为什么呢？我们来看下面这张图： 假设从点1出发，手动模拟一下 Bellman-ford 的两重循环可以算出：dis1=−2,dis2=−1,dis3=1dis_1=-2,dis_2=-1,dis_3=1dis1​=−2,dis2​=−1,dis3​=1，但此时，很明显可以看出，从点333到点111为−3-3−3，比dis1dis_1dis1​还要小，所以此时是存在负环的。 因为如果存在负环，那么每在环中转一圈，就会减小一定的值，这样就不存在最短路了，不论你转多少圈，再转一圈始终会比当前的最短距离短，如果不存在负环，那么最短路就是确定的，也就是说经过n×mn\\times mn×m次循环一定能求出最短的路径。 根据以上思路，我打出了一段代码： 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;using namespace std;int t,n,m,k,u[6001],v[6001],c[6001],dis[2001];//因为有可能全都是双向边，所以数组要开成m的两倍int main(){ scanf(&quot;%d&quot;,&amp;t); while(t--) { memset(dis,0x3f3f3f,sizeof(dis)); k=0; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) { k++; scanf(&quot;%d%d%d&quot;,&amp;u[k],&amp;v[k],&amp;c[k]);//Bellman-Ford这样存边更方便 if(c[k]&gt;=0) { k++; u[k]=v[k-1]; v[k]=u[k-1]; c[k]=c[k-1]; } } dis[1]=0; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=k;j++)//Bellman-Ford朴素算法 dis[v[j]]=min(dis[v[j]],dis[u[j]]+c[j]); for(int i=1;i&lt;=k;i++) if(dis[v[i]]&gt;dis[u[i]]+c[i])//判断负环 { printf(&quot;YE5\\n&quot;);//毒瘤出题人解释一下为什么是YE5！！！ goto l;//懒得写flag，直接跳出循环到l:处 } printf(&quot;N0\\n&quot;); l:; } return 0;} 如果你看到上面这段代码就很高兴地回去改了，那么很遗憾地告诉你，这是90pts的代码。 为什么呢？我们看题目： 寻找一个从顶点111所能到达的负环。 上面那段代码判断的是有没有负环，但题目要求是求从点111能到的负环，所以会错。 什么意思呢？意思是从点111开始，要能到这个负环才行，如果点111与这个负环不连通，那么就还是输出N0。 怎么改呢？很简单，用一个bbb数组表示每个点能否从点111到达，就像 Dijkstra 一样，枚举每条边时，我们判断一下这条边的出发点是否能从点111到达就行了，如果出发点目前不能从点111到达，就不管这条边，如果可以，就把这条边的终点也标记为可以从点111到达。同时，最后在判断负环时，也要判断当前边的出发点是否能从点111到达。这样不能从点111到达的负环就不会被判断到了。 那么，这么做会不会影响disdisdis数组的更新呢？当然不会，我们本来就是为了避免误将没有更新过的点当成已更新过的，才会把disdisdis数组设成无穷大的，现在只是另开了一个数组来代替这个功能而已。 还是比较简单吧，加了几行代码而已： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;using namespace std;int t,n,m,k,u[6001],v[6001],c[6001],dis[2001],b[2001];int main(){ scanf(&quot;%d&quot;,&amp;t); while(t--) { memset(b,0,sizeof(b)); k=0; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) { k++; scanf(&quot;%d%d%d&quot;,&amp;u[k],&amp;v[k],&amp;c[k]); if(c[k]&gt;=0) { k++; u[k]=v[k-1]; v[k]=u[k-1]; c[k]=c[k-1]; } } dis[1]=0; b[1]=1; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=k;j++) if(b[u[j]]) { dis[v[j]]=min(dis[v[j]],dis[u[j]]+c[j]); b[v[j]]=1; } for(int i=1;i&lt;=k;i++) if((b[u[i]]||b[v[i]])&amp;&amp;dis[v[i]]&gt;dis[u[i]]+c[i]) { printf(&quot;YE5\\n&quot;); goto l; } printf(&quot;N0\\n&quot;); l:; } return 0;} 好了，没有套路了，这就是 AC 的代码。 评测记录： Bellman-Ford 真香。","link":"/posts/1479545610.html"},{"title":"【笔记】图论-拓扑排序","text":"拓扑排序，是一种听上去很高级的算法，但其实它是很简单的（就基础算法而言）。 本文主要介绍一下拓扑排序最基本的概念和实现过程。（也就是说是一篇入门文章，大佬们可以不用看了） 什么是拓扑排序？ 在生活中和数学题中，我们常常会遇到需要完成很多件事的情况比如写很多作业，这些事件之间各有先后顺序，即你必须先完成这件事，才能完成另外的事，我们可以根据这些事来画张图（只是个例子）： 在这张图中，每条有向边代表要想完成v，就必须完成u，比如要想打开洛谷，就必须先打开电脑废话。 能不能给这些事排个序，让我按照这个顺序来做事不会冲突呢（比如不会出现先水犇犇再打开洛谷的情况）？ 当然可以，我们可以看出，按照ABCDEFGH这个顺序做事就不会冲突。 说了这么多，究竟什么是拓扑排序呢？相信你也看出来了，拓扑排序就是对一张图进行排序，使得每一条路径的起点永远出现在终点的前面，也就是安排一个顺序，使得做事不会冲突。最后的这个顺序，就被称为是拓扑序列，而得出这个序列的过程被称为拓扑排序。 当然，一张图的拓扑序列可能不止一种，比如在上图中BACEDGFH也是一个拓扑序列。 对于要进行排序的图，它必须是一个DAG（有向无环图），即不会出现要做A，先做B，但要做B，又要先做A的情况。 算法思路 拓扑排序其实很简单，对于一个点，如果它没有父亲（即与其相连的入边的起点）或是其父亲都被排在序列里了，那么这个点就可以放进序列，因为它既然没有先决条件，就是可以做的。 概括一下，不断地去做那些没有先决条件或是先决条件被满足的事情，最后所有事情都会做完这句话不适用于我的作业（满足是DAG的情况下）。 那么怎么判断一个点有无先决条件呢？很简单，我们在建图时就统计好每个点的入度，入度为000就说明没有先决条件，就是可以做的，在排序时，每做完一件事，就删掉这个点，同时其出边相连的点入度减111，如果一个点的先决条件都被满足了，那么它的入度也就为000了。 **注意：**不是真的要在图里把这个结点删去，而是只用将其相邻的点入度减111就行了，这样就和删去这个点效果是一样的了。 拓扑排序主要有两种实现方法，可以分别类比为BFS和DFS（因为真的很像啊！），我个人比较喜欢用BFS，因为要开的数组较少。 BFS 这种方法的思路是：每找到一个入度为000的点,就将其入队，然后拓展与其相连的点，将这些点入度减111，因为当前这个点入度为000，所以我们要完成它，完成了它之后，与它相连的点都少了一个先决条件，所以入度减111（这TM跟BFS有什么区别？）。 这里我们就不用开一个visitvisitvisit数组来记录到没到达过了，因为既然一个点入度都为000了，怎么可能还有路径到达它呢？所以不需要。 由于太简单，我就不手动模拟了，就是和BFS一模一样的。 PS：由于没有拓扑排序的模板题，所以我就自己出了一道。 输入格式： 第111行两个整数nnn和mmm，表示在这张图中共有nnn个点，mmm条边。 第222行到第m+1m+1m+1行，每行两个数uuu和vvv，表示从uuu到vvv有一条边。 输入保证没有环。 输出格式： 输出共一行，为这个图的拓扑序列，每两个数字之间一个空格。 输入数据： 1234567891011128 111 32 31 52 53 44 64 75 65 76 87 8 输出数据： 答案不唯一！ 11 2 3 4 5 6 7 8 不用看了就是上面那张图 参考代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;using namespace std;struct Edge{ int next; int to;};Edge edge[100001];//静态链式前向星存图int n,m,cnt,tot,head[10001],in[10001],ans[10001];//in记录每个点的入度，ans存答案queue&lt;int&gt; q;//我比较喜欢用STL，如果不会的可以百度一下，很简单的，几分钟就会了void add_edge(int u,int v){ cnt++; edge[cnt].next=head[u]; edge[cnt].to=v; head[u]=cnt;}void topo(){ for(int i=1;i&lt;=n;i++) if(!in[i]) q.push(i);//一开始检测哪些点入度为0，从这些点开始干♂。 while(!q.empty())//如果队列不为空 { int u=q.front();//取出队头元素 q.pop();//队头元素出队 ans[++tot]=u;//因为这个点被放进队列，有且只有一种情况，即它的入度为0，这种情况下我们当然是可以来做这件事的 for(int i=head[u];i;i=edge[i].next)//枚举与这个点相连的所有点。 { int v=edge[i].to; in[v]--;//这些点的入度减1 if(!in[v])//如果这个点入度为0了，就可以入队了，没有必要枚举完了再判断哪些点入度为0 q.push(v); } }}int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) { int a,b; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); add_edge(a,b); in[b]++; } topo(); for(int i=1;i&lt;=tot;i++) printf(&quot;%d &quot;,ans[i]); return 0;} 是不是很简单啊？只要会BFS就应该能看懂了。 DFS 这种方法相对来说就要麻烦一些，因为要开一个visitvisitvisit数组，但其实也没麻烦到哪去。 思路：从一个入度为000的点开始遍历，先一直走到底，在回溯的时候，将当前点压入栈中，也就是说，最后的出度为000的点将会最先被压入栈中，也就会最后被输出。同时，我们不再走之前走过的点了，因为这些点已经被压入栈中。 注意！ 要遍历所有点，找到入度为000的点，从这一点开始进行遍历，因为入度为000的点不可能从其他点到达，所以要从每一个初始入度为000的点都遍历一次。 参考代码：（题目如上） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;using namespace std;struct Edge{ int next; int to;};Edge edge[100001];int n,m,cnt,tot,head[10001],in[10001],ans[10001],visit[10001];stack&lt;int&gt; s;//还是STL模板void add_edge(int u,int v){ cnt++; edge[cnt].next=head[u]; edge[cnt].to=v; head[u]=cnt;}void topo(int u){ visit[u]=1;//标记当前点 for(int i=head[u];i;i=edge[i].next)//枚举所有出边 { int v=edge[i].to; if(!visit[v]) topo(v);//继续遍历 } s.push(u);//将这一点压入栈}int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) { int a,b; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); add_edge(a,b); in[b]++; } for(int i=1;i&lt;=n;i++)//一定要从每一个入度为0的点都遍历一次 if(!in[i]) topo(i); while(!s.empty()) { printf(&quot;%d &quot;,s.top()); s.pop(); } return 0;} 很简单是不是啊？ 拓扑排序由于保证了每个点、每条边只会被遍历一次，所以其时间复杂度为O(n+m)O(n+m)O(n+m)，还是很不错了。 在最开始，我们曾提到拓扑排序只能处理没有环的图，但其实，它还可以用来判断是否存在环。 思路很简单，如果一张图中存在环，那么我们是不可能将所有的点都放进答案数组里的，组成环的那些点因为入度怎么都不可能为000（试想一下让你在穿裤子之前必须穿上衣，但在穿上衣之前又必须穿裤子，那么最后你一定什么也穿不了），所以它们不会被放进数组。 简单来说，在BFS完之后，加一条语句判断tottottot是否小于nnn，如果是，那么一定存在环。 就像这样： 12if(tot&lt;n) printf(&quot;有环啊啊啊啊！！！&quot;); 这只是用BFS的思路，DFS的你们可以自己想一下，我就不再说了。 总结 emmm……没有什么好总结的了，都很简单，关键是做题（基础算法和题目可是两回事，蒟蒻亲身体验QAQ） 推荐几道题目吧： 全都是你谷上的哦（没办法窝太菜了只有你谷账号没有CF和AT之类的账号QAQ） P4017 最大食物链计数（拓扑排序+动归，极其简单，看题就切） P1137 旅行计划（简单明了，DFS一遍就过） P1038 神经网络（版子题，简单） P1983 车站分级 （有难度，但主要是在如何建图上，建好了跑一遍拓扑就好了） P1347 排序（也差不多是版子题，迄今为止做过最简单的一道蓝题） 由于我是个菜鸡，所以这些题保证你只要学懂了拓扑排序都是可以做的，只是有些要稍微思考一下。 如果有哪里不对请大佬在评论里指出，蒟蒻感谢之极qwq。","link":"/posts/2563015957.html"},{"title":"【笔记】图论-最短路径算法","text":"在图论中，有一类算法，是专门拿来算两点之间最短距离的，被称之为最短路算法。 一共有四种最短路算法，分别是：Floyd，Dijkstra，Bellman-Ford和SPFA，它们时间复杂度各不相同，同时也具有各自的缺陷，今天就来介绍一下这四种算法。 参考题目：P1744 采购特价商品（四种算法参考代码均为这道题） PS：因为图论刚起步，所以为了熟悉一下，代码都是用的链式前向星存图，其实这四种都有自己的方式，下面会讲到。 Floyed Floyd和其它三种不一样，是一种全源最短路径算法，也就是说，它能求出任意点为起点，任意点为终点的最短距离，而其它三种只能求出以某一点为起点，任意点为终点的最短距离，即单源最短路径。 Floyd算法时间复杂度为O(n3)O(n^{3})O(n3)，核心代码如下： 1234for(int k=1;k&lt;=n;k++) for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]); 其中，k为中间点，i和j为起点和终点。 关于为什么要把k放在最外层，我也是纠结了很久（那肯定啊强迫症看了会很不舒服的嘛），直到看到了这张图片。 这东西把这个算法解释的很清楚了，我就不再说了。 代码： 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#define min(a,b) a&lt;b?a:busing namespace std;struct Point{ int x; int y;};Point a[101];int n,m,s,t,cnt,h[101],b[101];double dis[101][101];int main(){ scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) { scanf(&quot;%d%d&quot;,&amp;a[i].x,&amp;a[i].y); for(int j=1;j&lt;=n;j++) dis[i][j]=10000000;//初始化dis数组为无穷大，这样才能避免算的时候加入不存在的边 //因为是取最小值，所以这么大的数不会被考虑 } scanf(&quot;%d&quot;,&amp;m); for(int i=1;i&lt;=m;i++) { int u,v; scanf(&quot;%d%d&quot;,&amp;u,&amp;v); dis[u][v]=dis[v][u]=sqrt((a[u].x-a[v].x)*(a[u].x-a[v].x)+(a[u].y-a[v].y)*(a[u].y-a[v].y)); } scanf(&quot;%d%d&quot;,&amp;s,&amp;t); for(int k=1;k&lt;=n;k++)//切记：中间点一定要放在最外层，原因上面已经讲过了 for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) dis[i][j]=min(dis[i][j],dis[i][k]+dis[j][k]);//这里如果没有边，则默认为无穷大 //由于是无穷大，所以这里不可能取到不存在的边 printf(&quot;%.2lf&quot;,dis[s][t]); return 0;} 事实上Floyd算法并不用链式前向星，而是邻接矩阵，毕竟它是求任意点为起点和终点的最短路径，所以必须用邻接矩阵。 优点：简单易懂，全源最短路 缺点：很明显啊……时间复杂度太感人了，空间复杂度也很棒棒啊 Dijkstra 正如上面所说，Dijkstra是一种单源最短路径算法，时间复杂度为O(n2)O(n^{2})O(n2)，比较稳定。 Dijkstra的核心思想是不停地找距离起点最近又没有更新过的点，然后对其所有相连的点进行更新。 因为从一个点到另一个点，中间必定经过至少一个中转点（把起点也算上），Dijkstra就是不停地把距离起点最近的点作为中转点，来更新与之相连的点。 Dijkstra默认不可能出现起点到A比起点到B距离长，但从起点经过A再到B距离却比直接到B短的情况，所以无法处理存在负边权的情况。 下面用图片来具体说明一下（标粗的点表示没有更新过）： 第一步： 此时，初始化dis[1]=0dis[1]=0dis[1]=0，dis[2,3,4,5]=∞dis[2,3,4,5]=\\inftydis[2,3,4,5]=∞，全部标记为未更新。 第二步： 此时，因为dis[1]=0dis[1]=0dis[1]=0，距离起点最近，因此更新点1，标记一下。然后，修改与点1相连的所有点，于是，dis[2]=2,dis[3]=4,dis[4]=7dis[2]=2,dis[3]=4,dis[4]=7dis[2]=2,dis[3]=4,dis[4]=7，但这时并不标记这些点，因为它们不一定是最短路径。 数据：dis[1]=0,dis[2]=2,dis[3]=4,dis[4]=7,dis[5]=∞dis[1]=0,dis[2]=2,dis[3]=4,dis[4]=7,dis[5]=\\inftydis[1]=0,dis[2]=2,dis[3]=4,dis[4]=7,dis[5]=∞ 第三步： 第二轮循环后，找到点2距离起点最近且目前未被更新过，更新点2，并循环与点2相连的所有点，即点1，点3，点5，同样，这轮修改不标记，原因如上所述。因为dis[1]=0&lt;dis[2]+2dis[1]=0&lt;dis[2]+2dis[1]=0&lt;dis[2]+2，所以不修改点1。 数据：dis[1]=0,dis[2]=2,dis[3]=3,dis[4]=7,dis[5]=4dis[1]=0,dis[2]=2,dis[3]=3,dis[4]=7,dis[5]=4dis[1]=0,dis[2]=2,dis[3]=3,dis[4]=7,dis[5]=4 第四步： 第三轮循环，找到未被更新过的点中点3距起点最近，因此标记点3，并修改与点3相连的点，即点1，点2，点4，点5，但因为dis[1]=0&lt;dis[3]+4,dis[2]=2&lt;dis[3]+1,dis[5]=4&lt;dis[3]+6dis[1]=0&lt;dis[3]+4,dis[2]=2&lt;dis[3]+1,dis[5]=4&lt;dis[3]+6dis[1]=0&lt;dis[3]+4,dis[2]=2&lt;dis[3]+1,dis[5]=4&lt;dis[3]+6，因此这三个点不管，只有点4被修改（同样不标记） 数据：dis[1]=0,dis[2]=2,dis[3]=3,dis[4]=4,dis[5]=4dis[1]=0,dis[2]=2,dis[3]=3,dis[4]=4,dis[5]=4dis[1]=0,dis[2]=2,dis[3]=3,dis[4]=4,dis[5]=4 最后两轮更新将点4和点5更新，手动模拟一下发现没有点再修改了，循环结束。 综上所述，Dijkstra算法简单来说就是，找距起点最近的点，用它来修改相连的点 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#define min(a,b) a&lt;b?a:busing namespace std;struct Point{ int x; int y;};struct Edge{ int next; int to; double w;};Point a[101];Edge edge[2001];int n,m,s,t,cnt,h[101],b[101];double dis[101];void add_edge(int u,int v){ edge[cnt].next=h[u]; edge[cnt].to=v; edge[cnt].w=sqrt((a[u].x-a[v].x)*(a[u].x-a[v].x)+(a[u].y-a[v].y)*(a[u].y-a[v].y)); h[u]=cnt; cnt++;}int main(){ memset(h,-1,sizeof(h)); scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) { scanf(&quot;%d%d&quot;,&amp;a[i].x,&amp;a[i].y); dis[i]=100000000;//初始化dis数组无穷大 } scanf(&quot;%d&quot;,&amp;m); for(int i=1;i&lt;=m;i++) { int u,v; scanf(&quot;%d%d&quot;,&amp;u,&amp;v); add_edge(u,v); add_edge(v,u); } scanf(&quot;%d%d&quot;,&amp;s,&amp;t); dis[s]=0;//这里只初始化距离，不标记起点，否则就无法用起点去修改与之相邻的点了 for(int i=1;i&lt;=n;i++) { double minn=100000000; int mj=0; for(int j=1;j&lt;=n;j++)//找距离起点最近的未更新的点 if(b[j]==0&amp;&amp;dis[j]&lt;minn) { minn=dis[j]; mj=j; } if(mj==0)//如果没有找到，就说明要么是所有点都更新完成了，要么是没有点和起点相连 break; b[mj]=1;//更新最近的点 for(int j=h[mj];j!=-1;j=edge[j].next)//用这个点去修改相邻的点 dis[edge[j].to]=min(dis[edge[j].to],dis[mj]+edge[j].w);//要判断一下通过这个点到达是否为最短路径 } printf(&quot;%.2lf&quot;,dis[t]); return 0;} Dijkstra算法可以用链式前向星，也可以用邻接矩阵，但个人认为链式前向星会更快一些，因为可以省去判断是否与当前点相连。 应当注意的是，Dijkstra不能处理存在负边权的情况，如下图： 如图，从A到C最短应该是A—&gt;B—&gt;C，长度为-7，但Dijkstra在第一轮循环的时候，就会先更新点C为1，再用点C去修改点B，然后更新点B为-9，所以无法求出最短路径。 优点：时间复杂度稳定，不容易被卡 缺点：无法处理存在负边权的情况 Bellman-Ford Bellman-Ford也是一种单源最短路径，其时间复杂度为O(nm)O(nm)O(nm)，较Dijkstra来说没有那么稳定，容易被卡。 与Dijkstra不同，Bellman-Ford的核心思想是，在一个图中，总有边是连接着修改过的点和未修改过的点的，通过枚举这些边，来不断修改未修改过的点的值。 具体我也不好直接说明，还是用图来手动模拟一下清晰。 PS：加粗的表示值未被修改过。 第一步： 老规矩，初始化所有点的值为无穷大，但点1不用，默认为0。 数据：dis[1]=0,dis[2,3,4,5]=∞dis[1]=0,dis[2,3,4,5]=\\inftydis[1]=0,dis[2,3,4,5]=∞ 第二步： 枚举所有的边，发现dis[1]+2&lt;dis[2],dis[1]+4&lt;dis[3],dis[1]+7&lt;dis[4]dis[1]+2&lt;dis[2],dis[1]+4&lt;dis[3],dis[1]+7&lt;dis[4]dis[1]+2&lt;dis[2],dis[1]+4&lt;dis[3],dis[1]+7&lt;dis[4]，因此修改这些点的值dis[2]=dis[1]+2=2,dis[3]=dis[1]+4=4,dis[4]=dis[1]+7=7dis[2]=dis[1]+2=2,dis[3]=dis[1]+4=4,dis[4]=dis[1]+7=7dis[2]=dis[1]+2=2,dis[3]=dis[1]+4=4,dis[4]=dis[1]+7=7，但在接下来的循环中，又发现dis[2]+1&lt;dis[3]dis[2]+1&lt;dis[3]dis[2]+1&lt;dis[3]，修改dis[3]=dis[2]+1=3dis[3]=dis[2]+1=3dis[3]=dis[2]+1=3，dis[3]+1&lt;dis[4]dis[3]+1&lt;dis[4]dis[3]+1&lt;dis[4]，于是修改dis[4]=dis[3]+1=4dis[4]=dis[3]+1=4dis[4]=dis[3]+1=4。 数据：dis[1]=0,dis[2]=2,dis[3]=3,dis[4]=4,dis[5]=∞dis[1]=0,dis[2]=2,dis[3]=3,dis[4]=4,dis[5]=\\inftydis[1]=0,dis[2]=2,dis[3]=3,dis[4]=4,dis[5]=∞ 第三步： 再次枚举所有的边，发现dis[2]+2&lt;dis[5]dis[2]+2&lt;dis[5]dis[2]+2&lt;dis[5]，于是修改dis[5]=dis[2]+2=4dis[5]=dis[2]+2=4dis[5]=dis[2]+2=4，而后又发现dis[3]+6&gt;dis[5]dis[3]+6&gt;dis[5]dis[3]+6&gt;dis[5]，于是dis[5]dis[5]dis[5]修改完毕，至此，所有的点都修改完了。 关于为什么Bellman-Ford要循环nnn次，其实很简单，虽然上面这个图只用了3次就完成了，但不能排除有链的情况，比如这样： 这时，每次循环所有边就只能改变一个点的值，所以至少要循环5次。 参考代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#define min(a,b) a&lt;b?a:busing namespace std;struct Point{ int x; int y;};struct Edge{ int next; int to; double w;};Point a[101];Edge edge[2001];int n,m,s,t,cnt,h[101];double dis[101];void add_edge(int u,int v){ edge[cnt].next=h[u]; edge[cnt].to=v; edge[cnt].w=sqrt((a[u].x-a[v].x)*(a[u].x-a[v].x)+(a[u].y-a[v].y)*(a[u].y-a[v].y)); h[u]=cnt; cnt++;}int main(){ memset(h,-1,sizeof(h)); scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) { scanf(&quot;%d%d&quot;,&amp;a[i].x,&amp;a[i].y); dis[i]=100000000; } scanf(&quot;%d&quot;,&amp;m); for(int i=1;i&lt;=m;i++) { int u,v; scanf(&quot;%d%d&quot;,&amp;u,&amp;v); add_edge(u,v); add_edge(v,u); } scanf(&quot;%d%d&quot;,&amp;s,&amp;t); dis[s]=0; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++)//链式前向星遍历所有边 //其实也可以用一个f[2*m][2]的数组来存每条边的起点与终点，会更方便 //之所以是2*m，是因为这是无向图，每条边要存两次 for(int k=h[j];k!=-1;k=edge[k].next) dis[edge[k].to]=min(dis[j]+edge[k].w,dis[edge[k].to]);//判断通过当前这条边到达这个点会不会更短 printf(&quot;%.2lf&quot;,dis[t]); return 0;} Bellman-Ford可以不用链式前向星，而直接单纯地存边的起讫点，在时间上区别个人认为不大，但空间的话还是后者要优秀一点。 Bellman-Ford无法处理存在负权回路的情况，即这条回路上所有边的权值加起来为负数的回路（废话这样一直转下去每次减一点值就无穷小了呀），就像这样： 尽管Bellman-Ford无法处理负权回路的情况，但可以判断是否存在负权回路，如果全部循环完了，还存在某条边使得从点A到点B的距离更小，就存在负权回路。 直接在两重循环完了后面加上这样几行代码即可： 1234for(int i=1;i&lt;=n;i++) for(int j=head[i];j!=-1;j=edge[j].next)//链式前向星遍历 if(dis[edge[j].to]&gt;dis[i]+edge[j].w) printf(&quot;啊啊啊有负权回路啊！！！&quot;); 优点：可以处理负边权的情况，可以检测负权回路 缺点：容易被卡！！！ SPFA SPFA是Bellman-Ford的队列优化版本，时间复杂度和Bellman-Ford一样，是O(nm)O(nm)O(nm)（不要信《信息学奥赛一本通》上的鬼话，它说时间复杂度是O(km)，其中k是常数，约为2，根本不对，详见百度） SPFA的思路非常简单，每次从队头取一个点出来，判断从这个点到相邻的点是否更短，如果是，则将这个相邻的点入队，其实就和BFS很像，但不同的是，SPFA中的点可以多次入队，因为第一次找到的最短路径不一定就是真正的最短路径。同时，也正因为可以多次入队，所以它无法像普通的BFS一样估算队列的长度，所以在实现时，要么采用循环队列（即把队列当成一个圆环，当队尾到达一定位置时，就把尾指针移到队头，相当于从头再开始存，一般是用一个取模来完成，这样比较方便），这时队列只需开到2∗n+52*n+52∗n+5即可（《信息学奥赛一本通》原话，具体证明我也不会，如果哪位大佬知道的话麻烦在评论里指出，蟹蟹！），要么还可以用STL库中的queue容器，这里我用的是queue，但也要学会手打队列，不能养成STL依赖症。 参考代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#define min(a,b) a&lt;b?a:busing namespace std;struct Point{ int x; int y;};struct Edge{ int next; int to; double w;};Point a[101];Edge edge[2001];int n,m,s,t,cnt,head[101];double dis[101];queue&lt;int&gt; q;void add_edge(int u,int v){ edge[cnt].next=head[u]; edge[cnt].to=v; edge[cnt].w=sqrt((a[u].x-a[v].x)*(a[u].x-a[v].x)+(a[u].y-a[v].y)*(a[u].y-a[v].y)); head[u]=cnt; cnt++;}int main(){ scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) { scanf(&quot;%d%d&quot;,&amp;a[i].x,&amp;a[i].y); dis[i]=10000000; head[i]=-1; } scanf(&quot;%d&quot;,&amp;m); for(int i=1;i&lt;=m;i++) { int u,v; scanf(&quot;%d%d&quot;,&amp;u,&amp;v); add_edge(u,v); add_edge(v,u); } scanf(&quot;%d%d&quot;,&amp;s,&amp;t); q.push(s);//一开始起点入队 dis[s]=0; while(!q.empty()) { for(int i=head[q.front()];i!=-1;i=edge[i].next) if(dis[q.front()]+edge[i].w&lt;dis[edge[i].to])//判断相邻的点通过当前点到达是否更短 { dis[edge[i].to]=dis[q.front()]+edge[i].w; q.push(edge[i].to);//如果是，则当前点的值修改，并入队 } q.pop(); } printf(&quot;%.2lf&quot;,dis[t]); return 0;} 整个过程其实和BFS几乎完全一样，这里我介绍一下queue容器的使用。 使用queue容器要包含#include&lt;queue&gt;这个头文件。 queue的定义格式是queue&lt;元素类型&gt;队列名称，如：queue&lt;int&gt;qwq就是定义了一个名字为qwq，元素类型为int的队列 queue一共有6个常用函数： qwq.push(x)：将x元素入队 qwq.pop()：将队头元素出队 qwq.front()：返回队头元素的值（但不出队） qwq.back()：返回队尾元素的值（个人觉得用处不大） qwq.empty()：判断队列是否为空，如果为空，则返回true qwq.size()：返回队列中元素个数 差不多就是这些了，如果还有什么，我后面再补充。 特别注意：SPFA容易被卡！ 在此放上一张经久不衰的图片： 2018 年 7 月 19 日，某位同学在NOI Day 1 T1里非常熟练地使用了一个广为人知的算法SPFA求最短路。 然后呢？ 100→60100 \\rightarrow 60100→60； Ag→CuAg \\rightarrow CuAg→Cu； 最终，他因此没能与理想的大学达成契约。 由于SPFA“优秀”的时间复杂度，所以它经常在各大OJ和OI上被卡，再引用一个人的话。 卡SPFA已经是一个共识了好吧…… 所以在比赛时，最好还是不要用SPFA了…… 优点：比较简单易懂，而且可以处理负边权的情况 缺点：容易被卡 总结 四种最短路径算法个人觉得还是根据具体的题目来看吧，但一般来说我觉得应该是没有负边权就用Dijkstra（实在不行加个堆优化），有负边权就用SPFA好了，也没有必要一味地说SPFA死了，毕竟既然这玩意还没有完全被淘汰不用，就说明它还是有自己的用途的。","link":"/posts/1960909489.html"},{"title":"【笔记】图论-树链剖分","text":"树链剖分，听起来确实是一种很高级的算法，但其实它并没有想象中的那么难以理解，事实上，个人觉得，树剖其实根本没有什么太大的思维难度（老实说我觉得怕不是背包都比它要难理解），只是码量大亿点，但只要熟练掌握了，打代码其实也并没有那么难 所谓树链剖分，是用来解决一类树上问题的，它将一棵树剖成很多条链，把树上问题转化成序列问题，然后用其它一些数据结构，比如线段树来维护树上路径的信息 举个例子，比如给定一棵树，每个点有自己的权值，要求查询某两点之间的路径上的所有点的点权和，看起来很简单是不是？用倍增在跳的时候顺便统计就行了，那么如果再要求支持改变某个点的点权呢，或是给某两点之间的路径上的所有点的点权全部加上一个数呢？倍增很明显就不行了吧，这时候就要用到树剖了 思路 树链剖分一般指的是重链剖分，在讲解它的思路之前，我们先要明确几个概念 重儿子：一个点的所有儿子中子树节点数量最多的儿子，如果有多个，那就随便选一个 轻儿子：一个点所有儿子中除重儿子以外的其他儿子，也就是说，对于一个点，重儿子是唯一的，但轻儿子不唯一 重边：一个点到它的重儿子之间的边 轻边：一个点到它的轻儿子之间的边 重链：一大堆重边组成的一条链 这么说起来可能有点抽象，还是拿张图最容易理解 在这张图中，蓝色节点表示轻儿子，橙色节点表示重儿子，相应的，蓝色边表示轻边，橙色边表示重边，由绿框框起来的就是重链，特别的，单独一个点也可以叫做重链 这个过程完了之后，整棵树就会被完全剖分成一条一条的重链 接下来是重点 对于这一条一条的重链，很明显我们还是不能直接用线段树去维护，因为每条链中的节点编号并不是连续的，所以，我们还要引入一个东西——DFS序 这个东西就是树剖把树上问题转化成序列问题的关键，所谓DFS序呢，就是在对这棵树进行DFS的时候，标记每个点是第几个到达的，其实也就是强连通分量Tarjan算法里的dfn数组，但树剖不太一样，因为我们需要让一条重链上所有点的DFS序连续，这样才好让这条链变成一个区间，所以，我们在对这棵树进行DFS的时候，优先遍历重儿子，这样就可以保证一条重链上的点的DFS序连续，因为是先把这条重链一拉到底之后再遍历其他的重链 对于上面那棵树，它的DFS序如下（拿蓝框框起来的就是） 我们可以用每个节点的DFS序建一棵线段树，这样，一条重链就是一个连续的区间了，也便于维护 代码实现 首先我们先来看一些变量 dep[]：记录每个点的深度 son[]：记录每个点的重儿子 size[]：记录以当前点为根的子树的节点个数 id[]：记录每个点的DFS序 rk[]：记录每个DFS序对应的点 top[]：记录当前点所在重链的顶部（下称链头），也就是深度最浅的点 其实树链剖分一共只需要两次DFS就可以解决了，第一次求出每个点的深度和重儿子（dep[]，son[]，size[]），第二次记录每个点的DFS序，相当于是连重边（id[]，rk[]，top[]），代码很短，也很好理解 12345678910111213141516171819202122232425void dfs1(int u,int father)//第一次DFS{ dep[u]=dep[father]+1; fa[u]=father; size[u]=1;//这个是把u点自己给算进去 for(int i=0;i&lt;edge[u].size();i++)//这里是用的vector存图 if(edge[u][i]!=father) { dfs1(edge[u][i],u);//先遍历子树 size[u]+=size[edge[u][i]];//累加当前点的子树的节点数 son[u]=size[edge[u][i]]&gt;size[son[u]]? edge[u][i]:son[u];//找重儿子，如果当前儿子的子树比重儿子的子树节点数量更多的话就换过去 }}void dfs2(int u,int father,int t)//第二次DFS，t是当前点所在重链的顶部{ cnt++;//DFS序 top[u]=t; rk[cnt]=u;//当前DFS序对应的节点编号 id[u]=cnt;//当前节点对应的DFS序 if(son[u]) dfs2(son[u],u,t);//一定要优先遍历重儿子啊！！！ for(int i=0;i&lt;edge[u].size();i++) if(edge[u][i]!=son[u]&amp;&amp;edge[u][i]!=father) dfs2(edge[u][i],u,edge[u][i]);} 在第二个DFS中，之所以下面遍历轻儿子的时候把轻儿子所在的重链顶部设成是轻儿子，是因为当前节点和轻儿子并不在一条重链里，自然也就无法充当它所在的重链的顶部 代码是真的很短了，但这其实只是树剖本身的实现，不要忘了，它是用来解决一类问题的，剖的过程确实很简单，但要维护却比较恼火，上面提到过，可以用线段树来维护重链上的信息，这玩意本来码量就很大，再加上有时候还会结合LCA，就更令人难受了 接下来，我会讲一下如何用树剖求LCA，当然，一般来说用树剖求LCA，就一定会有路径查询和路径修改，我会顺带着把这两个也讲一下的 树剖+LCA 如果是做过树剖的题的人，应该知道在这种题中一般会有这种要求，即求这棵树上从uuu到vvv的最短路径上所有点权之和，以及将这棵树上从uuu到vvv的最短路径上所有点的点权加上一个数，而这个最短路径，很明显就是要求LCA 树剖求LCA，思路其实和倍增差不多，都是往上跳，直到跳到同一个点结束，但树剖与倍增又有一点不同，倍增是往上跳2k2^k2k个祖先，而树剖则是直接跳到链头的父亲，因为如果uuu和vvv在同一条重链上，那么可以肯定他们中有一个是对方的祖先，比较一下深度就行了，如果不在同一条重链上，那么我们就先让他们跳到同一条重链上，再按照前面的方法执行 首先，我们比较uuu和vvv链头的深度，避免跳过头，接下来，我们把链头深度较深的那一个（假设是uuu）跳到他链头的父亲，因为如果只跳到链头，那么很明显这个点所在的重链并没有变，只有跳到链头的父亲才是到了另外一条重链，如此循环，直到uuu和vvv的链头是同一个点，也就是它们处于同一条重链上，这时深度浅的那一个就是LCA(u,v)\\text{LCA}(u,v)LCA(u,v) 老规矩，用上面那张图手动模拟一下 假设我们求14和16号点的LCA，过程如下： 首先比较各自链头的深度，很明显是16号点的链头深度更深，因此把16号点跳到链头的父亲11号点 再次比较14号点和11号点的链头深度，这次是14号点，跳到链头的父亲，为7号点 发现7号点和11号点的链头相同，也就是它们处于同一条重链，退出循环 因为7号点深度比11号点的深度更浅，所以LCA(14,16)=7\\text{LCA}(14,16)=7LCA(14,16)=7 当然，一般来说如果只是单纯求LCA还用不到树剖上场，如果必须要用树剖，那就肯定是加了路径修改和路径查询，这两个也是导致树剖码量大的一个很重要的原因。。。 其实只要掌握了树剖求LCA的方法，修改和查询也不是什么难事，上面说过，我们是用节点的DFS序建的线段树，因此每条重链都是一个连续的区间，而重链上的每个点到链头很明显也是连续的，结合刚刚求LCA的跳法，我们只需要在uuu（或vvv）跳到链头的父亲之前先修改（或查询）uuu到链头的点，并在最后出于同一重链上时把uuu到vvv之间的点进行修改（或查询）就行了，具体的可以看一下代码 1234567891011121314151617181920212223242526272829303132333435363738int lca_query(int u,int v)//查询{ int ans=0; while(top[u]!=top[v])//比较链头是否相同 if(dep[top[u]]&gt;=dep[top[v]]) { ans=ans+query(1,id[top[u]],id[u]);//query是线段树的区间查询函数，和普通写法是一样的 u=fa[top[u]];//让这个点跳到链头的父亲 } else { ans=ans+query(1,id[top[v]],id[v]); v=fa[top[v]]; } if(dep[u]&gt;=dep[v]) ans=ans+query(1,id[v],id[u]);//u和v处于同一重链上时单独处理 else ans=ans+query(1,id[u],id[v]); return ans;}void lca_update(int u,int v,int k)//和上面是一样的{ while(top[u]!=top[v]) if(dep[top[u]]&gt;=dep[top[v]]) { update(1,id[top[u]],id[u],k);//update是线段树的区间修改函数，和普通写法也是一样的 u=fa[top[u]]; } else { update(1,id[top[v]],id[v],k); v=fa[top[v]]; } if(dep[u]&gt;=dep[v]) update(1,id[v],id[u],k); else update(1,id[u],id[v],k);} （感觉其实不算很难啊） 一般来说，树剖的题基本上就是路径修改，路径查询，单点修改，单点查询，修改子树，查询子树这几种，后面四种都可以直接用线段树来完成，因为一个点的子树的DFS序也是一个完整的区间，比如上图中7的子树的DFS序就是从3到8，由于之前记录了每棵子树的节点数量，所以这里只需要修改从id[i]到id[i]+size[i]-1这个区间就行了 另外，树剖求LCA的时间复杂度是O(log⁡n)O(\\log n)O(logn)，且常数较小，不容易被卡掉，预处理也是O(n)O(n)O(n)级别的，所以还算比较优秀了 参考代码 题目：P3384 【模板】轻重链剖分 这道题要求支持路径修改，路径查询，子树修改，子树查询四种操作，上面都已经讲过了，就直接贴代码了 感受树剖的码量吧！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169#include&lt;bits/stdc++.h&gt;#define MAXN 100005using namespace std;struct node{ int l; int r; int data; int f;};node tree[MAXN&lt;&lt;2];vector&lt;int&gt; edge[MAXN];int n,m,r,p,cnt,w[MAXN];int dep[MAXN],fa[MAXN],son[MAXN],size[MAXN],top[MAXN],rk[MAXN],id[MAXN];void dfs1(int u,int father)//第一次DFS{ dep[u]=dep[father]+1; fa[u]=father; size[u]=1; for(int i=0;i&lt;edge[u].size();i++) if(edge[u][i]!=father) { dfs1(edge[u][i],u); size[u]+=size[edge[u][i]]; son[u]=size[edge[u][i]]&gt;size[son[u]]? edge[u][i]:son[u]; }}void dfs2(int u,int father,int t)//第二次DFS{ cnt++; top[u]=t; rk[cnt]=u; id[u]=cnt; if(son[u]) dfs2(son[u],u,t); for(int i=0;i&lt;edge[u].size();i++) if(edge[u][i]!=son[u]&amp;&amp;edge[u][i]!=father) dfs2(edge[u][i],u,edge[u][i]);}void push_down(int i)//懒标记下传{ int l=i&lt;&lt;1,r=i&lt;&lt;1|1; if(!tree[i].f) return; tree[l].data=(tree[l].data+tree[i].f*(tree[l].r-tree[l].l+1)%p)%p; tree[r].data=(tree[r].data+tree[i].f*(tree[r].r-tree[r].l+1)%p)%p; tree[l].f=(tree[l].f+tree[i].f)%p; tree[r].f=(tree[r].f+tree[i].f)%p; tree[i].f=0;}void build(int i,int l,int r)//建线段树{ tree[i].l=l; tree[i].r=r; if(l==r) { tree[i].data=w[rk[l]]%p; return; } build(i&lt;&lt;1,l,(l+r)&gt;&gt;1); build(i&lt;&lt;1|1,((l+r)&gt;&gt;1)+1,r); tree[i].data=(tree[i&lt;&lt;1].data+tree[i&lt;&lt;1|1].data)%p;}void update(int i,int l,int r,int k)//线段树区间修改{ if(tree[i].l&gt;=l&amp;&amp;tree[i].r&lt;=r) { tree[i].data=(tree[i].data+(tree[i].r-tree[i].l+1)*k%p)%p; tree[i].f=(tree[i].f+k)%p; return; } push_down(i); if(tree[i&lt;&lt;1].r&gt;=l) update(i&lt;&lt;1,l,r,k); if(tree[i&lt;&lt;1|1].l&lt;=r) update(i&lt;&lt;1|1,l,r,k); tree[i].data=(tree[i&lt;&lt;1].data+tree[i&lt;&lt;1|1].data)%p;}int query(int i,int l,int r)//线段树区间查询{ int ans=0; if(tree[i].l&gt;=l&amp;&amp;tree[i].r&lt;=r) return tree[i].data%p; push_down(i); if(tree[i&lt;&lt;1].r&gt;=l) ans=(ans+query(i&lt;&lt;1,l,r))%p; if(tree[i&lt;&lt;1|1].l&lt;=r) ans=(ans+query(i&lt;&lt;1|1,l,r))%p; return ans%p;}int lca_query(int u,int v)//路径查询{ int ans=0; while(top[u]!=top[v]) if(dep[top[u]]&gt;=dep[top[v]]) { ans=(ans+query(1,id[top[u]],id[u]))%p; u=fa[top[u]]; } else { ans=(ans+query(1,id[top[v]],id[v]))%p; v=fa[top[v]]; } if(dep[u]&gt;=dep[v]) ans=(ans+query(1,id[v],id[u]))%p; else ans=(ans+query(1,id[u],id[v]))%p; return ans;}void lca_update(int u,int v,int k)//路径修改{ while(top[u]!=top[v]) if(dep[top[u]]&gt;=dep[top[v]]) { update(1,id[top[u]],id[u],k); u=fa[top[u]]; } else { update(1,id[top[v]],id[v],k); v=fa[top[v]]; } if(dep[u]&gt;=dep[v]) update(1,id[v],id[u],k); else update(1,id[u],id[v],k);}int main(){ scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;m,&amp;r,&amp;p); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;w[i]); for(int i=1;i&lt;=n-1;i++) { int u,v; scanf(&quot;%d%d&quot;,&amp;u,&amp;v); edge[u].push_back(v); edge[v].push_back(u); } dfs1(r,0); dfs2(r,0,r); build(1,1,n); for(int i=1;i&lt;=m;i++) { int op,x,y,z; scanf(&quot;%d&quot;,&amp;op); switch(op) { case 1: scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z); lca_update(x,y,z); break; case 2: scanf(&quot;%d%d&quot;,&amp;x,&amp;y); printf(&quot;%d\\n&quot;,lca_query(x,y)); break; case 3: scanf(&quot;%d%d&quot;,&amp;x,&amp;z); update(1,id[x],id[x]+size[x]-1,z); break; case 4: scanf(&quot;%d&quot;,&amp;x); printf(&quot;%d\\n&quot;,query(1,id[x],id[x]+size[x]-1)); break; } } return 0;} 其实不算很难懂啦，关键就是码量太大了。。。 相关题目 P3038 [USACO11DEC]Grass Planting G（树剖维护边权，其实可以把边权转化成点权） P4092 [HEOI2016/TJOI2016]树（跟上面说的不太一样，但可以用树剖解决） P4315 月下“毛景树”（差点把我心态搞崩，码量不是一般的大） P2146 [NOI2015]软件包管理器（树剖经典题） P2486 [SDOI2011]染色（有些思维难度，加油！） P3178 [HAOI2015]树上操作（板子题） 其实真正开始做树剖的题就会发现，其实很多代码是通用的，完全可以把上一道题的代码复制过来稍微改一下就行了，但我个人不推荐这样做，毕竟要想熟练掌握代码，最好的方法就是多打几遍嘛，而且这样还可以练手速，做题做多了之后就可以越打越快（我有一次曾经一天内做了8道树剖题，手都快打废了）","link":"/posts/499196864.html"},{"title":"回顾2019","text":"唉，又过去一年了，离初三毕业又近了一点了 这一年过的好悲惨啊 文化课凉凉~~，OI也没什么太大的进展，怎么说呢，很不如意吧 PS：这是蒟蒻第一次写年终总结，所以可能有点水，请不要介意 OI方面 总体来说今年在OI这块还算不错吧，参加了人生中第一次CSP，就拿了一个不错 的成绩，J组一等，虽然这还很微不足道，但也是算一个小小的成就吧（毕竟这样就能稳保直升了），而且通过这次比赛，也是拓宽了眼界，见到了很多巨佬，同时也学到了很多。 给一些还未参加过OI的同学一些建议（纯属个人主观意见）： 首先，在考试前，不要太紧张，J组没什么难的，只要有一些基础，会模拟、简单dp，最好是再来一点图论知识，只要不出大问题，一般一等是稳的 其次，不要觉得骗分是多么不好的行为，只要不是作弊（或卡评测姬）， 没人规定不准骗分，甚至有时骗的比正解还好（比如我今年T4用邻接矩阵加记忆化dfs拿了80pts） 还有，不要过早地给自己下定义，比如觉得自己铁定凉凉什么的，一切要等尘埃落定后才知道，我今年做T4时，贪心把邻接矩阵开大了一些，结果考完了又记错了，以为自己MLE了（这样就只有100+100+10+0=210pts了，在SC正好拿不到一等），难过了好久，结果发现只是记错了，最后总分是290pts，稳上分数线 最后，不要就此结束，J组只是一个很小很小的成就，甚至很多学校都不屑去参加，如果你是真正把OI当成一个兴趣爱好或一种以后的谋生手段来搞，那这是远远不够的，至少都要拿个S组一等才行吧。 （以上内容请dalao勿喷） 除了参加CSP，今年我也想了很多 我现在学OI是为了什么？升学？声誉？谋生？我觉得都不是，仿佛就是一瞬间，我就选中了OI，决定把它当成一生为之奋斗的东西，有时就是这么神奇，有人苦苦寻觅一生的东西，你却一下子就找到了，有人直到老了，都不知道自己这一生是在干嘛，而我却很幸运，在最好的年华就找到了自己的路，或许，这就是一种缘分吧。 我该怎么去学好OI这门竞赛？OI之路说长不长，说短不短，五年时间，也能干很多事了，但如果没有目标，没有计划，就会像dfs没了vis标记，永远停留在函数中直到崩溃，但我现在就属于没有什么触手可及的或是量化的目标来完成，每天都只是跟着老师上课，再在洛谷上刷刷题，红题、橙题、黄题都做了不少，但却没有一点实质性的用处，我希望自学，但却缺乏途径，有了书，又没有时间来练（其实是因为自己时间规划得太差了），这些我现在都没有想清，准备留到寒假再想好了。 我的终极目标是什么？我的班主任曾说过他很羡慕我有自己的目标，人生规划和计划，但其实细想一下，我根本还没有想清。我想去上姚班，但姚班一年只在全国招不到50个人，还要算上数学和物理竞赛的巨佬，这太难太难了，能靠OI获得清华自招的名额都难，更别提姚班了。撇开上大学不说，工作呢？和程序设计有关的工作数不胜数，从低级码农，到顶级科研，我喜欢的到底是OI的什么？是AC的瞬间？还是一行行代码在IDE中被打出，实现？或许我现在还太年轻，没有这个脑子想清这些问题。 总的来说，这一年在OI上过的还是挺好的，在机房也结识了很多朋友，毕竟我是个实验班的蒟蒻，又不善于跟人打交道，所以直到今年暑假才开始有点存在感，但有些地方还是跟竞赛班的大佬很不一样，也没有什么共同的语言，对彼此班上的梗都不了解，说了也是白说。 文化课方面 今年文化课是铁定砸掉了，尤其是历史（政治不清楚，估计也差不多），由于CSP前一两周在机房积极备考，所以逃掉了不少课，再加上开学一个月后历史书又被人不声不响地拿走，我就没好好听过几堂历史课，所以历史肯定是没希望了，只要不在80分以下就行了（80分以下要抄书……）。 最近这几周一直学习不在状态，老是想颓，周末做完作业就了事，学校里也总是心不在焉，废话多，静不下心。语文、英语模拟考都GG了，最拿手的数学最近也不是很理想，现在感觉很痛苦，想要挣扎出这个泥潭，却又来不及了，只能眼睁睁地看着QMKS一点一点逼近，却又无能为力，幻想着奇迹发生，但理智又告诉我不可能，没有办法，只能硬着头皮去考了。 但总体来说，今年一整年的文化课搞得还是有声有色，拿了一次年级第七名，一次年级第八名，如果半期以后能再好一点，就比较完美了。 总结一下，2020年在文化课方面主要注意以下几点： 上课一定要认真听讲，虽然这很像套话，但事实证明，上课的确很重要 课后要注意复习，周末时应把平时讲的内容拿出来看一看，至少是把历史看一遍（理工男表示文科真的让我很抓狂） 周末要注意对手机和电脑的把控，适当颓废有益健康，过度玩乐摧残文化，这个还是不能不管的 注意刷题，周末和平时都要有计划地水做一些数学和物理，这个到了寒假再具体计划 最后再回顾一下，如果要用一个词语概括我的2019年的话，我觉得应该是遗憾吧，没能把好成绩一直延续到最后 希望2020年，我能让自己重新振作起来，不要重蹈2019的覆辙了 新年，加油！ Ps：一些新年小计划： 文化课拿一次年级前五 语文得一次130分 数学拿一次150 学好物理力学，不要挂科 在机房AK一次 绿名，绿名，绿名！！！ AC500道 Fighting！！！","link":"/posts/1276451225.html"},{"title":"【笔记】图论-Tarjan算法","text":"Tarjan是一种求强连通分量、双连通分量的常用算法，其拓展例如求缩点、割点、割桥以及2-SAT等都是非常实用的。 这篇文章主要讲一下Tarjan的朴素算法及其在缩点、求割点等方面的应用（主要是因为其他的都不会了QAQ） 什么是强连通分量？ 在有向图G中，如果两个顶点vi,vj间（vi&gt;vj）有一条从vi到vj的有向路径，同时还有一条从vj到vi的有向路径，则称两个顶点强连通。如果有向图G的每两个顶点都强连通，称G是一个强连通图。有向图的极大强连通子图，称为强连通分量。——来自某度的解释 什么意思呢？ 就是说在一个有向图中，有一个或几个子图，从它们中的任何一个点都可以到另外的任意一个点，这个子图就被称为是强连通分量（一个点也可以被称作是强连通分量哦） 另外，这张子图一定要是最大的，即要把所有满足条件的点全部加进这张子图，才能称为是强连通分量。 举个例子： 在这张图中，1,2,3,41,2,3,41,2,3,4和555还有666是三个强连通分量，但1,3,41,3,41,3,4并不能被称为是强连通分量，因为它不是最大的满足条件的子图，必须要加入点2才算。 简单介绍Tarjan算法 Tarjan算法是一种基于DFS（深度优先搜索）的求图的强连通分量的算法，非常常用（还有就是活在《信奥一本通》上的Kosaraju和活在百度百科中的Gabow算法），同时，其时间复杂度为O(n)O(n)O(n)，算是非常优秀的了。 一些变量 tot：当前点是第几个被遍历的。 dfn[]：记录每个点是第几个被遍历的，可以理解为一个时间戳。 low[]：记录每个点不经过祖先节点能到达最早的祖先的时间戳（下称”返祖“好名字）。 PS:这里大部分人写的都是能到达的最早的祖先，但这样就和下面有一个公式不符，所以我改了一下，如果不对希望大佬在评论里指出，谢谢！ stack[]：一个栈，存放强连通分量（不是直接存哦，有一些方法的）。 vis[]：标记每个点是否在栈中。 color[]：记录每个点属于第几个强连通分量。 p[]：记录每个强连通分量有几个点。（最后这两个都是缩点时用的） 算法思路 从一个点出发，遍历整张图。 dfn[]数组初始化为当前点（下称u）被遍历的顺序，同时将u入栈。 初始化low[u]=dfn[u]，因为一个点一定能到达它自己。 枚举所有出边（链式前向星存图），如果这条边到达的点（下称v）还没有被遍历过，则遍历点v，然后更新low[u]，公式为： low[u]=min⁡(low[u],low[v])low[u]= \\min (low[u],low[v]) low[u]=min(low[u],low[v]) 因为点v能到达的祖先节点，点u也一定能到达（废话），所以应该更新点u的low值。 如果v已被遍历过，且v在栈中，也要更新low值公式为： low[u]=min⁡(low[u],dfn[v])low[u]= \\min (low[u],dfn[v]) low[u]=min(low[u],dfn[v]) 因为到达之前到过的点（也就是祖先），说明这个点可以返祖，那么肯定是要更新low值的（更详细的请看下面的“一些可能的问题”） 枚举完所有出边后，如果dfn[u]=low[u]dfn[u]=low[u]dfn[u]=low[u]则说明这个点是一个强连通分量的开始点（梦开始的地方）它不可能属于其他任何一个强连通分量，因为它无法返祖，所以不可能和之前的点组成一个强连通分量，因而它属于一个独立的强连通分量，这时，将栈中在这个点之后入栈的点全部出栈（包括这个点），因为这些点也不属于其他任何一个强连通分量，如果属于，那么u就不可能无法返祖，所以，它们都是同一个强连通分量。 看起来很麻烦是不是？我也觉得下面用图来手模一下就清楚了。 上图： 资源缺乏，凑合着看吧 我们从点1开始遍历，下面是模拟过程： 从点1开始！u=1,dfn[1]=1,low[1]=1,stack={1},vis[1]=1u=1,dfn[1]=1,low[1]=1,stack=\\{1\\},vis[1]=1u=1,dfn[1]=1,low[1]=1,stack={1},vis[1]=1，先遍历点3。 u=3,dfn[3]=2,low[3]=2,stack={1,3},vis[3]=1u=3,dfn[3]=2,low[3]=2,stack=\\{1,3\\},vis[3]=1u=3,dfn[3]=2,low[3]=2,stack={1,3},vis[3]=1，再遍历点5。 u=5,dfn[5]=3,low[5]=3,stack={1,3,5},vis[5]=1u=5,dfn[5]=3,low[5]=3,stack=\\{1,3,5\\},vis[5]=1u=5,dfn[5]=3,low[5]=3,stack={1,3,5},vis[5]=1，遍历点6。 u=6,dfn[6]=4,low[6]=4,stack={1,3,5,6},vis[6]=1u=6,dfn[6]=4,low[6]=4,stack=\\{1,3,5,6\\},vis[6]=1u=6,dfn[6]=4,low[6]=4,stack={1,3,5,6},vis[6]=1，此时没有出边了，开始硬核出栈。 检测到dfn[6]=low[6]dfn[6]=low[6]dfn[6]=low[6]，将栈中点6及其之后的点全部出栈（其实只有一个点），stack={1,3,5},vis[6]=0stack=\\{1,3,5\\},vis[6]=0stack={1,3,5},vis[6]=0，666为一个强连通分量。 回溯到点5，没有出边了，出栈。stack={1,3},vis[5]=0stack=\\{1,3\\},vis[5]=0stack={1,3},vis[5]=0，555为一个强连通分量。 回溯到点3，遍历点4。 u=4,dfn[4]=5,low[4]=5,stack={1,3,4}vis[4]=1u=4,dfn[4]=5,low[4]=5,stack=\\{1,3,4\\}vis[4]=1u=4,dfn[4]=5,low[4]=5,stack={1,3,4}vis[4]=1，接下来遍历点1，发现已经遍历过了，说明点4返祖了（！！！），此时更新low[4]=dfn[1]=1low[4]=dfn[1]=1low[4]=dfn[1]=1。再遍历点6，发现点6已经遍历过了，但又不在栈中，说明点6不属于点4所在的强连通分量，所以不管。此时所有出边枚举完了，回溯到点3。 更新low[3]=min⁡(low[3],low[4])=1low[3]=\\min(low[3],low[4])=1low[3]=min(low[3],low[4])=1（意思是点3能到达点1），没有出边了，回溯到点1。 遍历点2，u=2,dis[2]=6,low[2]=6,stack={1,3,4,2},vis[2]=1u=2,dis[2]=6,low[2]=6,stack=\\{1,3,4,2\\},vis[2]=1u=2,dis[2]=6,low[2]=6,stack={1,3,4,2},vis[2]=1，枚举出边，只有一个点4已经被遍历了，且点4在栈里，low[2]=min⁡(low[2],dfn[4])=5low[2]=\\min(low[2],dfn[4])=5low[2]=min(low[2],dfn[4])=5，枚举完毕，回溯。 点1出边枚举完毕，开始出栈，stack清空，vis清空，1,3,4,21,3,4,21,3,4,2为一个强连通分量。自此，遍历完毕，三个强连通分量全部被求出（完结撒花，感谢陪伴）。 一些可能的问题 Q： 如果这张有向图不连通怎么办？也就是说，如果从一个点出发不能遍历完整张图怎么办？ A： 废话，那就从点1枚举到点n，如果当前点没有被遍历过，就从这一点开始遍历。 Q： 如何判断当前点有没有被遍历过？ A： dfn数组是干嘛的？记录每个点被遍历的顺序啊！如果dfn数组不为0，则表示它已经被更新，也被遍历过了。 Q： 还是没有搞懂为什么遍历完一个点后要把low更新为当前点和这条边的终点的low值中的较小值啊。 A： low数组记录的是能到达的最早的祖先，既然这条边的终点能到达，那起点肯定也能到达啊，同时要取最早的祖先，所以要取较小的值。 Q： 既然许多大佬都说low[]是记录能到的最早的祖先，那为什么出现”返祖“情况时不取祖先的能到达的最早时间戳，而要取祖先的时间戳呢？换句话说，为什么遍历到被遍历过的又在栈里的点（就是祖先嘛）时不用公式low[u]=min⁡(low[u],low[v])low[u]= \\min (low[u],low[v])low[u]=min(low[u],low[v])，而要用公式low[u]=min⁡(low[u],dfn[v])low[u]= \\min(low[u],dfn[v])low[u]=min(low[u],dfn[v])呢？ A： 这个问题其实有点复杂，理论上来说用前者是绝对没有问题的（仅限于求强连通分量的时候），但后面在求割点时，第一个公式就会出bug，所以我将low[]数组定义为不经过祖先节点能到达的最早祖先，详细情况请看后面讲求割点的部分。 （大概就是这些了，如果还有什么问题后面再补充） 参考代码 题目： 洛谷 P2863 [USACO06JAN]牛的舞会The Cow Prom 传送门 （PS：我没有用P2341 【模板】强连通分量 / [HAOI2006]受欢迎的牛，是因为这道题虽然写的是强连通分量的模板，但其实还用到了缩点的知识，不便于朴素算法的理解） 题目大意： 求子图内点的个数大于1的强连通分量个数。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;cstdio&gt;#include&lt;cstring&gt;#define min(a,b) a&lt;b?a:busing namespace std;struct Edge//链式前向星存图{ int next; int to;};Edge edge[50001];int n,m,s,head[10001];int cnt,k,ans,dfn[10001],low[10001],stack[10001],v[10001];//我这里的代码时间和这篇笔记的时间隔了将近5天 //所以有些变量名可能不太一样 //这里v数组就是上面的vis //cnt是上面的totvoid tarjan(int x){ cnt++; dfn[x]=low[x]=cnt; stack[++k]=x; v[x]=1;//初始化各种数组，包括dfn和low初始化为x被遍历到的次序，x入栈，v标记x入栈 for(int i=head[x];i!=-1;i=edge[i].next) if(!dfn[edge[i].to])//如果没有搜过 { tarjan(edge[i].to); low[x]=min(low[x],low[edge[i].to]);//取自己能到的最早祖先和终点能到的最早祖先 } else if(v[edge[i].to])//如果搜过了，且这个点在栈里，说明返祖了 low[x]=min(low[x],dfn[edge[i].to]);//详情见上面 if(dfn[x]==low[x])//如果dfn[x]=low[x]，说明这个点为整个强连通分量中的最老的祖先，也说明整个强连通分量已经遍历完了 { int flag=0; while(stack[k]!=x) { flag=1; v[stack[k]]=0; k--; } v[x]=0; k--; if(flag)//这里是判断这个强连通分量点的个数是否大于1（题目要求） ans++; }}void add_edge(int u,int v){ edge[s].next=head[u]; edge[s].to=v; head[u]=s; s++;}int main(){ memset(head,-1,sizeof(head)); scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) { int a,b; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); add_edge(a,b); } for(int i=1;i&lt;=n;i++) if(!dfn[i]) tarjan(i);//不确定从一个点开始就能遍历完整张图，所以要每个点都试一下 printf(&quot;%d&quot;,ans); return 0;} Tarjan+缩点 What means 缩点？ 一张有向图中，如果存在环，就会造成很多不方便的地方，比如不方便进行动归计算，这时，就可以用缩点来解决问题，所谓缩点，就是将这张有向图中所有的强连通分量变成一个一个的团，然后给这些团加边，形成一张DAG（有向无环图），就便于解决问题了。 这张图会让你更明白一些： 这张图中共有四个强连通分量，已经用红色圈出来了，对其进行缩点操作以后，就会变成下面这个样子： 是不是很棒棒啊仔细研究一番以后，可以发现：点1对应强连通分量1,2,3,41,2,3,41,2,3,4，点2对应强连通分量8,98,98,9，点3对应强连通分量5,6,75,6,75,6,7，点4对应强连通分量101010，此时，这张图中已经不存在环了，可以放心地尽情搞♂事♂情。 算法思路 Tarjan求出强连通分量，并在出栈时更新color和p。 遍历所有边，如果这条边连接的两个点不在同一个强连通分量中，就连边。 看起来很简单是不？没错，就是这么简单，没有别的了，只是有些细节可以再优化一下，下面的代码中会讲到。 参考代码 题目： 洛谷 P3387 【模板】缩点 传送门 题目大意： 将一张有向图缩点，然后在新的图上跑一遍记忆化DFS（DP也行），求出一条经过的点权值和最大的路径。 为什么知道这道题是缩点呢？废话这题目写了是缩点模板的嘛 既然题目告诉我们，可以重复经过一个点或一条边，但权值只计算一次，那么，既然是同一个强连通分量，取了一个，为什么不能取其他的呢？反正可以重复经过，取完一个强连通分量再回到之前的点就行了，完全不影响啊，这样缩完点后，一个强连通分量就是一个点，到达这个点，相当于就是到达了整个强连通分量，同时，在DAG图上跑记忆化，可以做到O(n)O(n)O(n)啊，如果不缩点，那就要重复经过一个点，这样时间复杂度就大大提升了，所以为什么不先用Tarjan跑一遍O(n)O(n)O(n)，再用记忆化跑一遍O(n)O(n)O(n)呢，这样更优啊。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;struct Edge{ int next; int to;};Edge edge[100001];int x[100001],y[100001]; int n,m,s,a[10001],head[10001];int cnt,cur,top,dfn[10001],low[10001],stack[10001],v[10001];//cur是统计强连通分量个数的int np[10001],b[10001];//这里的np相当于是上面的p，b则是colorint ans,f[10001];//f[i]记录的是从第i个强连通分量开始遍历所能取到的最大值void add_edge(int u,int v){ edge[s].next=head[u]; edge[s].to=v; head[u]=s; s++;}void tarjan(int x){ cnt++; dfn[x]=low[x]=cnt; stack[++top]=x; v[x]=1; for(int i=head[x];i!=-1;i=edge[i].next) if(!dfn[edge[i].to]) { tarjan(edge[i].to); low[x]=min(low[x],low[edge[i].to]); } else if(v[edge[i].to]) low[x]=min(low[x],dfn[edge[i].to]); if(dfn[x]==low[x]) { cur++;//当前强连通分量遍历完毕，cur加一 while(stack[top+1]!=x)//这里之所以用top+1是为了把x也弹出来 { v[stack[top]]=0; b[stack[top]]=cur;//标记栈顶的点属于第cur个强连通分量 np[cur]+=a[stack[top]];//p为这一强连通分量中所有点权值之和 top--; } }}void dfs(int x){ if(f[x]) return;//搜过了，就不再搜了 int maxn=np[x]; for(int i=head[x];i!=-1;i=edge[i].next) { if(!f[edge[i].to]) dfs(edge[i].to); maxn=max(maxn,f[edge[i].to]+np[x]);//取所有出边的终点中f的最大值 } f[x]=maxn;}int main(){ memset(head,-1,sizeof(head)); scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); for(int i=1;i&lt;=m;i++) { scanf(&quot;%d%d&quot;,&amp;x[i],&amp;y[i]); add_edge(x[i],y[i]);//优化：将之前的边存下来，便于后面重新建图 } for(int i=1;i&lt;=n;i++) if(!dfn[i]) tarjan(i); memset(head,-1,sizeof(head)); memset(edge,0,sizeof(edge)); s=0; for(int i=1;i&lt;=m;i++)//为什么不用链式前向星遍历：为了节省内存，我们将之前的edge清空 //因为链式前向星不是线性存图，所以一边遍历edge一边用edge来存图会冲突 if(b[x[i]]!=b[y[i]])//b[x[i]]和b[y[i]]分别表示x[i]和y[i]所在的强连通分量 add_edge(b[x[i]],b[y[i]]);//添加第b[x[i]]个强连通分量和第b[y[i]]个强连通分量之间的边 for(int i=1;i&lt;=cur;i++)//缩点后的图不一定从一点出发就能到达所有的点，因此要一个一个枚举 { dfs(i);//记忆化深搜 ans=max(ans,f[i]); } printf(&quot;%d&quot;,ans); return 0;} Tarjan+割点 何为割点？ 在一张无向图中，有一个或几个点，删去之后整张图就不连通了，这样的点称为割点，也就是说，如果没有这个点，一张连通图就会变成几张连通图。 还是举个例子： 在这张无向图中，很容易看出，如果删去点3，整张图就会变成1,21,21,2和4,5,64,5,64,5,6两张连通图，因此，点3为这张无向图的割点，同时，如果删去点4，整张图会变成1,2,31,2,31,2,3和5,65,65,6两张连通图，因此，点4也是这张图的割点。 算法思路 从一个根节点出发，遍历全图。 一边遍历，一边判断当前点是否为割点。 关于如何判断割点，我们分成两部分来考虑。 如果这个点是根节点，那好办，如果它连接两个及以上的连通图，这个点就是割点，因为如果去掉这一点，这些连通图就不连通了（之所以会有两张及以上的连通图，就是因为这些图彼此两两不连通，而只通过根节点连接彼此，所以，如果根节点炸了，这些图就失去了唯一的连通途径，就不连通了） 如果这个点不是根节点，就要判断它下面的点不通过它能否返祖，如果全都可以，则这个点不为割点，因为它的儿子都可以不通过它返祖，那要它也没什么用，但只要有一个儿子必须经过它才能返祖，这个点就是割点，因为去掉它后它的儿子就不能与上面的图连通。 如何判断？ 用这个！if(low[v]≥dfn[u])if(low[v]\\ge dfn[u])if(low[v]≥dfn[u])，low记录的是不经过祖先节点所能访问到的最早的祖先的时间戳，如果儿子的low值比当前节点的时间戳要小（或正好等于它），就说明这个儿子不经过它，是无法访问到更早的点的，所以去掉这个点后，它的儿子和祖先节点的连接就会断掉，就不连通了，所以这个点是割点。 用图来模拟一下好了。 我们从点1开始遍历，因此点1为根节点，它连接了两张连通图（即2,3,42,3,42,3,4和555），如果它炸了，两张连通图就不再相互连通，所以它是割点。再看点2，因为点3和点4不经过点2就无法访问点1，所以，点2如果炸了，点3和点4就不能与点1连通，所以点2也是割点。 一个非常重要的地方 这里就可以看出为什么当遍历时遇到祖先节点时的公式为low[u]=min⁡(low[u],dfn[v])low[u]=\\min(low[u],dfn[v])low[u]=min(low[u],dfn[v])而不是low[u]=min⁡(low[u],low[v])low[u]=\\min(low[u],low[v])low[u]=min(low[u],low[v])了，因为如果是后者的话则计算的是不管怎样到，总之能到达的最早的祖先，这样无法判断这个点最直接的能回到的祖先，也就无法判断割点。在上面的图中，如果用后面那个公式，low[3]和low[4]就都会变成1，此时再判断点2，就不能看出点2是割点了。 参考代码 题目： 洛谷 P3388 【模板】割点（割顶） 传送门 题目大意： 求一张无向图中的割点（注意：是从小到大输出节点！） 参考代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;struct Edge{ int next; int to;};Edge edge[200001];int n,m,s,head[20001];int cnt,top,cur,dfn[20001],low[20001],stack[20001],v[20001],b[20001];//b用来存放割点void add_edge(int u,int v){ edge[s].next=head[u]; edge[s].to=v; head[u]=s; s++;}void tarjan(int x,int root)//root是当前连通图的根节点，也就是最先被遍历的那个点{ int son_cnt=0,flag=0;//son_cnt统计连接的连通图个数 cnt++; dfn[x]=low[x]=cnt; stack[++top]=x; v[x]=1; for(int i=head[x];i!=-1;i=edge[i].next) if(!dfn[edge[i].to]) { tarjan(edge[i].to,root); low[x]=min(low[x],low[edge[i].to]); if(low[edge[i].to]&gt;=dfn[x]&amp;&amp;x!=root) flag=1; if(x==root) son_cnt++;//遍历完一个点后，这个点所在的连通图也就遍历完了，所以加一 } else if(v[edge[i].to]) low[x]=min(low[x],dfn[edge[i].to]);//注意！原因上面讲过了，不这样写的话就会WA if(son_cnt&gt;=2)//如果连接的连通图个数大于一，则这个点为割点 flag=1; if(flag) b[++cur]=x; if(dfn[x]!=low[x]) while(stack[top+1]!=x) { v[stack[top]]=0; top--; }}int main(){ memset(head,-1,sizeof(head)); scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) { int x,y; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); add_edge(x,y); add_edge(y,x);//无向图要添加两条边 } for(int i=1;i&lt;=n;i++) if(!dfn[i]) tarjan(i,i);//枚举所有点，如果没有被遍历过，就从这一点开始遍历 sort(b+1,b+1+cur);//排序！！ printf(&quot;%d\\n&quot;,cur); for(int i=1;i&lt;=cur;i++) printf(&quot;%d &quot;,b[i]); return 0;} 总结 Tarjan算法真的很常用，而且应该算是比较难的一个东西了，它有很多应用，还有很多的扩展，所以一定要把最基础的东西弄牢固，否则会对后面的练习造成困难。 一些相关的题目 洛谷 P1656 炸铁路（割边，与割点的求法有一个很小的不同，看一下题解就知道了） 洛谷 P2341 【模板】强连通分量 / [HAOI2006]受欢迎的牛（缩点） 洛谷 P2746 [USACO5.3]校园网Network of Schools（缩点，有点考智商） 洛谷 P3469 [POI2008]BLO-Blockade（有难度的割点+数学） 洛谷 P5058 [ZJOI2004]嗅探器（有些难度的割点）","link":"/posts/1282189380.html"},{"title":"【笔记】图论-最近公共祖先","text":"前置知识：树 概念 众所周知，在一棵树上，每个点都有其祖先，而最近公共祖先，顾名思义，就是指一个或几个点共有的祖先，且这个祖先的深度最大，为了方便，我们把一个或几个点的最近公共祖先记为LCA(u1,u2,⋯ ,un)\\text{LCA}(u_1,u_2,\\cdots,u_n)LCA(u1​,u2​,⋯,un​) 举个例子，这是一棵树： 其中，LCA(3,12)=2\\text{LCA}(3,12)=2LCA(3,12)=2，LCA(11,12)=4\\text{LCA}(11,12)=4LCA(11,12)=4，LCA(10,14)=1\\text{LCA}(10,14)=1LCA(10,14)=1，LCA(12,2)=2\\text{LCA}(12,2)=2LCA(12,2)=2，而LCA(7,8)≠1\\text{LCA}(7,8)\\neq 1LCA(7,8)​=1，因为555也是他们的公共祖先，并且555的深度比111大。 另外，LCA不一定只是在二叉树上才有（废话），上图很明显就不是一个二叉树 一般来说，LCA有四种求法，即倍增、Tarjan、RMQ+ST表和树链剖分，但本文只记录了三种，没有关于树链剖分的介绍，主要是因为树剖码量比较大，而且如果只是单纯地求某两点的LCA的话很浪费，这玩意用途很大，后面会专门写一篇文章来介绍，到时候反正也要说，所以这里就先不管了 倍增 倍增算是比较常见的求LCA的方法了，同时也是我个人比较喜欢用的一种方法。倍增是在线算法，相当于就是不管什么时候，只要你想求LCA，就可以跑一遍倍增，不需要事先知道所有的输入数据，也就是常说的输入一个回答一个，与之相反的是离线算法，这在Tarjan里面会更详细地讲 思路 一般来说，当我们还没有学过LCA的算法之前，我们首先想到的是暴力，先把两个点挪到相同的高度，然后把它们一层一层往上挪，它们相遇的时候所在的点就是它们的最近公共祖先，但是很明显，这样子太慢了，首先是需要用DFS预处理出每个节点的父亲及其深度，时间复杂度为O(n)O(n)O(n)，然后每次查询的时间复杂度大约为O(log⁡n)O(\\log n)O(logn)（特殊情况另当别论） 而倍增相当于是对暴力算法的优化，不再是一层一层地挪，而是用一个fa[u][i]数组来表示uuu的第2i2^i2i个祖先，实现快速移动 要想理解这一点，首先要理解一点，即通过上述方法，可以使树上的一个点移动到任意一个祖先节点 假设这个点的深度为depudep_udepu​，它的祖先节点的深度为depvdep_vdepv​，那么要跳到vvv去，之间会经过depu−depv+1dep_u-dep_v+1depu​−depv​+1个点，我们把这个数转化成二进制（假设为555），则有： (5)10=(101)2=20+22(5)_{10}=(101)_2=2^0+2^2 (5)10​=(101)2​=20+22 也就是说，uuu只需要先跳到fa[u][0]，再跳到fa[u][2]（这里的uuu已经是原来的fa[u][0]了）就可以到vvv了 另外这个数组有一个递推公式，思路也比较简单，就是自己的第2i−12^{i-1}2i−1个父亲的第2i−12^{i-1}2i−1个父亲就是自己的第2i2^i2i个父亲，即fa[u][i]=fa[fa[u][i-1]][i-1] 既然如此，倍增算法的思路也就出来了，在一开始用DFS预处理出所有的fa[u][i]，然后每次查询时先把两点调到相同的高度，再让两点一起移动就可以了，而这两个过程都可以采用上述方法 但这样又会有一个小问题，我并不知道LCA(u,v)\\text{LCA}(u,v)LCA(u,v)的深度，没有办法预先知道要跳多少，所以在这个过程中就有可能跳到LCA的上方，这个问题也好解决，既然我不知道哪个祖先是它们的最近公共祖先，那我就干脆不跳到他们的公共祖先，只是跳到最接近它们公共祖先的地方，即它们LCA的下一层，然后最后返回fa[u][0]就可以了，这样判断起来也很容易，如果是跳到了共同的祖先，那么fa[u][i]一定会等于fa[v][i]，所以在每次循环时判断一下就好了 还有一点，在最后这里uuu和vvv一起跳的时候，这个循环的顺序和移动uuu到vvv的深度时的顺序是相反的，也就是说这里要把iii从大往小循环，可以这样理解，这个跳的过程就是为这个深度差的二进制位填111的过程，每填一个111，就跳到对应的fa[u][i]（iii为这个111在二进制数里面的位数），之前我们知道这个值是多少，所以可以从低位开始一位一位按照这个给定的值去填，但此时我们并不知道这个值是多少，所以我们必须要尝试，如果从低位开始，那么有可能这一位本来是为000的，但填了111之后并没有超过原数的大小，只有到后面我们才会发现填错了，而如果从高位开始，那么就不会有这种问题。可以联系一下我们小学时学的比较数的大小的方法，先把最低位对齐，然后从最高位一位一位开始比，如果在某一位上一个数的数字小于另一个，那么就可以判断这个数一定小于那个数，这里也是一样的，如果本来是000，被填成了111，那么马上就可以发现这个数大于了深度差，也就是跳到了公共祖先上去 大概的思路就是这样了，可能写的有点迷，要是搞不懂的可以在评论里说一声，我好改进一下 过程模拟 众所周知，手动模拟能解决一切疑惑 我们用上面那棵树来模拟一下这个过程，假设我们求的是LCA(13,12)\\text{LCA}(13,12)LCA(13,12) 发现121212的深度和131313不一样，并且比它深，所以要将其上移，此时深度的差值为111，因此只需要一次u=fa[u][0]即可解决问题，此时121212变为444，而444不为131313，所以131313并不是LCA(13,12)\\text{LCA}(13,12)LCA(13,12) 然后是上跳，从nnn（点数）的二进制最高位开始试（这里求nnn的二进制最高位的位数iii就是求log⁡n\\log nlogn，有一个简便方法：i=log(n)/log(2)+0.5，这个0.50.50.5是起四舍五入的作用的），首先是fa[4][4]和fa[13][4]，发现它们都等于000，则不管它，继续。然后是fa[4][3]和fa[13][3]，和上面一样，不管，继续。fa[4][2]和fa[13][2]也是都等于000，直到fa[4][1]和fa[13][1]才都等于111，虽然我们知道这就是它们的LCA，但程序并不能分辨这是不是最近的公共祖先，所以还是跳过，最后fa[4][0]=2和fa[13][0]=6，这下才能执行u=fa[u][i],v=fa[v][i]的程序，两个点分别变为222和666 最后，返回fa[2][0]=1，求出LCA(13,12)=1\\text{LCA}(13,12)=1LCA(13,12)=1，完毕 参考代码 题目：洛谷 P3379 【模板】最近公共祖先（LCA） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;bits/stdc++.h&gt;using namespace std;struct Edge{ int next; int to;};Edge edge[1000001];//记得要建双向边，因为在输入的时候并不知道谁是谁的父亲int n,m,s,cnt,head[500001];int log2n,dep[500001],fa[500001][21];//log2n上面提到过，记录的是log(n)，dep数组记录每个点的深度，fa[u][i]记录第u个点的第2^i个父亲void add_edge(int u,int v){ cnt++; edge[cnt].next=head[u]; edge[cnt].to=v; head[u]=cnt;}void dfs(int u,int father)//预处理求出dep和fa数组{ fa[u][0]=father; dep[u]=dep[father]+1; for(int i=1;(1&lt;&lt;i)&lt;=dep[u];i++)//1&lt;&lt;i相当于2^i，这里要保证2^i小于u的深度 fa[u][i]=fa[fa[u][i-1]][i-1]; for(int i=head[u];i;i=edge[i].next) if(edge[i].to!=father) dfs(edge[i].to,u);}int lca(int u,int v)//倍增求LCA//因为u和v的值会在函数里发生改变，所以一定要用传参函数，也就是我们平时习惯的那样{ int depu=dep[u],depv=dep[v]; //这里也不能少，和上面一样，u和v的值会在函数里发生改变，但深度又要保持不变，所以另外用两个变量来代替 if(depu!=depv)//如果两个点深度不一样，所以需要调到相同高度 { if(depu&lt;depv)//因为默认是移动u点，所以要保证u在v的下方 { swap(u,v); swap(depu,depv); } for(int i=0;i&lt;=depu-depv;i++) //准确来说这里应该是log(depu-depv)/log(2)+0.5，但我嫌麻烦，而且这样也是对的 if((1&lt;&lt;i)&amp;(depu-depv))//判断第(depu-depv)的第i位是否为1，可以自己算一下 u=fa[u][i]; } if(u==v)//不要忘了判断，如果这里漏了，那么最后的返回值就是fa[LCA(u,v)][0] return u; for(int i=log2n;i&gt;=0;i--)//从高位向低位填1 if(fa[u][i]!=fa[v][i])//判断这一次所跳的点是否为公共祖先 { u=fa[u][i]; v=fa[v][i]; } return fa[u][0];}int main(){ scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;s); for(int i=1;i&lt;=n-1;i++) { int x,y; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); add_edge(x,y); add_edge(y,x); } log2n=log(n)/log(2)+0.5; dfs(s,0); for(int i=1;i&lt;=m;i++) { int a,b; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); printf(&quot;%d\\n&quot;,lca(a,b)); } return 0;} 整个程序不算太难，比较简洁，定义的数组也不多，所以我个人（当然也是很多人）比较喜欢这种算法 倍增的时间复杂度算是比较不错的了，O(nlog⁡n)O(n\\log n)O(nlogn)预处理，O(log⁡n)O(\\log n)O(logn)查询，同时这个nnn一般来说最大也就是1e51e51e5左右，而log⁡n\\log nlogn则不会超过202020，所以总体来说是很优秀的 Tarjan 这个Tarjan并不是求强连通分量的那个Tarjan，只是因为是同一个人发明的，所以都叫一样的名字（误导了我整整一学期=_=），关于这一点有兴趣的同志可以看一下这篇文章：Tarjan 大佬的算法们（根据这篇文章和百度百科看来，Tarjan这个巨佬至少发明了三四种算法和数据结构。。。） Tarjan是一种离线算法，也就是说和上面的倍增不同，它需要事先知道我们有哪些问题，然后一次性全部解决掉，好处是时间复杂度很棒，对于qqq次询问，Tarjan的时间复杂度仅为O(n+q)O(n+q)O(n+q)，但坏处也显而易见，不够灵活 思路 Tarjan其实比较容易理解，先对整棵树进行DFS，在这个过程中，每到一个点uuu并搜完这个点所有的子树后，查看有没有要查询的LCA(u,v)\\text{LCA}(u,v)LCA(u,v)（下称“有询问关系”），如果有，再看一下vvv是否遍历完毕，如果是，那么就找vvv的并查集的祖宗（也就是并查集的根结点，不是指这棵树上vvv的祖宗），这个祖宗就是LCA(u,v)\\text{LCA}(u,v)LCA(u,v)，最后标记自己已经遍历完毕，并把自己合并到父亲节点上（用并查集） 这时有一个小问题 为什么并查集的祖宗就是LCA？？？ 因为在这个过程中，我们是先遍历完所有子树才把自己合并到父亲节点上，此时我们分两种情况讨论，如果uuu和vvv互相都不是对方的祖先，那么它们就处在两棵不同的子树上，如果遍历到vvv时发现uuu已经被遍历过了，那么此时uuu的并查集的祖宗一定在uuu和vvv所属的子树分叉的地方，因为这个点的子树还没有遍历完，还差vvv这棵，所以自然也就不会合并到自己的父亲上去，而这个分叉的地方很明显就是LCA(u,v)\\text{LCA}(u,v)LCA(u,v)。如果uuu和vvv中某一个点是对方的祖先（假设vvv是uuu的祖先），那就更好办了，当遍历到uuu时，vvv由于自己的子树还没遍历完，所以不会打标记，而回溯到vvv时，uuu已经遍历完毕，而vvv还没有把自己合并到父亲节点，所以目前uuu的所属的并查集的根是vvv，也就是LCA(u,v)=v\\text{LCA}(u,v)=vLCA(u,v)=v 搞清楚了这一点，这个算法也就很简单了，如果还有点搞不清楚，那就来手动模拟一次 过程模拟 老规矩，上图 这次我们多弄一点，要求求出LCA(5,3),LCA(7,8),LCA(2,5),LCA(1,4)\\text{LCA}(5,3),\\text{LCA}(7,8),\\text{LCA}(2,5),\\text{LCA}(1,4)LCA(5,3),LCA(7,8),LCA(2,5),LCA(1,4) 首先从点111开始，一路向下，一直到点555，发现这是叶子节点，查看与555有询问关系的333和222，发现它们都还没有标记，所以不管，标记vis5=1,fa5=2vis_5=1,fa_5=2vis5​=1,fa5​=2，然后回溯 回溯到点222，发现它的子节点都搜完了，而有询问关系的点555已经被打了标记，所以查看它的祖先为222，因此LCA(2,5)=2\\text{LCA}(2,5)=2LCA(2,5)=2，标记一下vis2=1,fa2=1vis_2=1,fa_2=1vis2​=1,fa2​=1，回溯 又到了点111，由于子树还没有搜完，因此暂时不查看与点111有询问关系的点，也不打标记，先搜一下点333，一直往下到点777 点777也是个叶子节点，但与777有询问关系的888还没有标记，所以也不管，标记vis7=1,fa7=3vis_7=1,fa_7=3vis7​=1,fa7​=3，回溯到点333，接着又搜点888 到了点888，发现有询问关系的点777已经被打了标记，所以查看777的祖宗，为333，所以LCA(7,8)=3\\text{LCA}(7,8)=3LCA(7,8)=3，再标记vis8=1,fa8=3vis_8=1,fa_8=3vis8​=1,fa8​=3，回溯 回到点333，这时点333的子节点全部搜完，所以查看与点333有询问关系的点555，发现已经被打了标记，所以查看其祖宗，为点111（fa5=2,fa2=1fa_5=2,fa_2=1fa5​=2,fa2​=1，并查集基本操作），因此LCA(5,3)=1\\text{LCA}(5,3)=1LCA(5,3)=1，老规矩，打个标记，vis3=1,fa3=1vis_3=1,fa_3=1vis3​=1,fa3​=1，回溯 又回到了点111，还是没有搜完它的儿子，所以还是不管，来到点444 这点444也是个叶子节点，与111有询问关系，但111还没被打标记，所以还是vis4=1,fa4=1vis_4=1,fa_4=1vis4​=1,fa4​=1，回溯 回到点111，这回终于把它的儿子搜完了，查看点444的祖宗为点111，因此LCA(1,4)=1\\text{LCA}(1,4)=1LCA(1,4)=1，搜索结束 至此，所有要求的LCA都求出来了，直接输出即可 个人感觉不难懂吧，但顺序一定要整好，先查看有询问关系的点，再标记自己，否则就会出现LCA(2,5)=1\\text{LCA}(2,5)=1LCA(2,5)=1的事情 参考代码 老实说我个人并不是很喜欢用Tarjan算法来求LCA\\text{LCA}LCA，因为这玩意数组太多，相对应的函数也很多，整个码量都比较大，不过有时候题目可能会强制离线，比如设置一大堆询问这种，这时候用倍增就有可能会超时，所以还是应该掌握这种算法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;bits/stdc++.h&gt;using namespace std;struct Edge{ int next; int to;};struct Que{ int next; int to; int p;//p表示的是这个询问对应的是第几个问题，方便最后按照顺序输出答案};Edge edge[1000001];Que que[1000001];//我这里使用链式前向星存储询问，这样便于查询某一个点的所有询问，而不用每次都遍历所有问题 //其实是因为当时我太弱了，否则用vector来存其实更方便int n,m,s,cnt,f[500001],head[500001],queh[500001],vis[500001],ans[500001];int find(int x)//并查集基础操作不解释{ return f[x]==x?f[x]:f[x]=find(f[x]);}void add_edge(int u,int v){ cnt++; edge[cnt].next=head[u]; edge[cnt].to=v; head[u]=cnt;}void add_que(int u,int v,int i){ cnt++; que[cnt].next=queh[u]; que[cnt].to=v; que[cnt].p=i; queh[u]=cnt;}void lca(int u,int father){ for(int i=head[u];i;i=edge[i].next)//首先搜索这个点的所有子树 { int v=edge[i].to; if(v!=father&amp;&amp;!vis[v]) { lca(v,u); f[find(v)]=find(u);//这里我是回溯到父节点时才打标记，效果和上面说的查看完所有询问再标记是一样的 //另外，其实直接f[v]=u就可以了，这里只是打并查集习惯了而已 vis[v]=1; } } for(int i=queh[u];i;i=que[i].next)//查看所有询问，如果对方已经被打了标记，就求出答案 if(vis[que[i].to]) ans[que[i].p]=find(que[i].to);}int main(){ scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;s); for(int i=1;i&lt;=n;i++) f[i]=i; for(int i=1;i&lt;=n-1;i++) { int u,v; scanf(&quot;%d%d&quot;,&amp;u,&amp;v); add_edge(u,v); add_edge(v,u); } cnt=0; for(int i=1;i&lt;=m;i++) { int a,b; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); add_que(a,b,i);//这里要建双向边，但对应的p值应该是一样的 add_que(b,a,i); } lca(s,0); for(int i=1;i&lt;=m;i++) printf(&quot;%d\\n&quot;,ans[i]); return 0;} 整个过程还是很简单，如果还有什么不懂的可以在评论里问反正也不会有人看我博客的 RMQ+ST表 这也是一种在线算法，时间复杂度很强，预处理O(nlog⁡n)O(n\\log n)O(nlogn)，而询问只需要O(1)O(1)O(1)，不过有点难想，最重要的就是怎样把求LCA转化成RMQ，以及为什么这样做是对的，搞懂了这一点后，代码其实就好写了 关于ST表以及相应的用它来求RMQ，请自行上网查找，这里不再赘述 思路 在开始之前，我们先引入一个东西，欧拉序列 所谓欧拉序列，其实就是一棵树的DFS序，只不过每到一个节点都得记录一下，就连回溯时也是一样 以上面Tarjan算法那张图为例 这棵树的欧拉序列是这样的 序号 1 2 3 4 5 6 7 8 9 10 11 12 13 点 1 2 5 2 1 3 7 3 8 3 1 4 1 这个序列的长度为2n−12n-12n−1，nnn为这棵树的点数（其实上面这张图只有777个点，我漏了一个666。。。），这个看网上都很少有证明的，虽然不是很重要，但我觉得还是应该知道为妙 首先设点uuu有xux_uxu​个儿子，点的标号从111到nnn，易得，点uuu在这个序列中出现的次数为xu+1x_u+1xu​+1，因为每个儿子回溯时都会出现一次，同时一开始从父亲下来的时候还会出现一次 容易得出 ∑i=1nxi=n−1\\sum\\limits_{i=1}^n x_i=n-1 i=1∑n​xi​=n−1 因为每个点会且只会被算一次（因为每个点只有一个父亲嘛），同时点111作为根节点，没有父亲，所以是没有被算过的，要减去111 这样的话，所有点在这个序列中出现的总次数，也就是这个序列的长度，就是 len=∑i=1nxi+1=∑i=1nxi+n=n−1+n=2n−1len=\\sum\\limits_{i=1}^{n}x_i+1=\\sum\\limits_{i=1}^nx_i+n=n-1+n=2n-1 len=i=1∑n​xi​+1=i=1∑n​xi​+n=n−1+n=2n−1 完事 好了，回归正题，既然有了欧拉序列，我们就可以把树上问题转化成序列问题了 不过问题来了，你怎么知道这就是RMQ呢？ 我们来看，对于任意两点uuu和vvv，设它们第一次出现的位置的序号为posupos_uposu​和posvpos_vposv​，且posu&lt;posvpos_u&lt;pos_vposu​&lt;posv​（大不了如果不满足的话可以把uuu和vvv换一下嘛，不影响），那么在posupos_uposu​和posvpos_vposv​之间，深度最浅的点是哪个？ LCA(u,v)\\text{LCA}(u,v)LCA(u,v)！ 这个可以结合Tarjan算法的并查集合并来想，uuu要么是vvv的祖先，要么不是（因为uuu在序列中先出现，所以如果有一个点是对方的祖先的话，那么uuu一定深度更浅，也就一定是对方的祖先），如果是的话，由于vvv是uuu的子树上的点，所以在vvv第一次出现的时候，uuu的子树一定还没有搜完，也就不可能回溯到比uuu更浅的点，所以在这段区间中，uuu的深度一定是最浅的。如果不是，那么uuu和vvv一定处在LCA(u,v)\\text{LCA}(u,v)LCA(u,v)的两棵不同的子树上，而在搜完自己所有的子树前，LCA(u,v)\\text{LCA}(u,v)LCA(u,v)是不会回溯的，所以它也是这段区间中最浅的点，所以，对于任意两个点uuu和点vvv（posu&lt;posvpos_u&lt;pos_vposu​&lt;posv​），我们只需要找到在序列中posupos_uposu​和posvpos_vposv​之间的深度最小的点，就可以找到它们的LCA，而这很明显就是RMQ 那么为什么非要取每个点第一次出现的位置来作为区间的起讫点呢（不然你想取第几个啊喂）？其实主要还是为了方便，因为有的点只会出现一次嘛，所以记录第一次出现的位置是最方便的了（当然也有可能是其他原因，不过我不太清楚，如果哪位大佬知道可以在评论里说一下） 知道以上几点之后，思路就很简单了，我们先DFS一遍，求出欧拉序列，然后预处理ST表，最后查询就完事了 参考代码 这玩意的代码比较难懂，我个人其实也不是很喜欢用 另外，这里面的ST表数组（也就是那个dp）记录的其实是序列中从iii到i+2j−1i+2^j-1i+2j−1这个区间里的点中具有最小深度的点在这个序列中的下标，并不是最小深度，因为我们只关心这个点是哪个点，而不关心它的具体深度 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;bits/stdc++.h&gt;using namespace std;struct Edge{ int next; int to;};Edge edge[1000001];int n,m,s,cnt,k,head[500001],f[1000001],dep[1000001],p[500001],dp[1000001][21];//f是欧拉序列，dep是序列中每个位置的点的深度，p是每个点在这个序列中第一次出现的位置void add_edge(int u,int v){ cnt++; edge[cnt].next=head[u]; edge[cnt].to=v; head[u]=cnt;}void dfs(int u,int father,int depth){ k++; dep[k]=depth; f[k]=u; p[u]=k;//这是从父亲节点下来的那一次，所以一定是这个点在序列中第一次出现 for(int i=head[u];i;i=edge[i].next) if(edge[i].to!=father) { dfs(edge[i].to,u,depth+1); k++;//搜完一棵子树回溯时也要记录 dep[k]=depth; f[k]=u; }}void RMQ()//ST表初始化{ for(int i=1;i&lt;=2*n-1;i++) dp[i][0]=i; for(int i=1;(1&lt;&lt;i)&lt;=2*n-1;i++) for(int j=1;j+(1&lt;&lt;i)-1&lt;=2*n-1;j++) { int a=dp[j][i-1],b=dp[j+(1&lt;&lt;(i-1))][i-1]; dp[j][i]=dep[a]&lt;dep[b]? a:b;//记录下标，而不是深度 }}int query(int l,int r)//查询{ int t=log(r-l)/log(2.0); int a=dp[l][t],b=dp[r-(1&lt;&lt;t)+1][t]; return dep[a]&lt;dep[b]? f[a]:f[b];}int main(){ scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;s); for(int i=1;i&lt;=n-1;i++) { int x,y; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); add_edge(x,y); add_edge(y,x); } dfs(s,0,1); RMQ(); for(int i=1;i&lt;=m;i++) { int a,b; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); printf(&quot;%d\\n&quot;,query(min(p[a],p[b]),max(p[a],p[b])));//这里就相当于调换顺序 //当然也可以在函数中比较两者大小 //如果前大后小，就调换顺序 } return 0;} 相关题目 SP14932 LCA - Lowest Common Ancestor（板子题） P2420 让我们异或吧（LCA结合路径查询，其实用树剖要好整一点，不过倍增也可以解决） P3398 仓鼠找sugar（主要是证明树上两条路径相交的条件，与LCA有大关系） P2245 星际导航（最小生成树+LCA，这玩意整整恶心了我一个半小时） P3258 [JLOI2014]松鼠的新家（LCA+树上差分，也是很常见的组合了） CF191C Fools and Roads（LCA+树上差分） LCA其实也不算多难的算法吧，但这玩意如果是和其他东西结合起来，可以让人觉得十分恶心，所以还是应该加强训练，提高自己的水平","link":"/posts/undefined.html"},{"title":"关于这半年来所发生的事的一些想法","text":"终于考完期中考试了，不管考得怎么样，总归还是熬过半个学期了，所以想写点东西来记录一下这半个学期以来发生的一些事情吧。 寒假 这次寒假过的还是很艰难的啊，在大概一月底的时候，湖北爆发了新冠疫情，导致全国进入抗疫状态，所有娱乐活动全部木大，放假时说的是春节那几天要去福建玩一玩的，结果不用说，直接取消，生日本来计划和同学一起到外面嗨一天的，这下也没了。。。虽然对我这种一天到晚就喜欢宅在家里的人也没什么影响 但即使如此，整个寒假我还是处于一种极度颓废的状态。刚放假那会，我看了很多大佬的博客，发现他们很多都是用的博客园啊、CSDN这种，对于自己只知道用洛咕博客的行为产生了怀疑，于是想自己弄一个，经过发帖询问后选择了Hexo，从此在这条路上一去不复返。由于是第一次接触这种东西，而且平时除了C++就再也没看过其他的一些语言什么的了，导致刚入手时完全处于懵逼状态，花了很多时间来整这东西，然后又忙于美化（主要是一开始用的Next主题虽然很受欢迎，但其实很多地方跟我想要的不太一样，但自己又不会html和css这些东西，所以只好搬运别人的美化代码），再加上我自己的自控能力又不够，结果可想而知，文化课作业做的一塌糊涂，时间管理混乱不堪，甚至整个下午和晚上都不写作业，空出来捣鼓这个东西。因为不懂，所以常常受挫，但越是受挫，越是想继续弄下去，花的时间也就越来越多，最后的结果显而易见，我的所有文化课作业直到2月16日才全部完成（2月17日开学），而且有一项作业完全是敷衍了事，但按照以往的情况，在开学前一周，我的作业就应该大致完成了才对，拓展就更不用说了，整个寒假，我一篇现代文阅读也没做，但这正好是我最恼火的地方。可想而知，我在Hexo上花的时间有多少。 同时，除了捣鼓Hexo，水犇犇这项活动也贡献了不少。虽然是2019年2月就加入了洛谷，但我其实之前一直就是把这个网站当作一个纯学术的刷题的地方，对于那些含有一点社交性质的功能动都没动，包括犇犇。然后在这个寒假我终于发现了这个有趣的功能，开始活跃起来了，因为犇犇里其实几乎没有学术内容（起码我看到的是这样的），这当然就比每天不停的刷题有趣多了（当然刷题还是有他自己的乐趣的，只是相对这种娱乐活动来说感觉没有那么有趣），最后我直接沉迷于水犇犇，每天发的条数不说上百至少也有七八十条，最后文化课和OI几乎都没学到什么，只是单纯地耍了一天又一天。。。 开学（2月17号）之后，由于疫情影响，我们还得呆在家里上课，这对于我来说无疑是一个巨大的好消息，当然并不是说我要开始好好学习了，只是彼时我还没有完全弄完Next的美化，而呆在家里能提供更多的时间（感觉自己好像无可救药的样子。。。）。短暂的两周自学后，大概是在3月9日的样子，我们正式开始了网课生活，怎么说呢，感觉这个时候要比寒假时好一点吧，因为心里还是知道上课是很重要的，所以并没有像别人那样什么“Timi一响，网课白讲”，但也只是稍微好一点，毕竟颓废的工具就摆在面前，就我这点自控力还不足以完全抵挡诱惑。政史地生这些课还是会认认真真地上的，因为要是这个时候不认真，期末复习会很头秃的（这一点我上个学期已经深刻体会到了），物理也不敢走神，毕竟是力学，而且还是为高中打基础，而且其实也不算很无聊，语文因为都是讲的文言文，干货很多，一开小差就错过了，而且每天的作业都会涉及到上课内容，考试也会考到，所以还是认真听了的，英语课相对来说就没有那么认真了，有时候上课上着上着就会把钉钉的窗口用其他窗口覆盖掉（后来听说如果最小化的话就不会计入上课时长，很庆幸啊。。。），但还算是听了一些，数学课就基本是在神游了，反正是讲的不等式和图形的平移旋转这些，都是早就会的知识了，所以根本就没听讲，一上课就打开浏览器窗口水犇犇或是调试Hexo，被爸妈抓到了几次，还是不悔改，甚至开发出了对策——直接用电脑扬声器代替耳机，这样方便听见脚步声时立马关掉当前窗口。 现在想想，真的还是有点后悔，倒不是后悔不该搭建Hexo博客，不该去水犇犇，而是觉得自己的自控力怎么这么差，连一点诱惑都抵挡不住，放弃了自己的本分而去追求一时的快乐，这本身就是很不可取的，更何况，别人寒假时都在认真学习，而我却在努力下滑，这样差距拉的越来越大，到时候说不定连补都补不回来了。 我并不后悔做了这两件事，毕竟，这是我自己选择的，就像一个人用刀杀了别人，他却反过来怪刀太锋利了，这难道不是推卸责任吗，是的，这两个东西的诱惑是很大，但并不只有我一个人在使用啊，为什么别人能控制住不让它们影响自己的日常生活，我却做不到呢，还不就是我自己的问题！而且，这两件事并非没有益处，捣鼓Hexo，让我大致了解了html和css的一些最最基本的东西，而水犇犇除了带来快乐以外，其实也让我学到了一点和别人交流的技巧吧，虽然这些益处不算大，但终归还是不能埋没它们的存在。 说真的，整个寒假，我几乎没干什么事，每天光顾着傻乐去了，有用的事一件也没做，日子过得浑浑噩噩，当时还不觉得什么，现在回头看看，真的感觉当时真的太傻了，总觉得自己能力很强，颓一会不算什么，但经过日积月累，所带来的就不是一时半会能弥补的了。 罢了，寒假早就过去了，现在后悔也没什么用了，就当作是我的一个黑历史吧，希望我以后能引以为戒，不要再次沉迷于网络了。 正式开学 4月13日，我们终于正式开学了，然后开学当天居然就是入学考试，按照以往的规矩，考试前我一般都会很紧张，但这次恐怕是因为寒假颓得太厉害了，居然半点紧张的心情都没有，就是平时小测前的那种心态，别人都会觉得这是心理素质强的表现，但我觉得适当的紧张其实是有利于考试发挥的，完全不紧张反而不是那么好，总之，我就这样上了考场，然后考得一塌糊涂。 语文作文写了两面作文纸，第一面全在铺垫，第二面才开始叙事；数学A卷最后一道题脑残少算了一种情况，然后B卷又错了一大堆；地理由于没看见图上有标号导致下面的三道填空错位，总之就是被完全碾压的感觉，我都做好飞到年级100名外的心理准备了，结果。。。 第！五！名！ 当时真的着实把我吓了一大跳，后来仔细想想，大概是因为虽然大家都在颓，只是我没有颓的那么厉害而已，毕竟我并没有沉迷游戏，甚至上课都在玩，为什么这么说呢，看一下上学期期末的成绩和这次的成绩对比就知道了 这是上学期期末的： 地理 生物 语文 数学 英语 物理 年排 100 96 132 149 146.3 118 2 （为了方便对比，除开了政治和历史） 这是这学期的： 地理 生物 语文 数学 英语 物理 年排 96 96 119 134 143.5 116 5 完全是天差地别好吧！就这破样还能考年级第五，要是这都是真实水平，那臭豆腐连锁还叫什么名校啊，完全被四七九碾压好吧！ 当时我就意识到，这次考试的排名完全不能用来作为参考，下滑是肯定的，而且还滑了不少，但我还是没有制定相应的对策，在学校里得过且过，不能说状态很差，但肯定不是想要再一次考到高分的状态，周末在电脑面前的时间还是不少，早晨、午饭后、晚饭后、睡前，几乎但凡闲下来，我就会抱出电脑，做作业时也不是像以前一样精益求精，而是做完了事，感觉其实就比寒假要好一点，其他基本都是差不多的，还是有点沉迷电脑，虽然知道这样不行，但每次一开机，就没有再想别的了，然后一关机，负罪感马上就来了，每次想的是30的时候就关机，结果每次都要40甚至50才关掉，在做作业时也会时常想到有关的东西，另外，本来周末应该做一些拓展的，但周天上午其实做不到多少，周天下午又是全部拿来追番去了，所以物理数学的纠错什么的慢慢就松懈了。。。 说真的，自控力差真的很折磨人啊，有想要成功的愿望，但却总是被这样或那样的诱惑给带偏，最后好不容易重新回到了正道上，但是时间已经不早了。 在学校里呢，也好不到哪里去吧。每天其实过的不算很快乐主要是因为语文课，在上语文课的时候经常开小差（因为文言文都学完了嘛），语文作业也做的不是很好，原来几乎次次都可以得A+，现在变得有点艰难了，而且整体来看语文作业是变多了的，每天做作业的时间都还是有点紧，再加上那些组员又总不让我省心，老是在晚自习时违纪扣小组操勤分，整个一天仿佛都变得很忙碌，但仔细一想，要是把和同学聊天的时间挪一点来提前做点作业，其实也不至于此。 总的来说呢，上半学期的学校生活过的不算是很如意吧，可能有点遗憾，也有点难过，不是很在状态。怎么感觉我上半学期一无是处呢 期中考试 5月28日和29日，我们进行了半期考试审判降临，本来想单独写一篇游记的，但仔细想想，还是直接合并到这篇总结里要好一点。 Day 0（2020.5.27） 今天白天还是在上课，只不过老师都不布置作业了，xjy居然用两节英语课让我们来自己复习，还同意我们自由换座位，于是我就和Roy Yi说了两节课的话，当然并不是没有复习的，但那只是xjy带我们看了一些句型转换，然后听写了25个短语而已，事实上真正有用的个人认为只有讲的那个句型虽然考试并没有考。 晚自习的时候因为坐在最靠窗的一列，重新拉桌子的时候和同桌分开了，前30分钟的样子一直处于神游状态，然后就一个人看文言文和诗词的字形，保证默写不会错，又把文言文的翻译过了一遍，之后又复习了一下所有课文的字词的读音和字形，最后一节自习把生物书拿出来看了一部分，然后就下课了。 晚上回家因为一些事情和爸妈聊了很久，结果10点50才睡觉，然后又躺了30分钟的样子才睡着，一直在想组员的事情，本来打算睡前想一下有哪些可以写的作文的，结果也没有想。。。 感觉第二天考试一定完蛋了。。。 Day 1（2020.5.28） 居然8点20就要开始考语文。早上一去花了不到10分钟吃完早饭就直接在7点冲回教室，顺便从语文办公室把我的练习册摸了回来，然后开始我的传统习俗，考前做一篇现代文阅读，还可以，大部分都是对的，感觉又有一点信心了。8点离开教室，一到考场坐到位子上发现前面墙上的钟居然被黑板给挡住了一半，只看得到右半边钟面的一部分。。。 没想到考试座位右边就是个很熟的竞赛班大佬，稍微跟他聊了一会就发卷子了。 语文整体不算特别的难吧，但前面的选择题是真的有点迷惑，现代文不太有把握，因为最后一道6分的题是乱答的，作文还行，把以前写过的一篇稍微在脑子里改了改就直接放上去了，感觉不怎么违和，最后还剩了5分钟的样子，本来考前我最担心的就是做不完卷子，开学考试就差点因此而GG，结果现在不知道时间还做的这么快，估计是因为右边那个大佬做得太快了，不知不觉就让我也把速度提起来了。 考完一对答案，选择题错了两道，心态炸了，预计能考个125分就很不错了…… 本来以为地理会让我心情好一点，没想到这次zh出的题意外毒瘤，好多题书上根本找不到正确答案，只能靠脑子来想，而且考了那么多有关省级行政区的位置的问题，居然整张卷子还没有一张中国省级行政区的图，心态真的炸了啊 有趣的是yhl在班上跟我们信誓旦旦地说一定会考湖北和北京，结果就考了几道选择和一道填空，综合题跟这俩连边都沾不上，这押题水平……（不过估计还是因为她没想到zh把题出这么难） 地理也炸了，预计90分左右徘徊吧。。。 跟同学借了块表，这样下午就能看时间了。 第一堂考数学，一看到是zzy出的题就感觉不太对，这人一向毒瘤，出的题让我们这些蒟蒻完全没有体验。做完A卷，感觉还好，剩了一个小时，当时就在想zzy是不是改邪归正，终于估计到我们做题人的感受了 结果…… B卷完全爆炸了，填空题最后一道和解答题最后一个小题都没做起，当时感觉是不是自己水平下降了，还蛮沮丧的，然后考完，旁边那个人居然转过来对我说：“我觉得这次好简单哦 ，我全都做完了” 好简单！！！？？？(╯‵□′)╯︵┻━┻ 当时我强烈忍住了想掀桌子的欲望，问他最后一题怎么做，然后他说： 用四点共圆加上托勒密定理随随便便乱搞一通就好了啊 WDF？ 这是初二的考试啊兄弟，圆什么的明明是初三的知识去了吧 然后我突然反应过来，他在考前跟我说他们老师说这次考试会照顾他们竞赛班一点，可以用初三的方法来做题 这就是照顾竞赛班？出超纲题？？你让我们另外23个班怎么整，强行拉开5分差距？？？ 不是，你出一些用初三方法能做的初二的题我倒是没什么意见，但你出一道用初二方法做不了的初三题是想怎样？？？ 当时真的很气啊，填空题那道费马点我就不说了，但这道四点共圆就让人心里很不平了啊 当然如果这道题能用初二的方法做那当我没说，但目前问了很多人，没有人这么做出来了，可能有大佬会，但我觉得过程应该很麻烦。。。 我把题放在这里，要是有大佬用初二的方法（指全等之类的）做出来了第三小题，可以在评论区里鄙视一下我 以下内容更新于6月5日 啊啊啊太羞耻了，这么简单的题居然没做出来，其实这个题根本用不到那么难的方法，我在考场上想出来的辅助线作法其实是对的，就是因为没有尝试去倒角，所以没有做出来，要是当时想到了去倒一下角就做出来了啊，我怎么这么蠢啊。。。 目前有两种做法，解法一是答案讲的，解法二是我自己考场上想的，以后可能会有更多的解法，到时候再来补充 第一种 设PCPCPC与DFDFDF交于OOO，作CK⊥DFCK\\perp DFCK⊥DF于K，设∠FDC=α\\angle FDC=\\alpha∠FDC=α ∴∠PDO=90∘−α,∠DPO=2α∴∠PCD=90∘−2α∴∠POD=∠PCD+∠FDC=90∘−α∴∠POD=∠PDO∴PD=PO∵∠APO=180∘−2α,∠PAE=45∘,∠POE=90∘+α∴∠AEO=∠FEC=360∘−(180∘−2α)−45∘−(90∘+α)=45∘+α∴∠DEG=180∘−2×(45∘+α)=90∘−2α∵∠DEG=∠PCD∴∠HOC=∠KGC∵∠FEC=∠GEC∴CK=CH \\therefore \\angle PDO=90^\\circ-\\alpha,\\angle DPO=2\\alpha\\\\ \\therefore \\angle PCD=90^\\circ-2\\alpha\\\\ \\therefore \\angle POD=\\angle PCD+\\angle FDC=90^\\circ-\\alpha\\\\ \\therefore \\angle POD=\\angle PDO\\\\ \\therefore PD=PO\\\\ \\because \\angle APO=180^\\circ-2\\alpha,\\angle PAE=45^\\circ,\\angle POE=90^\\circ+\\alpha\\\\ \\therefore \\angle AEO=\\angle FEC=360^\\circ-(180^\\circ-2\\alpha)-45^\\circ-(90^\\circ+\\alpha)=45^\\circ+\\alpha\\\\ \\therefore \\angle DEG=180^\\circ-2\\times(45^\\circ+\\alpha)=90^\\circ-2\\alpha\\\\ \\because \\angle DEG=\\angle PCD\\\\ \\therefore \\angle HOC=\\angle KGC\\\\ \\because \\angle FEC=\\angle GEC\\\\ \\therefore CK=CH ∴∠PDO=90∘−α,∠DPO=2α∴∠PCD=90∘−2α∴∠POD=∠PCD+∠FDC=90∘−α∴∠POD=∠PDO∴PD=PO∵∠APO=180∘−2α,∠PAE=45∘,∠POE=90∘+α∴∠AEO=∠FEC=360∘−(180∘−2α)−45∘−(90∘+α)=45∘+α∴∠DEG=180∘−2×(45∘+α)=90∘−2α∵∠DEG=∠PCD∴∠HOC=∠KGC∵∠FEC=∠GEC∴CK=CH ∵\\because∵在△CHO\\triangle CHO△CHO与△CKG\\triangle CKG△CKG中： {∠CHO=∠CKG∠COH=∠CGKCH=CK∴△CHO≅△CKG(AAS)∴CO=CG∴CG:PD=CO:PO=7:5∵CG−PD=3∴CG=3÷(7−5)×7=10.5 \\begin{cases} \\angle CHO=\\angle CKG\\\\ \\angle COH=\\angle CGK\\\\ CH=CK\\\\ \\end{cases}\\\\ \\therefore \\triangle CHO\\cong\\triangle CKG(AAS)\\\\ \\therefore CO=CG\\\\ \\therefore CG:PD=CO:PO=7:5\\\\ \\because CG-PD=3\\\\ \\therefore CG=3\\div(7-5)\\times7=10.5 ⎩⎪⎨⎪⎧​∠CHO=∠CKG∠COH=∠CGKCH=CK​∴△CHO≅△CKG(AAS)∴CO=CG∴CG:PD=CO:PO=7:5∵CG−PD=3∴CG=3÷(7−5)×7=10.5 第二种 设PCPCPC与DFDFDF交于OOO，作CK⊥CDCK\\perp CDCK⊥CD于CCC，交DFDFDF延长线于KKK，设∠FDC=α\\angle FDC=\\alpha∠FDC=α ∴∠PDO=90∘−α,∠DPO=2α∴∠PCD=90∘−2α∴∠POD=∠PCD+∠FDC=90∘−α∴∠POD=∠PDO∴PD=PO∵CK⊥CD,PD⊥CD∴CK//PD∴∠KCO=2α,∠KOC=90∘−α∴CK=CO∴PD:CK=PO:CO=5:7∵∠ECG=45∘,CK⊥CD∴∠ECK=45∘=∠ECG \\therefore \\angle PDO=90^\\circ-\\alpha,\\angle DPO=2\\alpha\\\\ \\therefore \\angle PCD=90^\\circ-2\\alpha\\\\ \\therefore \\angle POD=\\angle PCD+\\angle FDC=90^\\circ-\\alpha\\\\ \\therefore \\angle POD=\\angle PDO\\\\ \\therefore PD=PO\\\\ \\because CK\\perp CD,PD\\perp CD\\\\ \\therefore CK//PD\\\\ \\therefore \\angle KCO=2\\alpha,\\angle KOC=90^\\circ-\\alpha\\\\ \\therefore CK=CO\\\\ \\therefore PD:CK=PO:CO=5:7\\\\ \\because \\angle ECG=45^\\circ,CK\\perp CD\\\\ \\therefore \\angle ECK=45^\\circ=\\angle ECG ∴∠PDO=90∘−α,∠DPO=2α∴∠PCD=90∘−2α∴∠POD=∠PCD+∠FDC=90∘−α∴∠POD=∠PDO∴PD=PO∵CK⊥CD,PD⊥CD∴CK//PD∴∠KCO=2α,∠KOC=90∘−α∴CK=CO∴PD:CK=PO:CO=5:7∵∠ECG=45∘,CK⊥CD∴∠ECK=45∘=∠ECG ∵\\because∵在△CEG\\triangle CEG△CEG与△CEK\\triangle CEK△CEK中： {∠CEG=∠CEKCE=CE∠ECG=∠ECK∴△CEG≅△CEK(ASA)∴CG=CK∴CG:PD=CK:PD=7:5∵CG−PD=3∴CG=3÷(7−5)×7=10.5 \\begin{cases} \\angle CEG=\\angle CEK\\\\ CE=CE\\\\ \\angle ECG=\\angle ECK\\\\ \\end{cases}\\\\ \\therefore \\triangle CEG\\cong\\triangle CEK(ASA)\\\\ \\therefore CG=CK\\\\ \\therefore CG:PD=CK:PD=7:5\\\\ \\because CG-PD=3\\\\ \\therefore CG=3\\div(7-5)\\times 7=10.5 ⎩⎪⎨⎪⎧​∠CEG=∠CEKCE=CE∠ECG=∠ECK​∴△CEG≅△CEK(ASA)∴CG=CK∴CG:PD=CK:PD=7:5∵CG−PD=3∴CG=3÷(7−5)×7=10.5 其实这道题并不算是一道很难的题，但我在考场上并没有做出来，看来还是我的水平下降了。。。 总之吃一堑长一智，以后再遇到这种乍一看有点复杂的几何题时，如果想不出来解法，还是先倒个角试试，说不定就成功了呢？ 最后一堂生物倒是不难，没有rxk说的那么毒瘤，个人感觉是这一天最有体验的一科了，但是把艾滋病毒寄生的细胞填错了，应该是淋巴细胞，我写的是免疫细胞不过要是老师改的水一点说不定能给我算对？ 晚自习把物理练习册拿出来全部看了一遍，然后又把英语卷子和单词表也看了一遍，觉得明天情况应该会好一点，因为这两科我都还是比较拿手。 Day 2（2020.5.29） 今天上午的英语要9点50才开考，所以在这之前我好好的把笔记全部看了一遍，又和前面的人聊了一会，然后匆匆忙忙地去了考场结果忘记了和同学借表 英语感觉还是不错吧，整体做下来都比较流畅没有什么不太确定的题，虽然倒数两道题都有点难，但是貌似几乎都做对了，作文比平时的要难一点点，让写一个你想保护的动物，给出两条理由，然后再写三条方法，我写的是熊猫，因为感觉这是最好写的。 考完后照例对了一下选择题，令人惊喜的是居然没有对出错误，而且发现很多人和我一样都是写的熊猫。感觉这次英语考得应该还行吧，希望能高一点，弥补一下其他几科（然并卵） 中午回去和室友一起关于这次考试聊了一中午，没有睡午觉。。。 下午物理感觉也还行，没有想象中的那么难，除了B卷选择题要稍微多想一下，其他就没什么很难的题了，最后一道压轴题居然也不难，就是道浮力入门题，连F浮=ρV浸gF_{\\text{浮}}=\\rho V_{\\text{浸}}gF浮​=ρV浸​g都没有用到，很简单，就是最后一问因为中途算错了一步，多花了点时间，别的都没什么好说的。一收完卷子，我右边那个人就跟我说我B卷选择题和他的完全一样（好家伙，这人趁收卷那会看我答案），然后把最后一道题对了一下，还是跟他一样的，就高兴地回教室了 回去以后才发现好像最后一个小问做出来的人还比较少，连csq巨佬貌似都没弄出来。我们组有两个人，一个在第一问就把数据看错了，导致后面两个小题的答案也错了，另一个在第二小题因为没有算物体受到的压力差，而是算压强差再乘受力面积，也做错了（那道题上下底面受力面积不一样，所以必须算压力差才行）。 听班主任说了几句话后，我们就背起书包回家了，这个周末居然没有作业，而且信竞课也不上，太好了，有时间打月赛了！ 最后估个分吧，等下周考试完了再来对比差距 语文 数学 英语 物理 地理 生物 总排 125 140 143 117 93 95 60 以下内容更新于6月5日 真实成绩 语文 数学 英语 物理 地理 生物 总排 126 139 145.5 120 96 86 3 感觉跟估的分数还是差不多吧，唯一就是生物考的差了点，不过老实说也在预料之中，但年排第三真的就有点出乎意料了啊，要是以前的考试这么差的成绩绝对拿不了前十的，尤其是语文和数学都没考好的情况下，还能拿到这个成绩，真的有点吃惊啊。。。 总结 这次考试总体来说不算特别好吧，因为两个主科都考砸了，地理生物也不是特别有把握，感觉这次的成绩虽然可能不算太差，但应该会很普通 究其原因，除了平时学习时放了些水外，恐怕就是我自己的心态问题了，没有在考前静心，导致语文考试本来两个选择题都是有概率做对的，判断成语使用对错里面的炙手可热其实我知道在那个语境里和它的本意不太一样，但最后还是脑抽选了另一个，病句题就更恼火了，如果不是一直纠结于好像在哪里看过那种说法，也不会傻到连缺宾语这种简单的问题都看不出来。所以说，这次考试的结果在很大程度上还是怪我自己这半个学期太浮躁了，没有踏踏实实地干活，总想着去耍，结果最后耍倒是耍的很开心，可学习却因此而颓废了 现在已经是初二下期了，如果继续这样浮躁下去，到初三恐怕我的境地会很艰难，到时候别说考七中，就连直升恐怕也拿不到奖学金了，还是要尽快把这个问题处理一下吧，到期末的时候希望能重新考个正儿八经的年级前十 期末考试的一些Flag 总分排在年级前十（10/10）√\\surd√ 语文127分以上（125/127） 数学145分左右（149/145）√\\surd√ 英语145分左右（143/145） 物理115分以上（120/115）√\\surd√ 政治历史90分左右（85/90，93/90）√\\surd√ 地理生物会考95分以上（100/95，100/95）√\\surd√ 题外话：关于入坑二次元 这个寒假，除了整Hexo和水犇犇之外，我其实还干了另外一件事——入坑二次元。 起因大概就是因为班上有些跟我还算比较熟的人一直在说超炮很好看，我自己也有所耳闻，所以大概是在1月11号，即正式放假的一天，我开始在B站上看超炮 说真的，当时应该是一下子就被吸引了吧，之前虽然也看过一些日漫（工作细胞、名柯），但我都没有这么喜欢过，于是不知不觉就看了一上午，然后就是走流程了，在一个月之内看完了超炮两季，魔禁三季，还有科方，可能有些肝帝不觉得有什么，但当时我爸妈对电子产品管的还是有点严的，虽然没到没收电脑手机的地步，但对时间的控制却一直很严格，所以这对我自己来说已经算是一个奇迹了 后来因为喜欢超炮，慢慢的开始了解一些有关二次元的东西，一开始也只是喜欢看超炮，后来慢慢地也开始看其他的了，第二部记得应该是辉夜告白。慢慢看到现在，五六个月的时间，一共只看了大概12部，但其实也还是给了我很多感受的吧 我觉得，日漫给我带来的不仅仅是一时的快乐，有时也会有一些人生的启发，或者说是一些想法吧，我想像当麻一样乐于助人，不求回报，我想像咲太那样冷静思考，善于交流，不在乎他人的看法，我还想像昴那样坚强，即使所有人都不看好，即使命运扼住了咽喉，也要一次又一次放手去拼…… 我还羡慕动漫里那些人过的生活，有一两个真正的朋友，能敞开心扉地聊感兴趣的话题，有真正关心自己的人，也有自己真正关心的人（父母除外），有相互都很信赖的伙伴，能作为彼此坚强的后盾 我觉得，我之所以看日漫，不仅仅是因为它确实好看，更是因为希望在日漫里找到一些自己在现实中所得不到的东西，虽然自己得不到，但能看看别人也总是好的，日漫之于我来说，或许已经超过了娱乐的范畴，而更像是一种寄托（可能说的太重了一点但大意就是这样）。因此，我对于那些说我看日漫只是纯粹喜欢里面的角色，甚至一些更【数据删除】的原因的人，才会很生气，甚至可以说是愤怒，他们很多人根本就不了解二次元这个领域，只是单纯的用外行人的眼光来看待，你不喜欢就算了，但请不要对我们指手画脚，每个人都有喜欢与不喜欢一个事物的权利，我尊重你的看法，但请不要用污言秽语来伤害我。就像一个根本不懂信竞的人，要用鄙视的语气说：“你们信竞不就是暴力出奇迹，打表出省一吗，有什么难的。”，或许别人能做到文明观猴，不在意别人说了什么，但我觉得，我做不到，尤其是对于自己所喜爱的东西，我更是要据理力争。 可能是性格使然吧，我在学校里感觉其实并没有真正的朋友，一个能保守秘密，能陪我聊天的人，这也不怪我那些同学，毕竟我聊的和他们都不一样，我喜欢信竞，也喜欢一些有关电脑的东西，但这些在班上很明显是与主流相悖的，所以在高中时，我是打算去读竞赛班的，而且是七中的竞赛班，因为在竞赛班搞竞赛感觉才比较“务正业”一点吧，而且也有那种氛围，能有人和我一起讨论信竞的东西。 扯远了，总之呢，希望我能在二次元的路上走得更远一点吧，但最重要的还是不能耽误学习，要尽量将两者结合起来才行，不然最后还是会被强制性停止的 累死我了，这篇文章是在5月29-30日写的，感觉内容还是很充实的吧，只可惜图片少了一点，以后有时间说不定会加点Emoji的，但在暑假前恐怕有点困难了","link":"/posts/520687165.html"},{"title":"2020年暑假集训日记","text":"⛅️7月16日 第一天集训！昨天晚上刚狂欢了一晚上其实也不过就是吃了顿好饭、捣鼓了会博客、看了会番而已，今天就又得穿上校服跑到学校去，还是有点不太爽。。。但既然是集训也还是比上文化课好多了 早上7点左右骑着车一路开到了学校，也不算去得太晚，大概是踩点到的，本来是计划先去食堂吃饭的，可一去发现里面人都没有，又不敢找人问，结果只好放弃了，没吃上早饭，饿了一上午。。。 到了原来集训过的3号机房，又发现里面坐的全是高中的，没敢进去问，只好在走廊里面转了几圈，最后终于遇到了一起集训的wgj，才知道这次改到了5号机房，坐下后发现开不了电脑，一直弹出什么没有影像输入，还是问了别人才知道电脑后面有一个按钮，要把那个按了才能开机，感觉自己好煞笔，一早上就这么倒霉，还不知道今天会有什么事情😂 原来的王老师不教我们了，换了一个姓祝的老师，整体还是有很多不一样吧，上课风格感觉完全是截然不同。竞赛班的人7月10号之后就开始集训了，学的比我们多多了，尤其是还有LCA，其他的都好对付，寒假时自学过，但那时候没学LCA，所以今天他们做的题搞都不太搞得懂，只能做我的最小生成树和最短路的作业，倒也做了不少，但他们竞赛班的却是早就做完了，看来还是得加把力才行 中午的时候跟着竞赛班的lyx终于找到了吃饭的地方，原来这儿的食堂还有个负一层，我早上来的时候只看了一楼就走了，怪不得没看见人😕 高中部的伙食真的比初中部好多了，而且餐厅也大得多，吃饭的时候还可以看新闻（乡巴佬进城了 中午回寝的时候也是lyx跟我们说了在哪栋宿舍，不然还要一栋一栋找。。。整个寝室只有我一个人，另外一个wgj说是出校去看眼睛什么的了，还有个不认识的好像要到18号才来。舍管比dp（人名）好多了不过八成是因为整层楼只有我一个人，给人的感觉要好很多啊。宿舍还是和上次来集训时一样，床下面还有桌子，可惜的是厕所里淋浴头还是和蹲坑的地方在一块的，心疼住校的同学三秒钟，哈哈哈 下午整体感觉和上午差不多，还是被竞赛班碾压的感觉，不过好在他们比我们离开得早，我们可以比他们多学几天 晚上去吃了盘火锅，把昨天晚上的一顿补上😁 回家后直接开始自学LCA，一次性整完了三种求法（倍增，Tarjan，RMQ+ST表），但感觉上还是前两种最好用 有点晚了，不写了，反正也没什么了，睡了吧 ⛅️7月17日 昨天下午下雨，所以没有把自行车骑回家，放在了学校，今天早上搭了个便车去学校，觉得没有必要带自行车钥匙所以就没管，结果走到半路突然想起来下午还得把车骑回家，这。。。 终于吃上早饭了，果然在负一楼，虽然很明显的高中部的伙食改善了一下，已经比初中部的要好吃多了，但早餐看来还是没变，江山易改，本性难移😶 上午终于可以开始做LCA的题了，用的最多的果然还是倍增，毕竟大部分题都没必要离线，而且我个人也更喜欢倍增一点，其他两种方法开的数组还是多了一点，影响整体的感觉 中午的时候wgj终于回来了，虽然我跟他不是一个班的，还有点生疏，也不说话，但有个认识的人在旁边总还是能感觉舒心一点，明天一定要记得把MP3带过去，不然中午睡觉还有点难办，现在不听歌反而有点难以入睡 下午为了调P2245花了整整一两个小时，最后发现是用倍增求LCA\\text{LCA}LCA的时候没有给log2n\\text{log2n}log2n赋值，也就是相当于只把u\\text{u}u调到了和v\\text{v}v一样的高度，但没有找他们的祖先，本来如果是LCA\\text{LCA}LCA模板题的话应给很容易看得出来，因为这样有一部分答案应该会错乱，但没想到这道题的样例给得水，而且又不是直接输出LCA\\text{LCA}LCA，所以就没检查出来，还是最后看代码的时候发现我定义了log2n\\text{log2n}log2n这个变量，但不记得给它赋了值才搞清楚的，整个下午就被这道题耗去了一半。。。😭 晚上晚自习之前跟旁边的lyx颓了一会generals，果然我不是玩PVP游戏的料，基本每次都被第一个干掉，但还是感觉很好玩 晚自习倒没什么说的了，不过lyx在我的影响下开始玩小黑屋了，不愧是”颓神“，上手新游戏就是快（雾 今天总体来说比昨天要平淡一点，但还是不错吧，希望明天会更好 ⛅️7月18日 今天早上又走的比较晚，到了学校后就没吃早饭，直接上机房颓废去了 上午讲了强连通分量，还好我暑假的时候已经自学过了，所以理解起来比较容易，而且老师布置的作业里面有几道题我已经做过了，进度是班上最快的，但因此他们也问了我很多问题，尤其是mjc，直接把我给绕晕了，根本没搞懂他在说什么，最后他还是找的老师才解决问题的，yzh更骚，有道题他把循环里面的一个字母打错了，还把我叫去和他一起找错，关键是看了半天还没看出来。。。😣 中午吃饭的时候发现学校居然真的改过自新了，排骨藕汤里面居然真的有一坨一坨的排骨！！！真的是头一回！！太阳从地里出来了！！😱 下午还是一样的做题，被P4819卡了一两个小时，最后发现是Tarjan里面有两个变量名打错了，真的有点自闭了，万一考试的时候再出这种问题怎么办。。。 晚上放假回家，捣鼓了一晚上博客，还是没整出个什么所以然来，Volantis更新pjax之后不知道为什么一直有些细节上的bug，所以也就一直没换，计划是等到beta这个东西给去掉后再换，不过目前在尝试了，有兴趣的同志可以看一下这里，用Coding整的临时站点 明天也是放假，终于可以体验一下暑假生活了！！🎉 ⛅️7月20日 感觉一天假根本没放够呢。。。😟 今天还是做题，但上午的时候教练讲了SPFA的优化，有两种，一种是SLF优化，一种是LLL优化，教练在网上找了一篇文章跟我们讲（这个风格和我们原来的教练不太一样，原来我们是看教练做好的PPT，但我个人其实更喜欢这种），看它说的多玄乎的，什么“一般用SLF+LLL可以优化50%左右”，结果我全部用上了交到P4779 【模板】单源最短路径（标准版）里面去还是要超时，虽然弱化版的是过了，但看来出题人是铁了心要让SPFA在棺材里待的安安稳稳的，绝不让他复活。。。 P1993 小 K 的农场终于过了，之前先是在解决差分约束的问题，把这玩意搞懂后打了一发代码还是全WA，最后发现是Bellman-Ford判环的时候把一个大于写成小于了。。。就这么个破玩意花了我整整一个半小时，还逼得我在机房里大声骂人，草 中午寝室里又来了个初一的，性格看来很开朗，但戒备心比较强，没能跟他搭上话，明天得试试 话说今天居然在机房里遇到了寒假认识的black_trees，虽然还没见到真人，只是确认了在一个机房而已，还没去找他，明天得找个时间见见真人（话说即使见了面好像也没什么可聊的。。。😐 下午的时候教练又给那些小学的（小学生跟我们学同样的内容，感觉自己被吊打了。。。）讲了树状数组，不得不说这玩意简直就是个天才的发明，比线段树还要牛，线段树虽然码量大，但其实基本思路是比较简单的，就是个分治，但树状数组光是想出来怎么把一个数组搞成一棵树，还要让它满足那么多规律就够厉害的了，还不说lowbit这玩意简直是神了，把计算机用补码储存数据的性质运用到了极致啊，太强了！ 另外，P3627 [APIO2009]抢掠计划真的是让人感觉很迷惑了，这玩意我的算法是对的，先缩点，然后在缩完点的图上跑最长路，于是我又手残，在打SPFA的时候加了一发优化，结果优化变成了劣化，T了一个点，然后把优化去掉，A了，这。。。 给你们康康我的代码 1234567891011121314151617181920212223242526272829303132333435while(q.size()){ int u=q.front(); q.pop_front(); num--; sum-=dis[u]; while(num&amp;&amp;dis[u]&lt;=sum/num)//LLL优化 { q.push_back(u); num++; sum+=dis[u]; u=q.front(); q.pop_front(); num--; sum-=dis[u]; } vis[u]=0; for(int i=0;i&lt;edge2[u].size();i++) { int v=edge2[u][i].first,c=edge2[u][i].second,k=q.front(); if(dis[v]&lt;dis[u]+c) { dis[v]=dis[u]+c; if(!vis[v]) { if(q.size()&amp;&amp;dis[v]&gt;dis[k])//SLF优化 q.push_front(v); else q.push_back(v); num++; sum+=dis[v]; } } }} 难道有什么问题吗？？？为什么优化反变劣化？？？给个解释？？？ 晚上的时候终于把所有强连通分量的题都做完了，不容易啊，八九道题肝了两三天了，还是我太菜了。。。😣 今天突然发现初一的比我们还要颓啊，最恼火的是颓generals的时候他们联合起来打我跟lyx，导致开局被秒，周围至少四个人在轮番打我们（好像一共才六个人。。。），后来我们不跟他们打了，我还是被lyx和yzh虐，但确实挺好玩的（没办法，我玩PVP就是不在行） 嗯，就这样吧，明天就看一下能不能把LCA和最短路剩下的几道题做一做，不过我还是很想上新课 ⛅️7月21日 今天真的做题做到崩了，早上又双叒叕没有吃早饭（因为在家里一直颓到了将近7点），一去就开始做最短路的题，恼火得不行，P2738 [USACO4.1]篱笆回路Fence Loops光是建图就让人极想砸电脑，照着题解改都改不对，一直整了一个半小时的样子才终于A掉，然后Johnson全源最短路的板子又卡了我几个小时，一直到下午才做完，最短路真的毒瘤，我的天哪。。。😩 中午的时候居然在打饭的窗口遇到了寒假在洛谷上认识的black_trees，当时他估计是看我跟lyx是初二的，就问我们认不认识一个洛谷用户名是线段树（Segment_Tree_）的（lyx居然说不知道，看来他的英语貌似不是那么好，我天天就坐他旁边都不知道），我当时就一惊，因为除了black_trees我还没有在洛谷上遇到其他初一的，结果当时我就直接告诉他我就是Segment_Tree_了（其实后来想想应该耍耍他的，不该那么早就告诉他。。），然后。。。就没有然后了，我跟lyx拿了饭就走了，也再没管他，直到晚自习的时候他才主动跑过来找我们😂 老实说black_trees的形象跟我在寒假时想象的不太一样啊，根据他在洛谷上的发言和他给我的私信来看，我本来觉得他是属于那种小男生的感觉，也就是类似于比较矮，然后看起来很聪明，有点。。。狡黠的那种吧，结果一见面才发现他居然比我还高一些，而且老实说长得有点。。。来者不善的感觉吧😨，当然这也只是我的第一印象罢了，还是不能以貌取人 不过最让我吃惊的是他居然也是个二次猿，这跟他给人的感觉一点都不像啊喂（不过我同样做为一个二次猿给人的感觉好像也很违和），而且他们还把机房里自己电脑的桌面设成二次元壁纸，这也太明目张胆了吧，不行，明天我得把我压箱底的壁纸拿去跟他们做个比拼​ 今天下午比上午要好点了，还好把最短路的作业都做完了，不然下午肯定也是崩溃的状态，一开始先是试着做了一道LCA的题，又做崩了，于是直接放弃，开始肝树状数组的作业了，还是这玩意简单些，一下午就做了五六道，不过我感觉树状数组还是没有线段树打起来那么爽，弄个区间最值那么麻烦（不过还是都没有ST表简单就是了），但毕竟人家码量小，空间小，常数小，没办法，以后还是能用树状数组的尽量少用线段树吧 晚上才是最爽的，有了yzh，hx，lyx三位颓废大神在旁边，整个晚自习直接木大，颓了一晚上的generals之类的游戏，lyx和yzh是真的不要脸，居然合伙欺负我这个萌新 明天还是不颓了吧，毕竟要以OI为重，而且这周好像还要考试（但愿不要和月赛冲突，再不打rated的比赛我咕值都要掉光了😭 ⛅️7月22日 今天总体来说应该是喜忧参半吧，上午倒还好，因为走得比昨天要早一点，所以吃上了早饭，到了机房后先做了两个树状数组的题，但中途还是参考了一下题解，然后开始肝一道线段树的蓝题，没什么特别难的，直接用线段树暴力维护了一下就好了，不过代码是真的难写（后来看了题解才发现其实是我想复杂了），尤其是那个懒标记的下传函数真的是把我弄惨了，虽然上午的时候没弄对，不过下午一来就发现了一个小bug，把它修了之后就AC了，总体来说比较平淡吧，唯一值得一提的是lyx唱歌实在是太难听了，关键是唱得还大声，我又不好直接跟他说，只好戴上耳机听自己的歌 下午可就惨了，教练给我们弄了一场膜你赛，说是什么普及组难度，结果前两题根本不是那么回事（当然也有可能是CSP-2019前两题太简单了导致我认为普及组的难度没有这么高），第一题的数据范围就把人整蒙了，不过还好可以一边输入一边处理，倒也A掉了，第二题就是个纯数学题，先去重，然后分别统计奇数和偶数的个数，再用乘法原理乱搞一通就好了（起码我是这么认为的），不过，最骚的操作在于，我把两个要去重的数组的第000位设为−1-1−1，这样就不怕统计不到第一个数字，结果。。。我在交代码的前一分钟把代码里的long long全部换成了unsigned long long，于是只得了可怜的606060分。。。第三题就更不用说了，我想出来那道题要用队列来整，但是我推的方法有bug，然后我在最后555分钟内写出了一组数据把我自己给hack了，于是第三题就这样愉快地爆零了，第四题方法应该是对的，关键是我把大样例都过了，最后还是只得了505050分，最后总分210210210，十四个人里排名第六。。。 这个结果其实也不能说是太差吧，只是有点普通罢了，但最让我接受不了的是lyx居然都得了300300300分。我平常虽然自诩不会以分数取人，但实际生活中可能还是有点犯了这个毛病，有时我其实不是很看得起lyx，觉得他也学了一两年OI了，怎么连一些基础操作（比如define，const）都不知道，而且觉得他做题动不动就去翻题解，不会仔细思考，慢慢的也就觉得他比较菜，可能还是我的傲气在作祟吧。但这次他居然比我整整高909090分，我觉得这应该是是我不能接受这次成绩的原因之一 总结一下，这次比赛也反映出我的一些问题，首先是策略不太得当，在最后一题上花的时间太多，但却没有得到相应的分数，反而让本来能得更多分的二三题丢了不少分，然后是太注重学习高级（当然也没高级到哪里去）数据结构，忽略了对于思维的训练，总想要打一发某种算法或数据结构的板子来解决问题，但一旦遇到需要动动脑子的思维题就根本做不起，而且做题量太少，这是我这一段时间的OI学习存在的一些问题，后面几天应该想想办法把它解决了 后面几天应该会写一篇这次比赛的总结和反思，但有点麻烦的在于我们是在auoj上评测的，而现在又找不到地方测改过后的代码，不过那几道题应该会展示在auoj上的，一定要把它们做对，不能欠账啊 唉，心里还是有点难受吧，不写了 ⛅️7月23日 今天上午一去就把昨天那四道题给做了，真心觉得自己好菜，第二题把unsigned去掉就AC了，第三题把代码按照我昨天最后一分钟想出来的思路一改就又A了，五分钟连过两题，我都差点以为评测机出问题了，然后第四题其实就是判断的时候错了，具体的就不多说了，等周末写总结的时候再来讲好了 然后其实就没什么必须要做的了，LCA作业剩下四道全都做不起，强连通分量作业做完了，最短路作业做完了，树状数组作业基本做完了，于是在智颓里找了两道比较水一点的来做，顺便吐槽一句，为什么这两天的智颓都是五蓝啊，还有什么树剖和网络瘤的题，洛谷真的以为我能做这些东西吗。。。 做完两道题之后，开始攻略两道紫题，一道是LCA，一道是线段树，最后直接耗了我将近六七个小时，主要是LCA那道题码量大，还综合了最短路和最小生成树，再加上思路又不是常人能想出来的，直接让我调到崩溃，一直过不了样例，最后发现是我建边的时候前后变量不统一，导致跑Dijkstra的时候用的是建好的最小生成树的图，我tm。。。 线段树就更恼火了，那道题是我以前没有见过的船新做法，用DFS序把树上问题转化成序列问题，然后用线段树维护区间，结果由于不熟练，导致读入数据出错，但样例又没检查出来，最后还是在lyx的建议下用对拍找出了问题 顺便说一句，随机数据生成程序是真的难写，但又是个不得不掌握的技能，只能多加练习了 去年的CSP-J一等奖证书终于到了，这效率。。。都快一年了才发过来。。。 今天发现一个很有趣的游戏，类似于猫国（不得不说最近玩过的几个游戏都很像猫国），一开始还有点生物的感觉，到后来其实完全就是个纯肝或是用连点器了，但真的很不错啊，整个设计也很完善，感觉可以玩很久的那种，不像小黑屋肝个两三天就通关了，把网址记在这里，想玩的同志可以试试：http://likexia.gitee.io/evolve/ （而且这玩意有很多不同的方向，每个方向还有所不同，比如我就是半兽人，但zy和lyx就是仙人掌） ⛅️7月24日 早上因为不注意身体，集训的时候水喝少了，运动少了被老妈训了一顿，还说我站着的时候脖子总是不由自主地往前伸，真的有点吓人，于是开始有意识地矫正，但真的很累啊，可能是因为我走路习惯低着头，久而久之脖子就习惯了往前探吧，但还是要注意了，不然仔细想想真的挺丑的 上午做题不太顺利，遇到一道卡常的题，老实说我觉得我的算法已经很优秀了，但还是有一个点T掉，连八聚氧和读入输出优化都没能救我，只好放弃了，本来想的是做几道线段树的题的，结果全都是些神仙题，没哪道做的来的，不过还是过了几道比较水的，而且教练布置的线段树作业也全都做完了（主要是寒假就已经自学完线段树了，而这个学期又一直在做题，所以作业里面大部分题我都早就做过了） 下午也没做几道题，颓进化去了，这玩意真心好玩，不过越到后面就越来越肝了 没什么好写的了，今天比较平淡，明天上午准备自学树剖，下午把月赛打了，希望我这次能拿到一个好名次，多涨点咕值，争取在8月2号之前红名 今天居然都24号了，离集训结束只有一周了，真的不想回归文化课啊啊啊。。。 ⛅️7月25日 今天又没吃上早饭，唉，算了，就当减肥了，反正一次两次，问题应该不大 上午的时候自学了树剖，个人感觉其实它的基础思想是挺简单的，用两次DFS处理出每个点的重儿子，然后把这些重儿子连起来，构成一条一条的链，链上的结点DFS序是连续的，这样就方便用线段树和其他一些数据结构来维护，老实说难倒是不难，就是很巧妙。但由于这玩意要结合其他数据结构，所以码量很大，模板直接170行，达到了前所未有的3KB，主要还是线段树和LCA的码量都不小，现在又要把他们两个结合起来。。。 下午全机房集体打洛谷月赛，而且教练还同意了，还帮我们调代码，讲思路（这tm算是物理外挂吗）！但就算是这样最后我还是只得了186分，主要是T2一直调不出来，对拍也拍不出来错误，只好打了一发暴力，加了个特判交上去，只得了50分，T1本来以为要用二分+快速幂，结果一直调不对，就按照他们的说法用pow代替快速幂交上去，居然还A了，关键是不知道为什么用快速幂就要WA，而且我那个还是快速幂模板直接复制过来的都要出错，我服了，真就玄学啊。T3和T4还是一如既往的做不出（不过赛后听有人说T3是树状数组求逆序对），不愧是我（雾 咕值就别想了，Div.1才200多名，Div.2都700多名去了，本来想的是好好打一下比赛看这个周末能不能变红名的，现在看来是很悬了 下午回家的时候忘记复制进化的存档了，今天白发展了。。。 晚上放假，回家看番。今天超炮居然又更新了，爷的青春回来了！RE0也好好看，E.M.T!\\color{purple}\\text{E.M.T!}E.M.T! ⛅️7月27日 又过了一个周末了，这周是最后一周集训了，唉😣 果然洛谷没有红名啊，不过咕值还是涨了16分，这周再努把力，肝几篇题解，下周估计就能红名了，人家black_trees没有成就分都上橙了，我应该也没问题的 上午的时候老师把我和lyx叫到了隔壁机房去，给我们讲了一下树剖，虽然我已经懂了，但还是认真地听了一下，毕竟万一有些老师讲的东西是我没有学到的就尴尬了，结果其实也差不多，不过还是给了我们一些题做 树剖的题是真心难写啊，虽然思想不难，很简单，但码量是真的大，洛谷的模板我都打了整整170多行，现在每天上午平均只能做3道题，有时还调不完，比如今天上午的最后一道P4315 月下“毛景树”，要求支持区间染色，区间加，区间查询，好家伙，代码差点突破200行，直接调了我几个小时，难受死了，关键一开始还要蜜汁RE，真的玄学，最后还是照着题解一行一行来检查才发现自己有一个地方，本来应该是id[x]的，我给打成了x。。。 下午教练又弄了一场膜你赛，题倒是很简单，T1字符串乱搞，T2煞笔动归，T3搜索板子，T4就一个最短路，但不知道为什么，可能是眼瞎了，题目中很多东西居然都给看漏了，比如T3和T4如果无法满足要求需要输出一行字，我给看漏了，还好后来检查出来了，不过T4居然还有多组数据，我都是临近结束时经同学提醒才看到的，简直是。。。关键是T3打了一发深搜居然还T了，没想到那道题一定要用广搜才行，真的是。。。最骚的是，T4明明说好N≤1000N\\le1000N≤1000的，结果lyx打了一发Floyd板子居然过了，这tm是个什么情况啊啊啊，而且我的Dijkstra还WA了两个点。。。 晚上把调对了P4315调对了之后就开始颓废了，果然还是放不下昨天晚上看的中二病啊，真的太好看了（记得把中途执笔的老虚给我按得死死的，别让他拿到笔），六花和勇太的糖也太甜了吧！！！而且六花好可爱啊！！！😆 不过老实说，这部番还是给我带来了一些想法吧，而且里面有些台词真的说得好好啊，我们很多人所追求的普通，合群，其实都不过是建立在他人的基础之上的，有时为了和他人一样，还不得不压抑自己的个性，但这样真的好吗，虽然我们得到了想要的所谓友谊，但那些真的都是真实的吗，如果人没有了个性，那么每个人都一模一样，这样的世界真的有意义吗，每个人都是特殊的，凭什么非要按照别人的想法去塑造自己呢，你又不是为了别人而活的，当然以上言论只适用于不影响他人的范畴，如果你想以此来作为自己搞事情的借口，那我觉得这是很不恰当的（以上纯属博主的胡思乱想，请勿当真） 扯多了扯多了，好了，没什么可说的了，那就晚安吧 ⛅️7月28日 啊，今天也太爽了！早上一到机房就开始接着做树剖的作业，而且出人意料的顺利，每次基本都是打完之后用样例调一下，把一些小错误改过来就A掉了，甚至有的居然能一遍过，再加上不知道为什么手速变得快了许多，一上午居然前所未有的做了六道树剖，而且除了四道蓝题外，居然还有两道紫题也很快就A掉了，不过第一道紫题真的很恼火，居然要求支持区间染色和查询区间内颜色的段数，可把我整惨了，中途都打自闭了好几次，虽然最后还是交了两三遍就过了，但整个代码居然都超过了200行，真的不可思议啊！！ 下午花了一个小时把剩下的两道题给做了，然后就闲着没事做了，颓了一会，做了一会初一的搜索题，两个小时就过去了。中途教练过来跟我和lyx说，把树剖学完之后，再把树形和状压DP学了，再补一些数论知识，NOIP内容就基本弄完了，当时真的把我吓了一跳，本来以为离NOIP还有很长的距离要走，没想到突然就到头了，怕不是教练高估了我们的水平哦，我确实是在寒假的时候自学了一些内容，而且正好和这几天集训的内容相同，估计教练就以为我已经学了很多了，不过也不清楚，也有可能我想的太多了，总之只能走一步看一步了，但接下来的任务可就艰巨了，DP是我最讨厌的几种算法之一（另外还有贪心这种），而且对于自己的数论知识我其实也没有太多的把握，可能到时候学起来就会困难一些（lyx肯定就要爆踩我了） 顺便提一句，今天学校的伙食真的好好吃啊，早上的面条虽然看着有点像粉丝，但味道是真心好，比初中部那个所谓的干拌面好吃多了，中午和晚上的菜也大有长进，难道学校真的痛定思痛，下定决心要改变了吗（不过我估计可能是因为这几天集训，而且人比较少），真的有点不可思议啊 晚上还是老规矩，看番，今天把中二病第一季看完了，真的很好看啊，在这里把里面的一段话记录一下 大家都说“中二病太让人难为情了” 还说“好想把那段记忆都删除掉，永远不要想起来” 但是，当初那个古古怪怪的自己，真的会消失吗 那个总是妄想自己被人监视 那个给自己设定了角色，并化身为那个角色的自己…… 人有时候总是会夸夸其谈，梦想着突然改变的世界，在脑海里想象着遥远的未来，想象那不存在的，轰轰烈烈的爱情 那就是 从生至死 在人的内心不断复发 永远无法痊愈的 有些伤感 有些害羞 却又可爱的 名为“自我意识过剩”的病症 是一种名为“自我”的，谁都无法回避的人生 没错 人啊 一辈子都是中二病 感觉真的很有道理吧 ，虽然我们最后可能因为一些原因不得不成为一个平凡的普通人，但原来的那个自己是永远不会消失的，我们的个性，永远都存在于我们心里啊 话说如果我几年以后再看到这一段会不会也觉得很羞耻 ⛅️7月29日 今天一整天都感觉很不在状态啊，早上去了先是做教练布置的搜索的题，结果发现自己很多东西好像都忘光了，打起代码来还有点吃力，虽然速度也还是可以，但真的状态很差，又困又累，一点也不想做题，可能是昨天晚上没有睡好的原因吧，而且今天早上也起来迟了，不过最让人恼火的还是有一道题死活都过不去，明明只是一道BFS板子题，结果交了将近十遍都没过，一开始我先打了一发DFS，T了，然后又换成了BFS，结果没想到它又提示我超内存，明明那道题的范围一点也不大，而且按照我的代码来看每个点又只会被遍历一次，所以理论上空间复杂度是O(n)O(n)O(n)的，而且也没有递归调用，是真的不知道哪里错了啊，没办法，我又把STL的queue换成了手打队列，这次居然WA了，而且它也没提示我爆内存，这。。。总之那道题我到现在还没做对（老实说也不想做了），真的是很恼火 中午因为和旁边的人颓generals，没去吃午饭，所以和lyx一起去了趟小卖部，花了他7块钱，明天得给他补上才行 下午还是要死不活的状态，也不知道怎么回事，题也没做几道，快四点的时候，教练又把我和lyx交到隔壁机房，给我们讲了树形DP，虽然lyx树剖还没做完，但教练让他八月份回家再做（估计是怕他一直拖下去到8月2号都做不完）。树形DP是真的难受，本来我对于DP和贪心这一类算法就不是很擅长，总是搞不懂状态转移方程怎么整，有时甚至看了题解也没搞懂，更别说树形DP了，这玩意和树剖简直是两个极端，一个思路简单，码量大，一个码量小，思路复杂（不过估计应该也会有码量又大思路又复杂的毒瘤算法），可把我整惨了，不过也没什么办法，毕竟DP是个很重要的算法，只能靠多做题来巩固了。。。 昨天lyx又写了篇题解，但是没过，我看了一下，真的是NB，不仅树链剖分的“树”写成了“数”，而且还说树剖是通过把“一张图”转化成链用数据结构维护，而且代码也没有注释，说真的，这玩意要是过了才有点迷惑 晚上一个竞赛班的人把红警带到我们机房，瞬间掀起了一股热潮，我们那一排至少有五六个人在颓红警，我本来还说看番的，但玩了两把之后真的有点上头了，主要是那玩意真的太爽了，即使是一向不擅长这种游戏的我也没能抵挡住诱惑，因为我平时一般很少玩这种竞技类的游戏，大部分时候都是玩比较养生的那种，但这个感觉还有点不一样，总之就是很好玩啦 今天晚上还是早点睡吧，希望明天能有个好点的状态 ⛅️7月30日 今天状态比昨天要好一点了，没有那么困了，其他的感觉都差不多，上午和下午还是都在做题，树形DP真的太难受了，虽然确实比线性DP要好想一点，但只要难度一上去，其实都差不多，完全做不出来，今天其实还好，做题速度比较快，主要是那些题的难度都不算特别大，只有个别几道很难，尤其是有一道IOI的题，真的是不看题解完全做不出来，看了题解也要花好些时间才能搞懂它在做什么，不过好在题目不多，今天下午就把树形DP的作业做完了，然后又开始跟着新初二的做DP的综合训练，真的是太恼火了，连个绿题我都不容易做出来，果然DP是我的死穴啊 午饭和晚饭都没吃，中午是因为和他们一起颓废，没吃成，下午是改题改过了时间，所以也没去吃，不过现在居然感觉不太饿，真的是很奇怪啊 晚上还是老规矩，颓红警，不过现在越来越觉得这玩意没意思了，主要是它本来的设定是PVP游戏，但现在完全被我玩成了PVE，因为和他们联机完全打不过啊，只能和最简单的人机打（就算是这样我有时都会GG），明天晚上估计不会再颓这东西了吧 emmm，好像没什么事情了，那就睡了吧 ⛅️7月31日 今天。。。没什么可说的啊，还是一整天都在做DP的题，这玩意简直是太难受了，我一上午才做了两道，不过感觉其实还是有一丢丢进步了吧，有好几道题的DP方程都是自己给整对的，没有看题解，虽然都不算是很难的题，但还是让人感觉很高兴吧，毕竟之前除了背包和一小部分区间DP以及几道线性DP的入门题外，其他的好像就没有几道是我自己做出来的了，这玩意真的是我的短板啊 不知道为什么，突然感觉那些游戏好像都没有什么意思了，也不是很想颓了，只有今天晚上打了一个小时的红警，看了几集中二病，难道是因为要离开了，所以觉得有点难过吗（不过八成是因为DP把自己给做自闭了 老实说，现在感觉越来越烦lyx了，做题的时候动不动就打开题解，也不说自己先思考一下，教练说每次看题要先思考三十分钟，确定自己完全是没有思路了在看题解时他还很惊讶，学了将近两年OI了，连一些基本的操作都搞不懂，总是想着问别人，也不会自己上网去查，感觉真的很烦啊，也不是很会考虑别人的感受，有时真的让我感觉很气，明明我在那里想DP方程都快自闭了，他还在那里哼歌，让我根本没法仔细思考啊。唉，不过也有可能是他的性格和我的标准不相符合吧，毕竟每个人有每个人的个性，也不能老是以自我为中心啊 中二病真的是太好看了！甜到了！ 明天集训就结束了，感觉喜忧参半吧，毕竟后面就要开始做文化课作业了嘛，还是不太爽，但也没有办法，没有不散的宴席嘛，再说又不是要退役了，也没有必要太难受。不过教练说明天会给我们来一场欢乐赛，两个半小时，13道题，IOI赛制，还有奖品，希望能多拿点分吧 ⛅️8月1日 今天很爽啊，早上一去先颓了一会，然后开始打欢乐赛，之前本来以为这个欢乐赛是一些比较正经的题，比如什么搜索啊，DP啊，结果，第一题就把我们给震惊了，给你一个exe文件，让你输出答案，告诉你答案就在exe文件里，结果打开一看，居然是个单词接龙的游戏？！本来还以为是把那玩意用编辑器打开就会看到些什么了，结果根本没有，就是让你把这个游戏打通，也就是让这个程序没法用没用过的单词接龙就算赢了，我最后玩了半个小时都没结束，结果后来出题人说是有策略的，因为在英语中，以x开头的单词是最少的，所以就要尽量让它用x开头的单词来接，这样赢得最快，他还试验了一下，只用了不到两分钟就打通了。。。还有一题，居然给了我们一个HTML，让我们把里面的javascript看懂，然后用C++实现同样的功能，我在洛谷上发了个帖子，有人告诉我是一个叫exgcd的东西，我还搜出了那东西的模板，是一道什么二元一次不定方程，但因为输入输出格式没搞懂，也没办法直接抄过去，还好我们机房里有个会一点javascript的大佬，给我们解决了几个问题以后，我就直接在那玩意的基础上改了一下，就过了，总之这个欢乐赛里头基本都是这些不正经的题，照我来看，这玩意要是再毒瘤一点，就快赶上洛谷愚人节赛了（顺便说一句，这次欢乐赛居然是zjk和另外两个大佬给我们出的题！！ 下午没什么事可做了，滑了一会水，教练就开始给我们发奖品，我这次总共拿了450分，其实也还是算不错的了，毕竟我们机房里没上400还有一大堆呢，最后拿了一根棒棒糖，一瓶可乐，一袋薯片，本来四点钟左右就放学了的，我们又在机房颓了一个小时多才回去 晚上接着看番，把中二病看完了，真的好看，以后可能还会二刷吧 🌞结语 结束了呢。 这次集训感觉算是比较难忘的一次了，毕竟换了一个教练，整个感觉也不一样了，而且还跟新初二的学弟们一起集训（当然还有几个神仙小学生）。不过让我印象最深的，还是截然不同的教练的上课风格，之前的那个教练，总是用自己做好的PPT来给我们讲课，做的题也都是在她整理出来的word文档上，虽然也有在洛谷上刷题，但也是在课余时间，而现在这个教练，更注重于网上资源的搜集（大概就是这个意思吧，我语文不太好），总是让我们在洛谷，vjudge上刷题，有时候讲课的资料甚至还是别人写的学习笔记，其实我觉得还是后者要更好一点吧，因为我们信息学竞赛生跟其他的不太一样，要借助电脑才能刷题，学习当然你也可以尝试手写代码，所以既然网上有那么多资源，而且质量也基本能得到保证，那么为什么不拿来用呢，当然也不是说之前那个教练的做法就不对了，只是我个人更喜欢现在这种罢了 总的来说呢，这十多天时间里还是学到了很多东西吧，LCA，树状数组，树链剖分，树形DP，能力也还是提高了一些，但感觉颓废的时间还是多了一些，希望以后能注意吧 老实说，集训结束了，还是有点难过吧，毕竟没办法和OI天天呆在一块了，也不能像这十几天一样天天刷题了，要回归文化课，心情还是有点低落吧，但也没办法，OI是要搞，文化课也不能落下，我毕竟还不是个竞赛班学生，文化课对我来说还是很重要的，尤其是这次期末文科出了些问题，更应该好好补补，所以，加油吧！ 话说怎么感觉搞得跟要退役了似的","link":"/posts/1160748433.html"},{"title":"Emoji一览表","text":"这张表用来便于预览和复制Emoji语法，源地址 People 预览 语法 预览 语法 预览 语法 :bowtie: :bowtie: 😄 :smile: 😃 :smiley: ☺️ :relaxed: 😏 :smirk: 😍 :heart_eyes: 😘 :kissing_heart: 😚 :kissing_closed_eyes: 😳 :flushed: 😌 :relieved: 😆 :satisfied: 😁 :grin: 😉 :wink: 😜 :stuck_out_tongue_winking_eye: 😝 :stuck_out_tongue_closed_eyes: 😀 :grinning: 😗 :kissing: 😙 :kissing_smiling_eyes: 😛 :stuck_out_tongue: 😴 :sleeping: 😟 :worried: 😧 :anguished: 😮 :open_mouth: 😬 :grimacing: 😕 :confused: 😯 :hushed: 😑 :expressionless: 😒 :unamused: 😅 :sweat_smile: 😓 :sweat: 😥 :disappointed_relieved: 😩 :weary: 😔 :pensive: 😞 :disappointed: 😖 :confounded: 😨 :fearful: 😰 :cold_sweat: 😣 :persevere: 😢 :cry: 😭 :sob: 😂 :joy: 😲 :astonished: 😱 :scream: :neckbeard: :neckbeard: 😫 :tired_face: 😠 :angry: 😡 :rage: 😤 :triumph: 😪 :sleepy: 😋 :yum: 😷 :mask: 😎 :sunglasses: 😵 :dizzy_face: 👿 :imp: 😈 :smiling_imp: 😐 :neutral_face: 😶 :no_mouth: 😇 :innocent: 👽 :alien: 💛 :yellow_heart: 💙 :blue_heart: 💜 :purple_heart: ❤️ :heart: 💚 :green_heart: 💔 :broken_heart: 💓 :heartbeat: 💗 :heartpulse: 💕 :two_hearts: 💞 :revolving_hearts: 💘 :cupid: 💖 :sparkling_heart: ✨ :sparkles: ⭐️ :star: 🌟 :star2: 💫 :dizzy: 💥 :collision: 💢 :anger: ❗️ :exclamation: ❓ :question: ❕ :grey_exclamation: ❔ :grey_question: 💤 :zzz: 💨 :dash: 💦 :sweat_drops: 🎶 :notes: 🎵 :musical_note: 🔥 :fire: 💩 :hankey: 💩 :poop: 💩 :shit: 👍 :+1: 👍 :thumbsup: 👎 :-1: 👎 :thumbsdown: 👌 :ok_hand: 👊 :punch: 👊 :facepunch: ✊ :fist: ✌️ :v: 👋 :wave: ✋ :hand: ✋ :raised_hand: 👐 :open_hands: ☝️ :point_up: 👇 :point_down: 👈 :point_left: 👉 :point_right: 🙌 :raised_hands: 🙏 :pray: 👆 :point_up_2: 👏 :clap: 💪 :muscle: 🤘 :metal: 🖕 :fu: 🏃 :runner: 🏃 :running: 👫 :couple: 👪 :family: 👬 :two_men_holding_hands: 👭 :two_women_holding_hands: 💃 :dancer: 👯 :dancers: 🙆 :ok_woman: 🙅 :no_good: 💁 :information_desk_person: 🙋 :raising_hand: 👰 :bride_with_veil: 🙎 :person_with_pouting_face: 🙍 :person_frowning: 🙇 :bow: :couplekiss: :couplekiss: 💑 :couple_with_heart: 💆 :massage: 💇 :haircut: 💅 :nail_care: 👦 :boy: 👧 :girl: 👩 :woman: 👨 :man: 👶 :baby: 👵 :older_woman: 👴 :older_man: 👱 :person_with_blond_hair: 👲 :man_with_gua_pi_mao: 👳 :man_with_turban: 👷 :construction_worker: 👮 :cop: 👼 :angel: 👸 :princess: 😺 :smiley_cat: 😸 :smile_cat: 😻 :heart_eyes_cat: 😽 :kissing_cat: 😼 :smirk_cat: 🙀 :scream_cat: 😿 :crying_cat_face: 😹 :joy_cat: 😾 :pouting_cat: 👹 :japanese_ogre: 👺 :japanese_goblin: 🙈 :see_no_evil: 🙉 :hear_no_evil: 🙊 :speak_no_evil: 💂 :guardsman: 💀 :skull: 🐾 :feet: 👄 :lips: 💋 :kiss: 💧 :droplet: 👂 :ear: 👀 :eyes: 👃 :nose: 👅 :tongue: 💌 :love_letter: 👤 :bust_in_silhouette: 👥 :busts_in_silhouette: 💬 :speech_balloon: 💭 :thought_balloon: :feelsgood: :feelsgood: :finnadie: :finnadie: :goberserk: :goberserk: :godmode: :godmode: :hurtrealbad: :hurtrealbad: :rage1: :rage1: :rage2: :rage2: :rage3: :rage3: :rage4: :rage4: :suspect: :suspect: :trollface: :trollface: Nature 预览 语法 预览 语法 预览 语法 ☀️ :sunny: ☔️ :umbrella: ☁️ :cloud: ❄️ :snowflake: ⛄️ :snowman: ⚡️ :zap: 🌀 :cyclone: 🌁 :foggy: 🌊 :ocean: 🐱 :cat: 🐶 :dog: 🐭 :mouse: 🐹 :hamster: 🐰 :rabbit: 🐺 :wolf: 🐸 :frog: 🐯 :tiger: 🐨 :koala: 🐻 :bear: 🐷 :pig: 🐽 :pig_nose: 🐮 :cow: 🐗 :boar: 🐵 :monkey_face: 🐒 :monkey: 🐴 :horse: 🐎 :racehorse: 🐫 :camel: 🐑 :sheep: 🐘 :elephant: 🐼 :panda_face: 🐍 :snake: 🐦 :bird: 🐤 :baby_chick: 🐥 :hatched_chick: 🐣 :hatching_chick: 🐔 :chicken: 🐧 :penguin: 🐢 :turtle: 🐛 :bug: 🐝 :honeybee: 🐜 :ant: 🐞 :beetle: 🐌 :snail: 🐙 :octopus: 🐠 :tropical_fish: 🐟 :fish: 🐳 :whale: 🐋 :whale2: 🐬 :dolphin: 🐄 :cow2: 🐏 :ram: 🐀 :rat: 🐃 :water_buffalo: 🐅 :tiger2: 🐇 :rabbit2: 🐉 :dragon: 🐐 :goat: 🐓 :rooster: 🐕 :dog2: 🐖 :pig2: 🐁 :mouse2: 🐂 :ox: 🐲 :dragon_face: 🐡 :blowfish: 🐊 :crocodile: 🐪 :dromedary_camel: 🐆 :leopard: 🐈 :cat2: 🐩 :poodle: 🐾 :paw_prints: 💐 :bouquet: 🌸 :cherry_blossom: 🌷 :tulip: 🍀 :four_leaf_clover: 🌹 :rose: 🌻 :sunflower: 🌺 :hibiscus: 🍁 :maple_leaf: 🍃 :leaves: 🍂 :fallen_leaf: 🌿 :herb: 🍄 :mushroom: 🌵 :cactus: 🌴 :palm_tree: 🌲 :evergreen_tree: 🌳 :deciduous_tree: 🌰 :chestnut: 🌱 :seedling: 🌼 :blossom: 🌾 :ear_of_rice: 🐚 :shell: 🌐 :globe_with_meridians: 🌞 :sun_with_face: 🌝 :full_moon_with_face: 🌚 :new_moon_with_face: 🌑 :new_moon: 🌒 :waxing_crescent_moon: 🌓 :first_quarter_moon: 🌔 :waxing_gibbous_moon: 🌕 :full_moon: 🌖 :waning_gibbous_moon: 🌗 :last_quarter_moon: 🌘 :waning_crescent_moon: 🌜 :last_quarter_moon_with_face: 🌛 :first_quarter_moon_with_face: 🌙 :crescent_moon: 🌍 :earth_africa: 🌎 :earth_americas: 🌏 :earth_asia: 🌋 :volcano: 🌌 :milky_way: ⛅️ :partly_sunny: :octocat: :octocat: :squirrel: :squirrel: Objects 预览 语法 预览 语法 预览 语法 🎍 :bamboo: 💝 :gift_heart: 🎎 :dolls: 🎒 :school_satchel: 🎓 :mortar_board: 🎏 :flags: 🎆 :fireworks: 🎇 :sparkler: 🎐 :wind_chime: 🎑 :rice_scene: 🎃 :jack_o_lantern: 👻 :ghost: 🎅 :santa: 🎄 :christmas_tree: 🎁 :gift: 🔔 :bell: 🔕 :no_bell: 🎋 :tanabata_tree: 🎉 :tada: 🎊 :confetti_ball: 🎈 :balloon: 🔮 :crystal_ball: 💿 :cd: 📀 :dvd: 💾 :floppy_disk: 📷 :camera: 📹 :video_camera: 🎥 :movie_camera: 💻 :computer: 📺 :tv: 📱 :iphone: ☎️ :phone: ☎️ :telephone: 📞 :telephone_receiver: 📟 :pager: 📠 :fax: 💽 :minidisc: 📼 :vhs: 🔉 :sound: 🔈 :speaker: 🔇 :mute: 📢 :loudspeaker: 📣 :mega: ⌛️ :hourglass: ⏳ :hourglass_flowing_sand: ⏰ :alarm_clock: ⌚️ :watch: 📻 :radio: 📡 :satellite: ➿ :loop: 🔍 :mag: 🔎 :mag_right: 🔓 :unlock: 🔒 :lock: 🔏 :lock_with_ink_pen: 🔐 :closed_lock_with_key: 🔑 :key: 💡 :bulb: 🔦 :flashlight: 🔆 :high_brightness: 🔅 :low_brightness: 🔌 :electric_plug: 🔋 :battery: 📲 :calling: ✉️ :email: 📫 :mailbox: 📮 :postbox: 🛀 :bath: 🛁 :bathtub: 🚿 :shower: 🚽 :toilet: 🔧 :wrench: 🔩 :nut_and_bolt: 🔨 :hammer: 💺 :seat: 💰 :moneybag: 💴 :yen: 💵 :dollar: 💷 :pound: 💶 :euro: 💳 :credit_card: 💸 :money_with_wings: 📧 :e-mail: 📥 :inbox_tray: 📤 :outbox_tray: ✉️ :envelope: 📨 :incoming_envelope: 📯 :postal_horn: 📪 :mailbox_closed: 📬 :mailbox_with_mail: 📭 :mailbox_with_no_mail: 📦 :package: 🚪 :door: 🚬 :smoking: 💣 :bomb: 🔫 :gun: 🔪 :hocho: 💊 :pill: 💉 :syringe: 📄 :page_facing_up: 📃 :page_with_curl: 📑 :bookmark_tabs: 📊 :bar_chart: 📈 :chart_with_upwards_trend: 📉 :chart_with_downwards_trend: 📜 :scroll: 📋 :clipboard: 📆 :calendar: 📅 :date: 📇 :card_index: 📁 :file_folder: 📂 :open_file_folder: ✂️ :scissors: 📌 :pushpin: 📎 :paperclip: ✒️ :black_nib: ✏️ :pencil2: 📏 :straight_ruler: 📐 :triangular_ruler: 📕 :closed_book: 📗 :green_book: 📘 :blue_book: 📙 :orange_book: 📓 :notebook: 📔 :notebook_with_decorative_cover: 📒 :ledger: 📚 :books: 🔖 :bookmark: 📛 :name_badge: 🔬 :microscope: 🔭 :telescope: 📰 :newspaper: 🏈 :football: 🏀 :basketball: ⚽️ :soccer: ⚾️ :baseball: 🎾 :tennis: 🎱 :8ball: 🏉 :rugby_football: 🎳 :bowling: ⛳️ :golf: 🚵 :mountain_bicyclist: 🚴 :bicyclist: 🏇 :horse_racing: 🏂 :snowboarder: 🏊 :swimmer: 🏄 :surfer: 🎿 :ski: ♠️ :spades: ♥️ :hearts: ♣️ :clubs: ♦️ :diamonds: 💎 :gem: 💍 :ring: 🏆 :trophy: 🎼 :musical_score: 🎹 :musical_keyboard: 🎻 :violin: 👾 :space_invader: 🎮 :video_game: 🃏 :black_joker: 🎴 :flower_playing_cards: 🎲 :game_die: 🎯 :dart: 🀄️ :mahjong: 🎬 :clapper: 📝 :memo: 📝 :pencil: 📖 :book: 🎨 :art: 🎤 :microphone: 🎧 :headphones: 🎺 :trumpet: 🎷 :saxophone: 🎸 :guitar: 👞 :shoe: 👡 :sandal: 👠 :high_heel: 💄 :lipstick: 👢 :boot: 👕 :shirt: 👕 :tshirt: 👔 :necktie: 👚 :womans_clothes: 👗 :dress: 🎽 :running_shirt_with_sash: 👖 :jeans: 👘 :kimono: 👙 :bikini: 🎀 :ribbon: 🎩 :tophat: 👑 :crown: 👒 :womans_hat: 👞 :mans_shoe: 🌂 :closed_umbrella: 💼 :briefcase: 👜 :handbag: 👝 :pouch: 👛 :purse: 👓 :eyeglasses: 🎣 :fishing_pole_and_fish: ☕️ :coffee: 🍵 :tea: 🍶 :sake: 🍼 :baby_bottle: 🍺 :beer: 🍻 :beers: 🍸 :cocktail: 🍹 :tropical_drink: 🍷 :wine_glass: 🍴 :fork_and_knife: 🍕 :pizza: 🍔 :hamburger: 🍟 :fries: 🍗 :poultry_leg: 🍖 :meat_on_bone: 🍝 :spaghetti: 🍛 :curry: 🍤 :fried_shrimp: 🍱 :bento: 🍣 :sushi: 🍥 :fish_cake: 🍙 :rice_ball: 🍘 :rice_cracker: 🍚 :rice: 🍜 :ramen: 🍲 :stew: 🍢 :oden: 🍡 :dango: 🥚 :egg: 🍞 :bread: 🍩 :doughnut: 🍮 :custard: 🍦 :icecream: 🍨 :ice_cream: 🍧 :shaved_ice: 🎂 :birthday: 🍰 :cake: 🍪 :cookie: 🍫 :chocolate_bar: 🍬 :candy: 🍭 :lollipop: 🍯 :honey_pot: 🍎 :apple: 🍏 :green_apple: 🍊 :tangerine: 🍋 :lemon: 🍒 :cherries: 🍇 :grapes: 🍉 :watermelon: 🍓 :strawberry: 🍑 :peach: 🍈 :melon: 🍌 :banana: 🍐 :pear: 🍍 :pineapple: 🍠 :sweet_potato: 🍆 :eggplant: 🍅 :tomato: 🌽 :corn: Places 预览 语法 预览 语法 预览 语法 🏠 :house: 🏡 :house_with_garden: 🏫 :school: 🏢 :office: 🏣 :post_office: 🏥 :hospital: 🏦 :bank: 🏪 :convenience_store: 🏩 :love_hotel: 🏨 :hotel: 💒 :wedding: ⛪️ :church: 🏬 :department_store: 🏤 :european_post_office: 🌇 :city_sunrise: 🌆 :city_sunset: 🏯 :japanese_castle: 🏰 :european_castle: ⛺️ :tent: 🏭 :factory: 🗼 :tokyo_tower: 🗾 :japan: 🗻 :mount_fuji: 🌄 :sunrise_over_mountains: 🌅 :sunrise: 🌠 :stars: 🗽 :statue_of_liberty: 🌉 :bridge_at_night: 🎠 :carousel_horse: 🌈 :rainbow: 🎡 :ferris_wheel: ⛲️ :fountain: 🎢 :roller_coaster: 🚢 :ship: 🚤 :speedboat: ⛵️ :boat: ⛵️ :sailboat: 🚣 :rowboat: ⚓️ :anchor: 🚀 :rocket: ✈️ :airplane: 🚁 :helicopter: 🚂 :steam_locomotive: 🚊 :tram: 🚞 :mountain_railway: 🚲 :bike: 🚡 :aerial_tramway: 🚟 :suspension_railway: 🚠 :mountain_cableway: 🚜 :tractor: 🚙 :blue_car: 🚘 :oncoming_automobile: 🚗 :car: 🚗 :red_car: 🚕 :taxi: 🚖 :oncoming_taxi: 🚛 :articulated_lorry: 🚌 :bus: 🚍 :oncoming_bus: 🚨 :rotating_light: 🚓 :police_car: 🚔 :oncoming_police_car: 🚒 :fire_engine: 🚑 :ambulance: 🚐 :minibus: 🚚 :truck: 🚋 :train: 🚉 :station: 🚆 :train2: 🚅 :bullettrain_front: 🚄 :bullettrain_side: 🚈 :light_rail: 🚝 :monorail: 🚃 :railway_car: 🚎 :trolleybus: 🎫 :ticket: ⛽️ :fuelpump: 🚦 :vertical_traffic_light: 🚥 :traffic_light: ⚠️ :warning: 🚧 :construction: 🔰 :beginner: 🏧 :atm: 🎰 :slot_machine: 🚏 :busstop: 💈 :barber: ♨️ :hotsprings: 🏁 :checkered_flag: 🎌 :crossed_flags: 🏮 :izakaya_lantern: 🗿 :moyai: 🎪 :circus_tent: 🎭 :performing_arts: 📍 :round_pushpin: 🚩 :triangular_flag_on_post: 🇯🇵 :jp: 🇰🇷 :kr: 🇨🇳 :cn: 🇺🇸 :us: 🇫🇷 :fr: 🇪🇸 :es: 🇮🇹 :it: 🇷🇺 :ru: 🇬🇧 :gb: 🇬🇧 :uk: 🇩🇪 :de: Symbols 预览 语法 预览 语法 预览 语法 1️⃣ :one: 2️⃣ :two: 3️⃣ :three: 4️⃣ :four: 5️⃣ :five: 6️⃣ :six: 7️⃣ :seven: 8️⃣ :eight: 9️⃣ :nine: 🔟 :keycap_ten: 🔢 :1234: 0️⃣ :zero: #️⃣ :hash: 🔣 :symbols: ◀️ :arrow_backward: ⬇️ :arrow_down: ▶️ :arrow_forward: ⬅️ :arrow_left: 🔠 :capital_abcd: 🔡 :abcd: 🔤 :abc: ↙️ :arrow_lower_left: ↘️ :arrow_lower_right: ➡️ :arrow_right: ⬆️ :arrow_up: ↖️ :arrow_upper_left: ↗️ :arrow_upper_right: ⏬ :arrow_double_down: ⏫ :arrow_double_up: 🔽 :arrow_down_small: ⤵️ :arrow_heading_down: ⤴️ :arrow_heading_up: ↩️ :leftwards_arrow_with_hook: ↪️ :arrow_right_hook: ↔️ :left_right_arrow: ↕️ :arrow_up_down: 🔼 :arrow_up_small: 🔃 :arrows_clockwise: 🔄 :arrows_counterclockwise: ⏪ :rewind: ⏩ :fast_forward: ℹ️ :information_source: 🆗 :ok: 🔀 :twisted_rightwards_arrows: 🔁 :repeat: 🔂 :repeat_one: 🆕 :new: 🔝 :top: 🆙 :up: 🆒 :cool: 🆓 :free: 🆖 :ng: 🎦 :cinema: 🈁 :koko: 📶 :signal_strength: :u5272: :u5272: :u5408: :u5408: :u55b6: :u55b6: :u6307: :u6307: :u6708: :u6708: :u6709: :u6709: 🈵 :u6e80: :u7121: :u7121: :u7533: :u7533: :u7a7a: :u7a7a: :u7981: :u7981: 🈂️ :sa: 🚻 :restroom: 🚹 :mens: 🚺 :womens: 🚼 :baby_symbol: 🚭 :no_smoking: 🅿️ :parking: ♿️ :wheelchair: 🚇 :metro: 🛄 :baggage_claim: 🉑 :accept: 🚾 :wc: 🚰 :potable_water: 🚮 :put_litter_in_its_place: ㊙️ :secret: ㊗️ :congratulations: Ⓜ️ :m: 🛂 :passport_control: 🛅 :left_luggage: 🛃 :customs: 🉐 :ideograph_advantage: 🆑 :cl: 🆘 :sos: 🆔 :id: 🚫 :no_entry_sign: 🔞 :underage: 📵 :no_mobile_phones: 🚯 :do_not_litter: 🚱 :non-potable_water: 🚳 :no_bicycles: 🚷 :no_pedestrians: 🚸 :children_crossing: ⛔️ :no_entry: ✳️ :eight_spoked_asterisk: ❇️ :sparkle: ✴️ :eight_pointed_black_star: 💟 :heart_decoration: 🆚 :vs: 📳 :vibration_mode: 📴 :mobile_phone_off: 💹 :chart: 💱 :currency_exchange: ♈️ :aries: ♉️ :taurus: ♊️ :gemini: ♋️ :cancer: ♌️ :leo: ♍️ :virgo: ♎️ :libra: ♏️ :scorpius: ♐️ :sagittarius: ♑️ :capricorn: ♒️ :aquarius: ♓️ :pisces: ⛎ :ophiuchus: 🔯 :six_pointed_star: ❎ :negative_squared_cross_mark: 🅰️ :a: 🅱️ :b: 🆎 :ab: 🅾️ :o2: 💠 :diamond_shape_with_a_dot_inside: ♻️ :recycle: 🔚 :end: 🔙 :back: 🔛 :on: 🔜 :soon: 🕐 :clock1: 🕜 :clock130: 🕙 :clock10: 🕥 :clock1030: 🕚 :clock11: 🕦 :clock1130: 🕛 :clock12: 🕧 :clock1230: 🕑 :clock2: 🕝 :clock230: 🕒 :clock3: 🕞 :clock330: 🕓 :clock4: 🕟 :clock430: 🕔 :clock5: 🕠 :clock530: 🕕 :clock6: 🕡 :clock630: 🕖 :clock7: 🕢 :clock730: 🕗 :clock8: 🕣 :clock830: 🕘 :clock9: 🕤 :clock930: 💲 :heavy_dollar_sign: ©️ :copyright: ®️ :registered: ™️ :tm: ❌ :x: ❗️ :heavy_exclamation_mark: ‼️ :bangbang: ⁉️ :interrobang: ⭕️ :o: ✖️ :heavy_multiplication_x: ➕ :heavy_plus_sign: ➖ :heavy_minus_sign: ➗ :heavy_division_sign: 💮 :white_flower: 💯 :100: ✔️ :heavy_check_mark: ☑️ :ballot_box_with_check: 🔘 :radio_button: 🔗 :link: ➰ :curly_loop: 〰️ :wavy_dash: 〽️ :part_alternation_mark: 🔱 :trident: ▪️ :black_small_square: ▫️ :white_small_square: ◾️ :black_medium_small_square: ◽️ :white_medium_small_square: ◼️ :black_medium_square: ◻️ :white_medium_square: ⬛️ :black_large_square: ⬜️ :white_large_square: ✅ :white_check_mark: 🔲 :black_square_button: 🔳 :white_square_button: ⚫️ :black_circle: ⚪️ :white_circle: 🔴 :red_circle: 🔵 :large_blue_circle: 🔷 :large_blue_diamond: 🔶 :large_orange_diamond: 🔹 :small_blue_diamond: 🔸 :small_orange_diamond: 🔺 :small_red_triangle: 🔻 :small_red_triangle_down: :shipit: :shipit:","link":"/posts/2868108500.html"}],"tags":[{"name":"DP","slug":"DP","link":"/tags/DP/"},{"name":"字符串","slug":"字符串","link":"/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"OI","slug":"OI","link":"/tags/OI/"},{"name":"LCA","slug":"LCA","link":"/tags/LCA/"},{"name":"模拟","slug":"模拟","link":"/tags/%E6%A8%A1%E6%8B%9F/"},{"name":"并查集","slug":"并查集","link":"/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"贪心","slug":"贪心","link":"/tags/%E8%B4%AA%E5%BF%83/"},{"name":"图论","slug":"图论","link":"/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"拓扑排序","slug":"拓扑排序","link":"/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"},{"name":"数论","slug":"数论","link":"/tags/%E6%95%B0%E8%AE%BA/"},{"name":"最短路","slug":"最短路","link":"/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"name":"树链剖分","slug":"树链剖分","link":"/tags/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"},{"name":"文化课","slug":"文化课","link":"/tags/%E6%96%87%E5%8C%96%E8%AF%BE/"},{"name":"Tarjan","slug":"Tarjan","link":"/tags/Tarjan/"},{"name":"生活","slug":"生活","link":"/tags/%E7%94%9F%E6%B4%BB/"},{"name":"工具","slug":"工具","link":"/tags/%E5%B7%A5%E5%85%B7/"}],"categories":[{"name":"题解","slug":"题解","link":"/categories/%E9%A2%98%E8%A7%A3/"},{"name":"总结","slug":"总结","link":"/categories/%E6%80%BB%E7%BB%93/"},{"name":"学习笔记","slug":"学习笔记","link":"/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"回顾","slug":"回顾","link":"/categories/%E5%9B%9E%E9%A1%BE/"},{"name":"记录","slug":"记录","link":"/categories/%E8%AE%B0%E5%BD%95/"},{"name":"其他","slug":"其他","link":"/categories/%E5%85%B6%E4%BB%96/"}]}